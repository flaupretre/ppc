<?php                                                         ?><?php #PHK M M1.4.0        V1.4.0        FS192517      PO241         SSO88571       STO89188       FTO113499      SIO192517      CRC8c207324 PCO800         PCS87771       ?><?php
 if (!class_exists('PHK',0)) { $_phk_fp=fopen(__FILE__,'rb'); $_phk_buf=fread($_phk_fp,241); fseek($_phk_fp,(int)(substr($_phk_buf,212,11)),SEEK_SET); $_phk_size=(int)(substr($_phk_buf,227,11)); $_phk_code=''; while (strlen($_phk_code) < $_phk_size) $_phk_code .=fread($_phk_fp,$_phk_size-strlen($_phk_code)); fclose($_phk_fp); eval($_phk_code); unset($_phk_code); unset($_phk_fp); unset($_phk_buf); unset($_phk_size); } $_phk_cmd=null; $_phk_ret=0; PHK::prolog(__FILE__,$_phk_cmd,$_phk_ret); eval($_phk_cmd); return $_phk_ret; __halt_compiler(); ?>ÿÿÿÿ
 if (!class_exists('Automap',false)) { class Automap { const VERSION='1.1.0'; const MAGIC="AUTOMAP  M\024\x8\6\3"; const T_FUNCTION='F'; const T_CONSTANT='C'; const T_CLASS='L'; const T_EXTENSION='E'; const F_SCRIPT='S'; const F_EXTENSION='X'; const F_PACKAGE='P'; private static $type_strings=array( self::T_FUNCTION => 'function', self::T_CONSTANT => 'constant', self::T_CLASS => 'class', self::T_EXTENSION => 'extension', self::F_SCRIPT => 'script', self::F_EXTENSION => 'extension file', self::F_PACKAGE => 'package' ); private static $failure_handlers=array(); private static $success_handlers=array(); private static $support_constant_autoload; private static $support_function_autoload; private static $automaps; private static $mount_order; private static function is_web() { return (php_sapi_name()!='cli'); } private static $simul_inode_array=array(); private static $simul_inode_index=1; private static function path_unique_id($prefix,$path,&$mtime) { if (($s=stat($path))===false) throw new Exception("$path: File not found"); $dev=$s[0]; $inode=$s[1]; $mtime=$s[9]; if ($inode==0) { $rpath=realpath($path); if ($rpath === false) throw new Exception("$path: Cannot compute realpath"); if (isset(self::$simul_inode_array[$rpath])) $inode=self::$simul_inode_array[$rpath]; else { $inode=self::$simul_inode_index++; self::$simul_inode_array[$rpath]=$inode; } } return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime); } public static function init() { self::$automaps=array(); self::$mount_order=array(); $f=new ReflectionFunction('function_exists'); self::$support_function_autoload=($f->getNumberOfParameters()==2); $f=new ReflectionFunction('defined'); self::$support_constant_autoload=($f->getNumberOfParameters()==2); } public static function register_failure_handler($callable) { self::$failure_handlers[]=$callable; } public static function register_success_handler($callable) { self::$success_handlers[]=$callable; } public static function key($type,$symbol) { if (($type==self::T_EXTENSION) ||($type==self::T_FUNCTION) ||($type==self::T_CLASS)) $symbol=strtolower($symbol); return $type.$symbol; } public static function get_type_from_key($key) { if (strlen($key) <= 1) throw new Exception('Invalid key'); return $key{0}; } public static function get_symbol_from_key($key) { if (strlen($key) <= 1) throw new Exception('Invalid key'); return substr($key,1,strcspn($key,'|',1)); } public static function get_type_string($type) { if (!isset(self::$type_strings[$type])) throw new Exception("$type: Invalid type"); return self::$type_strings[$type]; } public static function string_to_type($string) { $type=array_search($string,self::$type_strings,true); if ($type===false) throw new Exception("$type: Invalid type"); return $type; } public static function is_mounted($mnt) { return isset(self::$automaps[$mnt]); } public static function validate($mnt) { if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point'); return $mnt; } public static function instance($mnt) { self::validate($mnt); return self::$automaps[$mnt]; } public static function mnt_list() { return array_keys(self::$automaps); } public static function path_to_mnt($path) { $dummy=null; $mnt=self::path_unique_id('m',$path,$dummy); if (self::is_mounted($mnt)) return $mnt; throw new Exception($path.': path is not mounted'); } public static function mount($path,$base_dir=null,$mnt=null,$flags=0) { try { if (is_null($mnt)) { $dummy=null; $mnt=self::path_unique_id('m',$path,$dummy); } if (self::is_mounted($mnt)) { self::instance($mnt)->mnt_count++; return $mnt; } if (is_null($base_dir)) { $base_dir=dirname($path); if (($base_dir!=='/') && ($base_dir!=='\\')) $base_dir .= DIRECTORY_SEPARATOR; } self::$mount_order[] =self::$automaps[$mnt]=new self($path,$base_dir,$mnt,$flags); } catch (Exception $e) { if (isset($mnt) && self::is_mounted($mnt)) unset(self::$automaps[$mnt]); throw new Exception($path.': Cannot mount - '.$e->getMessage()); } return $mnt; } public static function umount($mnt) { if (self::is_mounted($mnt)) { $map=self::instance($mnt); if ((--$map->mnt_count) > 0) return; foreach (self::$mount_order as $order => $obj) { if ($obj===$map) self::$mount_order[$order]=null; } unset(self::$automaps[$mnt]); } } private static function symbol_is_defined($type,$symbol) { switch($type) { case self::T_CONSTANT: return (self::$support_constant_autoload ? defined($symbol,false) : defined($symbol)); case self::T_FUNCTION: return (self::$support_function_autoload ? function_exists($symbol,false) : function_exists($symbol)); case self::T_CLASS: return class_exists($symbol,false) || interface_exists($symbol,false); case self::T_EXTENSION: return extension_loaded($symbol); } } public static function autoload_hook($symbol,$type=self::T_CLASS) { self::get_symbol($type,$symbol,true,false); } private static function get_symbol($type,$symbol,$autoload=false ,$exception=false) { if (!$autoload) { if (self::symbol_is_defined($type,$symbol)) return true; } $key=self::key($type,$symbol); foreach(array_reverse(self::$mount_order) as $map) { if ((!is_null($map)) && $map->resolve_key($key)) return true; } foreach (self::$failure_handlers as $callable) $callable($key); if ($exception) throw new Exception('Automap: Unknown ' .self::get_type_string($type).': '.$symbol); return false; } public static function get_function($symbol) { return self::get_symbol(self::T_FUNCTION,$symbol,false,false); } public static function get_constant($symbol) { return self::get_symbol(self::T_CONSTANT,$symbol,false,false); } public static function get_class($symbol) { return self::get_symbol(self::T_CLASS,$symbol,false,false); } public static function get_extension($symbol) { return self::get_symbol(self::T_EXTENSION,$symbol,false,false); } public static function require_function($symbol) { return self::get_symbol(self::T_FUNCTION,$symbol,false,true); } public static function require_constant($symbol) { return self::get_symbol(self::T_CONSTANT,$symbol,false,true); } public static function require_class($symbol) { return self::get_symbol(self::T_CLASS,$symbol,false,true); } public static function require_extension($symbol) { return self::get_symbol(self::T_EXTENSION,$symbol,false,true); } private $path; private $base_dir; private $mnt; private $flags; private $mnt_count; private $symbols=null; private $options=null; private $version; private $min_version; private function __construct($path,$base_dir,$mnt,$flags=0) { $this->path=$path; $this->mnt=$mnt; $this->base_dir=$base_dir; $this->flags=$flags; $this->mnt_count=1; } private function realize() { if (!is_null($this->symbols)) return; try { if (($buf=@file_get_contents($this->path))===false) throw new Exception($this->path.': Cannot read map file'); if (substr($buf,0,14)!=self::MAGIC) throw new Exception('Bad Magic'); $this->min_version=trim(substr($buf,16,12)); if (version_compare($this->min_version,self::VERSION) > 0) throw new Exception('Cannot understand this automap.'. ' Requires at least Automap version '.$this->min_version); $this->version=trim(substr($buf,30,12)); if (strlen($buf)!=($sz=(int)substr($buf,45,8))) throw new Exception('Invalid file size. Should be '.$sz); if (($buf=unserialize(substr($buf,53)))===false) throw new Exception('Cannot unserialize data from map file'); if (!is_array($buf)) throw new Exception('Map file should contain an array'); if (!array_key_exists('map',$buf)) throw new Exception('No symbol table'); if (!array_key_exists('options',$buf)) throw new Exception('No options array'); if (!is_array($this->symbols=$buf['map'])) throw new Exception('Symbol table should contain an array'); if (!is_array($this->options=$buf['options'])) throw new Exception('Options should be an array'); } catch (Exception $e) { $this->symbols=array(); throw new Exception($this->path.': Cannot load map - '.$e->getMessage()); } } public function path() { self::validate($this->mnt); return $this->path; } public function base_dir() { self::validate($this->mnt); return $this->base_dir; } public function mnt() { self::validate($this->mnt); return $this->mnt; } public function flags() { self::validate($this->mnt); return $this->flags; } public function symbols() { self::validate($this->mnt); $this->realize(); return $this->symbols; } public function options() { self::validate($this->mnt); $this->realize(); return $this->options; } public function version() { self::validate($this->mnt); $this->realize(); return $this->version; } public function min_version() { self::validate($this->mnt); $this->realize(); return $this->min_version; } public function option($opt) { self::validate($this->mnt); $this->realize(); return (isset($this->options[$opt]) ? $options[$opt] : null); } public function symbol_count() { self::validate($this->mnt); return count($this->symbols()); } private function call_success_handlers($key,$value) { foreach (self::$success_handlers as $callable) $callable($key,$this->mnt,$value); } private function resolve_key($key) { $this->realize(); if (!isset($this->symbols[$key])) return false; $value=$this->symbols[$key]; $fname=self::get_symbol_from_key($value); switch($ftype=self::get_type_from_key($value)) { case self::F_EXTENSION: if (!dl($fname)) return false; $this->call_success_handlers($key,$value); break; case self::F_SCRIPT: $file=$this->base_dir.$fname; { require($file); } $this->call_success_handlers($key,$value); break; case self::F_PACKAGE: $file=$this->base_dir.$fname; error_reporting(($errlevel=error_reporting()) & ~E_NOTICE); $mnt=require($file); error_reporting($errlevel); self::instance($mnt)->resolve_key($key); break; default: throw new Exception('<'.$ftype.'>: Unknown file type in map'); } return true; } public function show($subfile_to_url_function=null) { self::validate($this->mnt); $this->realize(); if ($html=self::is_web()) { $this->html_show($subfile_to_url_function); return; } echo "\n* Global information :\n\n"; echo '	Map version : '.$this->version."\n"; echo '	Min reader version : '.$this->min_version."\n"; echo '	Symbol count : '.$this->symbol_count()."\n"; echo "\n* Options :\n\n"; print_r($this->options); echo "\n* Symbols :\n\n"; $ktype_len=$kname_len=4; $fname_len=10; foreach($this->symbols as $key => $value) { $ktype=self::get_type_string(self::get_type_from_key($key)); $kname=self::get_symbol_from_key($key); $ftype=self::get_type_from_key($value); $fname=self::get_symbol_from_key($value); $ktype_len=max($ktype_len,strlen($ktype)+2); $kname_len=max($kname_len,strlen($kname)+2); $fname_len=max($fname_len,strlen($fname)+2); } echo str_repeat('-',$ktype_len+$kname_len+$fname_len+8)."\n"; echo '|'.str_pad('Type',$ktype_len,' ',STR_PAD_BOTH); echo '|'.str_pad('Name',$kname_len,' ',STR_PAD_BOTH); echo '| T '; echo '|'.str_pad('Defined in',$fname_len,' ',STR_PAD_BOTH); echo "|\n"; echo '|'.str_repeat('-',$ktype_len); echo '|'.str_repeat('-',$kname_len); echo '|---'; echo '|'.str_repeat('-',$fname_len); echo "|\n"; foreach($this->symbols as $key => $value) { $ktype=ucfirst(self::get_type_string(self::get_type_from_key($key))); $kname=self::get_symbol_from_key($key); $ftype=self::get_type_from_key($value); $fname=self::get_symbol_from_key($value); echo '| '.str_pad(ucfirst($ktype),$ktype_len-1,' ',STR_PAD_RIGHT); echo '| '.str_pad($kname,$kname_len-1,' ',STR_PAD_RIGHT); echo '| '.$ftype.' '; echo '| '.str_pad($fname,$fname_len-1,' ',STR_PAD_RIGHT); echo "|\n"; } } private function html_show($subfile_to_url_function=null) { echo "<h2>Global information</h2>"; echo '<table border=0>'; echo '<tr><td>Map version:&nbsp;</td><td>' .htmlspecialchars($this->version).'</td></tr>'; echo '<tr><td>Min reader version:&nbsp;</td><td>' .htmlspecialchars($this->min_version).'</td></tr>'; echo '<tr><td>Symbol count:&nbsp;</td><td>' .$this->symbol_count().'</td></tr>'; echo '</table>'; echo "<h2>Options</h2>"; echo '<pre>'.htmlspecialchars(print_r($this->options,true)).'</pre>'; echo "<h2>Symbols</h2>"; echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 ' .'cellspacing=0 style="border-collapse: collapse"><tr><th>Type</th>' .'<th>Name</th><th>FT</th><th>Defined in</th></tr>'; foreach($this->symbols as $key => $value) { $ktype=ucfirst(self::get_type_string(self::get_type_from_key($key))); $kname=self::get_symbol_from_key($key); $ftype=self::get_type_from_key($value); $fname=self::get_symbol_from_key($value); echo '<tr><td>'.$ktype.'</td><td>'.htmlspecialchars($kname) .'</td><td align=center>'.$ftype.'</td><td>'; if (!is_null($subfile_to_url_function)) echo '<a href="'.call_user_func($subfile_to_url_function,$fname).'">'; echo htmlspecialchars($fname); if (!is_null($subfile_to_url_function)) echo '</a>'; echo '</td></tr>'; } echo '</table>'; } public function export($path=null) { self::validate($this->mnt); $this->realize(); $file=(is_null($path) ? "STDOUT" : $path); $fp=fopen($file,'w'); if (!$fp) throw new Exception("$file: Cannot open for writing"); foreach($this->symbols as $key => $value) fwrite($fp,"$key $value\n"); fclose($fp); } } if (!defined('_AUTOMAP_DISABLE_REGISTER')) { if (!extension_loaded('spl')) throw new Exception("Automap requires the SPL extension"); spl_autoload_register('Automap::autoload_hook'); } Automap::init(); } if (!class_exists('PHK_Util',false)) { class PHK_Util { private static $verbose=true; public static function msg($msg) { if (self::$verbose) echo $msg."\n"; } public static function var_type($var) { return is_object($var) ? 'object '.get_class($var) : gettype($var); } public static function is_web() { return (php_sapi_name()!='cli'); } public static function is_windows() { return (substr(PHP_OS, 0, 3) == 'WIN'); } public static function file_suffix($filename) { $dotpos=strrpos($filename,'.'); if ($dotpos===false) return ''; return strtolower(substr($filename,$dotpos+1)); } public static function combine_path($dir,$rpath) { if ($dir=='.' || $dir=='') return $rpath; $rpath=trim($rpath,'/'); $rpath=trim($rpath,'\\'); $separ=(strpos($dir,':')!==false) ? '/' : DIRECTORY_SEPARATOR; if (($dir==='/') || ($dir==='\\')) $separ=''; else { $c=substr($dir,-1,1); if (($c==='/') || ($c=='\\')) $dir=rtrim($dir,$c); } return $dir.$separ.$rpath; } public static function load_extension($ext) { if (extension_loaded($ext)) return; if (PHP_OS == 'AIX') $suffix = 'a'; else $suffix = PHP_SHLIB_SUFFIX; @dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix); if (!extension_loaded($ext)) throw new Exception("$ext: Cannot load extension"); } public static function load_extensions($ext_list) { $failed_ext=array(); foreach($ext_list as $ext) { try { self::load_extension($ext); } catch (Exception $e) { $failed_ext[]=$ext; } } if (count($failed_ext)) throw new Exception('Cannot load the following required extension(s): ' .implode(' ',$failed_ext)); } public static function substr($buf,$position,$len=NULL) { $str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len); if ($str===false) $str=''; return $str; } private static $mqr_exists=null; private static $mqr_level=0; private static $mqr_save; public static function disable_mqr() { if (is_null(self::$mqr_exists)) self::$mqr_exists=function_exists('set_magic_quotes_runtime'); if (!self::$mqr_exists) return; if (self::$mqr_level==0) { self::$mqr_save=get_magic_quotes_runtime(); set_magic_quotes_runtime(0); } self::$mqr_level++; } public static function restore_mqr() { if (is_null(self::$mqr_exists)) self::$mqr_exists=function_exists('set_magic_quotes_runtime'); if (!self::$mqr_exists) return; self::$mqr_level--; if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save); } public static function timestring($time=null) { if ($time=='unlimited') return $time; if (is_null($time)) $time=time(); return @strftime('%d-%b-%Y %H:%M %z',$time); } public static function http_base_url() { if (!self::is_web()) return ''; if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF']; $phpself=$_SERVER['PHP_SELF']; $slen=strlen($phpself); $pathinfo=$_SERVER['PATH_INFO']; $ilen=strlen($pathinfo); if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo)) $phpself=substr($phpself,0,$slen-$ilen); return $phpself; } public static function http_301_redirect($path) { header('Location: http://'.$_SERVER['HTTP_HOST'].self::http_base_url().$path); header('HTTP/1.1 301 Moved Permanently'); exit(0); } public static function http_404_fail() { header("HTTP/1.0 404 Not Found"); exit(1); } public static function http_403_fail() { header("HTTP/1.0 403 Forbidden"); exit(1); } public static function bool2str($cond) { return $cond ? 'Yes' : 'No'; } public static function readfile($path) { if (($data=@file_get_contents($path))===false) throw new Exception($path.': Cannot get file content'); return $data; } public static function scandir($path) { if (($subnames=scandir($path))===false) throw new Exception($path.': Cannot read directory'); $a=array(); foreach($subnames as $f) if (($f!='.') && ($f!='..')) $a[]=$f; return $a; } public static function trace($msg) { if (($tfile=getenv('PHK_TRACE_FILE')) !== false) { if (($fp=fopen($tfile,'a'))===false) throw new Exception($tfile.': Cannot open trace file'); fwrite($fp,self::timestring().': '.$msg."\n"); fclose($fp); } } public static function delta_ms($start) { $delta=microtime(true)-$start; return round($delta*1000,2).' ms'; } public static function mk_array($data) { if (is_null($data)) return array(); if (!is_array($data)) $data=array($data); return $data; } public static function display_slow_path() { if (getenv('PHK_DEBUG_SLOW_PATH')!==false) { $html=PHK_Util::is_web(); if (isset($GLOBALS['__PHK_SLOW_PATH'])) $data="Slow path entered at:\n".$GLOBALS['__PHK_SLOW_PATH']; else $data="Fast path OK\n"; PHK::info_section($html,'Fast path result'); if ($html) echo "<pre>"; echo $data; if ($html) echo "/<pre>"; } } public static function slow_path() { if ((getenv('PHK_DEBUG_SLOW_PATH')!==false) && (!isset($GLOBALS['__PHK_SLOW_PATH']))) { $e=new Exception(); $GLOBALS['__PHK_SLOW_PATH']=$e->getTraceAsString(); } } public static function format_error($msg) { throw new Exception('Format error: '.$msg); } public static function get_min_version($mnt,$caching) { return PHK_Stream::get_file(false,PHK_Mgr::command_uri($mnt ,'magic_field&name=mv'),$mnt,'magic_field',array('name' => 'mv'),'' ,$caching); } public static function get_options($mnt,$caching) { return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt ,'OPTIONS'),$mnt,'section',array('name' => 'OPTIONS'),'',$caching)); } public static function get_build_info($mnt,$caching) { return unserialize(PHK_Stream::get_file(false,PHK_Mgr::section_uri($mnt ,'BUILD_INFO'),$mnt,'section',array('name' => 'BUILD_INFO'),'',$caching)); } public static function call_method($object,$method,$args) { return call_user_func_array(array($object,$method),$args); } public static function run_webinfo($phk) { $phk->proxy()->crc_check(); $phkw=new PHK_Webinfo($phk); $phkw->run(); } public static function atomic_write($path,$data) { $tmpf=tempnam(dirname($path),'tmp_'); if (file_put_contents($tmpf,$data)!=strlen($data)) throw new Exception($tmpf.": Cannot write"); if (PHK_Util::is_windows()) @unlink($path); if (!rename($tmpf,$path)) { unlink($tmpf); throw new Exception($path,'Cannot replace file'); } } private static $simul_inode_array=array(); private static $simul_inode_index=1; public static function path_unique_id($prefix,$path,&$mtime) { if (($s=stat($path))===false) throw new Exception("$path: File not found"); $dev=$s[0]; $inode=$s[1]; $mtime=$s[9]; if ($inode==0) { $rpath=realpath($path); if ($rpath === false) throw new Exception("$path: Cannot compute realpath"); if (isset(self::$simul_inode_array[$rpath])) $inode=self::$simul_inode_array[$rpath]; else { $inode=self::$simul_inode_index++; self::$simul_inode_array[$rpath]=$inode; } } return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime); } } } if (!class_exists('PHK_File',false)) { class PHK_File { private $fp=null; private $path; private $size; private $open_count=0; private $keep_open_flag; public function __construct($path,$flags) { $this->set_params($path,$flags); if (($this->size=filesize($path))===false) throw new Exception($path.': Cannot get file size'); } public function set_params($path,$flags) { $this->path=$path; $this->keep_open_flag=PHK_Mgr::is_a_phk_uri($path); } public function __sleep() { return array('size'); } public function __destruct() { $this->really_close(); } private function really_close() { if (!is_null($this->fp)) { fclose($this->fp); $this->fp=null; $this->open_count=0; } } public function _open() { if (is_null($this->fp)) { if (!($this->fp=fopen($this->path,'rb',false))) throw new Exception($this->path.': Cannot open for reading'); $this->open_count=1; } else $this->open_count++; } public function _close() { $this->open_count--; if (($this->open_count <= 0) && (!$this->keep_open_flag)) $this->really_close(); } private function read($size) { $data=''; $nb_chunks=intval($size/8192); $rest=$size % 8192; PHK_Util::disable_mqr(); while ($nb_chunks > 0) { $data .= $this->read_chunk(8192); $nb_chunks--; } if ($rest) $data .= $this->read_chunk($rest); PHK_Util::restore_mqr(); return $data; } private function read_chunk($size) { $buf=fread($this->fp,$size); if ($buf===false) throw new Exception('Cannot read'); if (($bsize=strlen($buf))!=$size) throw new Exception("Short read ($bsize/$size)"); return $buf; } public function _read_block($offset,$size) { try { $this->_open(); if (fseek($this->fp,$offset,SEEK_SET) == -1) throw new Exception('Cannot seek'); $buf=$this->read($size); $this->_close(); } catch (Exception $e) { $this->_close(); throw new Exception($e->getMessage()); } return $buf; } public function size() { return $this->size; } public function path() { return $this->path; } } } if (!class_exists('PHK_FileSpace',false)) { class PHK_FileSpace { public $file; private $offset; private $size; public function __construct($arg1,$arg2,$size=null) { if (is_string($arg1)) { $this->file=new PHK_File($arg1,$arg2); $this->offset=0; $this->size=$this->file->size(); } else { if ((!($arg1 instanceof self)) || (!is_numeric($arg2)) || (!is_numeric($size)) || ($arg2 < 0) || (($arg2+$size) > $arg1->size)) throw new Exception("PHK_FileSpace: cannot create - invalid arguments"); $this->file=$arg1->file; $this->offset=$arg1->offset + $arg2; $this->size=$size; } } public function read_block($offset=0,$size=null) { if (is_null($size)) $size=$this->size-$offset; if (($offset<0)||($size<0)||($offset+$size>$this->size)) throw new Exception('PHK_FileSpace: Read out of bound'); if ($size==0) return ''; $data=$this->file->_read_block($this->offset+$offset,$size); return $data; } public function open() { $this->file->_open(); } public function close() { $this->file->_close(); } public function size() { return $this->size; } public function path() { return $this->file->path(); } } } if (!class_exists('PHK_Cache',false)) { class PHK_Cache { const VERSION='1.1.0'; const TTL=3600; private static $caches=array("apc","xcache","eaccelerator"); private static $cache_name; private static $cache=null; private static $cache_maxsize=524288; public static function cache_id($prefix,$key) { return 'phk.'.$prefix.'.'.$key; } private static function set_cache_object() { if (is_null(self::$cache)) { self::$cache=false; self::$cache_name='none'; foreach(self::$caches as $c) { if (!extension_loaded($c)) continue; $class='PHK_Cache_'.$c; $obj=new $class; try { $status=$obj->init(); } catch (Exception $e) { $status=false; } if ($status) { self::$cache=$obj; self::$cache_name=$c; break; } unset($obj); } } } public static function set_cache_maxsize($size) { $this->cache_maxsize=$size; } public static function cache_name() { if (is_null(self::$cache)) self::set_cache_object(); return self::$cache_name; } public static function cache_present() { if (is_null(self::$cache)) self::set_cache_object(); return (self::$cache!==false); } public static function get($id) { if (is_null(self::$cache)) self::set_cache_object(); if (self::$cache===false) return null; $result=self::$cache->get($id); if ($result===false) $result=null; return $result; } public static function set($id,$data) { if (is_null(self::$cache)) self::set_cache_object(); if (is_object(self::$cache)) { if (is_string($data) && (strlen($data) > self::$cache_maxsize)) return; PHK_Util::trace("Writing cache: id=$id"); self::$cache->set($id,$data); } } } abstract class PHK_Cache_Base { abstract public function init(); abstract public function get($id); abstract public function set($id,$data); } class PHK_Cache_apc extends PHK_Cache_Base { public function init() { return PHK_Util::is_web() || ini_get('apc.enable_cli'); } public function get($id) { return apc_fetch($id); } public function set($id,$data) { apc_store($id,$data,PHK_Cache::TTL); } } class PHK_Cache_xcache extends PHK_Cache_Base { public function init() { return PHK_Util::is_web(); } public function get($id) { return xcache_get($id); } public function set($id,$data) { xcache_set($id,$data,PHK_Cache::TTL); } } class PHK_Cache_eaccelerator extends PHK_Cache_Base { public function init() { if (!function_exists('eaccelerator_get')) return false; return PHK_Util::is_web(); } public function get($id) { return eaccelerator_get($id); } public function set($id,$data) { eaccelerator_put($id,$data,PHK_Cache::TTL); } } } if (!class_exists('PHK_Proxy',false)) { class PHK_Proxy { const VERSION='1.3.0'; const INTERP_LEN=64; const VERSION_SIZE=12; const OFFSET_SIZE=11; const MAGIC_STRING="#PHK M\024\x8\6\3"; const MAGIC_STRING_LEN=10; const MAGIC_STRING_OFFSET=70; const MAGIC_LINE_LEN=177; const AUTOMAP_SECTION='AUTOMAP'; const CRC_OFFSET=200; protected $stree=null; public $ftree=null; protected $flags; protected $fspace; private $magic=null; public function __construct($path,$flags) { try { PHK_Util::slow_path(); $this->flags=$flags; if (!($this->flags & PHK::F_CREATOR)) { if (! self::file_is_package($path)) throw new Exception($path.'is not a PHK package'); $this->fspace= new PHK_FileSpace($path,$flags); $this->fspace->open(); $this->get_magic_values(); if ($this->fspace->size()!=$this->magic['fs']) PHK_Util::format_error('Invalid file size. Should be '.$this->magic['fs']); $this->stree=PHK_Tree::create_from_edata( $this->fspace->read_block($this->magic['sso'] ,$this->magic['sto']-$this->magic['sso']) ,new PHK_FileSpace($this->fspace,$this->magic['sto'] ,$this->magic['fto']-$this->magic['sto'])); $this->ftree=PHK_Tree::create_from_edata($this->section('FTREE') ,new PHK_FileSpace($this->fspace,$this->magic['fto'] ,$this->magic['sio']-$this->magic['fto'])); $this->fspace->close(); } else { $this->ftree=PHK_Tree::create_empty(); $this->stree=PHK_Tree::create_empty(); } } catch (Exception $e) { throw new Exception('While initializing PHK proxy - '.$e->getMessage()); } } public function crc_check() { self::check_crc_buffer($this->fspace->read_block()); } public static function insert_crc($buffer,$crc) { return substr_replace($buffer,$crc,self::CRC_OFFSET,8); } private static function get_crc($buffer) { return substr($buffer,self::CRC_OFFSET,8); } private static function compute_crc($buffer) { return sprintf('%08x',crc32(self::insert_crc($buffer,'00000000'))); } public static function check_crc_buffer($buffer) { if (self::compute_crc($buffer) !== self::get_crc($buffer)) throw new Exception('Wrong CRC'); } public static function fix_crc($buffer) { return self::insert_crc($buffer,self::compute_crc($buffer)); } public static function file_is_package($path) { if (filesize($path)< (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false; if (($fp=fopen($path,'rb',false))===false) return false; if (fseek($fp,self::MAGIC_STRING_OFFSET) != 0) return false; if (($m=fread($fp,self::MAGIC_STRING_LEN))===false) return false; fclose($fp); return ($m===self::MAGIC_STRING); } public static function data_is_package($data) { if (strlen($data) < (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false; return (substr($data,self::MAGIC_STRING_OFFSET,self::MAGIC_STRING_LEN) ===self::MAGIC_STRING); } public function get_magic_values() { $buf=$this->fspace->read_block(self::INTERP_LEN,self::MAGIC_LINE_LEN); $fsize=(int)substr($buf,47,self::OFFSET_SIZE); $sio=(int)substr($buf,121,self::OFFSET_SIZE); $crc=null; sscanf(substr($buf,136,8),'%08x',$crc); $this->magic=array( 'mv' => trim(substr($buf,18,self::VERSION_SIZE)), 'v' => trim(substr($buf,32,self::VERSION_SIZE)), 'fs' => $fsize, 'po' => (int)substr($buf,61,self::OFFSET_SIZE), 'sso' => (int)substr($buf,76,self::OFFSET_SIZE), 'sto' => (int)substr($buf,91,self::OFFSET_SIZE), 'fto' => (int)substr($buf,106,self::OFFSET_SIZE), 'sio' => $sio, 'pco' => (int)substr($buf,148,self::OFFSET_SIZE), 'pcs' => (int)substr($buf,163,self::OFFSET_SIZE), 'crc' => $crc, 'signed' => ($sio != $fsize)); } public function magic_field($name) { return $this->magic[$name]; } private function cache_data() { $this->stree->walk('read'); $this->ftree->walk('read'); } private function clear_cache() { $this->stree->walk('clear_cache'); $this->ftree->walk('clear_cache'); } public function path_list() { return $this->ftree->path_list(); } public function section_list() { return $this->stree->path_list(); } public function signed() { return $this->magic['signed']; } public function interp() { $block=$this->fspace->read_block(0,self::INTERP_LEN); if ((($block{0}!='#')||($block{1}!='!')) && (($block{0}!='<')||($block{1}!='?'))) throw new Exception('Invalid interpreter block'); return ($block{0}=='#') ? trim(substr($block,2)) : ''; } public static function interp_block($interp) { if (($interp!=='') && (strlen($interp) > (PHK_Proxy::INTERP_LEN-3))) throw new Exception('Length of interpreter string is limited to ' .(PHK_Proxy::INTERP_LEN-3).' bytes'); if ($interp==='') return str_pad('<?'.'php',PHK_Proxy::INTERP_LEN-2).'?'.'>'; else return '#!'.str_pad($interp,PHK_Proxy::INTERP_LEN-3)."\n"; } public static function set_buffer_interp($path,$interp='') { return self::fix_crc(substr_replace(PHK_Util::readfile($path) ,self::interp_block($interp),0,PHK_Proxy::INTERP_LEN)); } public function version() { return $this->magic['v']; } public function path() { return $this->fspace->path(); } public function section($name) { try { $node=$this->stree->lookup_file($name); } catch (Exception $e) { throw new Exception($name.': Unknown section'); } try { return $node->read(); } catch (Exception $e) { throw new Exception($name.': Cannot read section - '.$e->getMessage()); } } public function ftree() { return $this->ftree; } public function stree() { return $this->stree; } public function flags() { return $this->flags; } public function display_packages() { $this->ftree->display_packages(); } public function showfiles() { $this->ftree->display(true); } } } if (!class_exists('PHK_Mgr',false)) { class PHK_Mgr { const VERSION='1.4.0'; private static $phk_tab=array(); private static $proxy_tab=array(); private static $tmp_mnt_num=0; private static $caching=null; public static function is_mounted($mnt) { return isset(self::$phk_tab[$mnt]); } public static function validate($mnt) { if (!self::is_mounted($mnt)) throw new Exception($mnt.': Invalid mount point'); return $mnt; } public static function instance($mnt) { self::validate($mnt); return self::$phk_tab[$mnt]; } public static function proxy($mnt) { self::validate($mnt); if (is_null(self::$proxy_tab[$mnt])) { $phk=self::instance($mnt); self::$proxy_tab[$mnt]=new PHK_Proxy($phk->path(),$phk->flags()); } return self::$proxy_tab[$mnt]; } public static function mnt_list() { return array_keys(self::$phk_tab); } public static function set_cache($caching) { self::$caching=$caching; } public static function cache_enabled($mnt,$command,$params,$path) { if (!is_null(self::$caching)) return self::$caching; if (is_null($mnt)) return false; return self::instance($mnt)->cache_enabled($command,$params,$path); } public static function path_to_mnt($path) { $dummy1=$mnt=$dummy2=null; self::compute_mnt($path,$dummy1,$mnt,$dummy2); if (self::is_mounted($mnt)) return $mnt; throw new Exception($path.': path is not mounted'); } public static function mount($path,$flags=0) { try { if ($flags & PHK::F_CREATOR) { $mnt='_tmp_mnt_'.(self::$tmp_mnt_num++); self::$proxy_tab[$mnt]=null; self::$phk_tab[$mnt]=new PHK_Creator($mnt,$path,$flags); } else { $parent_mnt=$mnt=$mtime=$options=$build_info=null; self::compute_mnt($path,$parent_mnt,$mnt,$mtime); if (self::is_mounted($mnt)) return $mnt; self::$proxy_tab[$mnt]=null; self::$phk_tab[$mnt]=$phk=new PHK($parent_mnt,$mnt,$path,$flags,$mtime); self::get_store_data($mnt,$options,$build_info); $phk->init($options,$build_info); } } catch (Exception $e) { if (isset($mnt) && self::is_mounted($mnt)) unset(self::$phk_tab[$mnt]); throw new Exception($path.': Cannot mount - '.$e->getMessage()); } return $mnt; } private static function get_store_data($mnt,&$options,&$build_info) { $caching=(is_null(self::$caching) ? true : self::$caching); $mv=PHK_Util::get_min_version($mnt,$caching); if (version_compare($mv,PHK::VERSION) > 0) { PHK_Util::format_error('Cannot understand this version. ' .'Requires at least PHK version '.$mv); } $options=PHK_Util::get_options($mnt,$caching); $build_info=PHK_Util::get_build_info($mnt,$caching); } private static function compute_mnt($path,&$parent_mnt,&$mnt,&$mtime) { if (self::is_a_phk_uri($path)) { $dummy1=$dummy2=$subpath=$parent_mnt=null; PHK_Stream::parse_uri($path,$dummy1,$dummy2,$parent_mnt,$subpath); self::validate($parent_mnt); $mnt=$parent_mnt.'#'.str_replace('/','*',$subpath); $mtime=self::instance($parent_mnt)->mtime(); } else { $mnt=PHK_Util::path_unique_id('p',$path,$mtime); $parent_mnt=null; } } public static function umount($mnt) { if (self::is_mounted($mnt)) { foreach (array_keys(self::$phk_tab) as $dmnt) { if (isset(self::$phk_tab[$dmnt]) && self::$phk_tab[$dmnt]->parent_mnt()===$mnt) self::umount($dmnt); } self::$phk_tab[$mnt]->umount(); unset(self::$phk_tab[$mnt]); unset(self::$proxy_tab[$mnt]); } } public static function uri($mnt,$path) { return self::base_uri($mnt).ltrim($path,'/'); } public static function is_a_phk_uri($uri) { $u=$uri.'      '; return ($u{0}=='p' && $u{1}=='h' && $u{2}=='k' && $u{3}==':' && $u{4}=='/' && $u{5}=='/'); } public static function base_uri($mnt) { return 'phk://'.$mnt.'/'; } public static function command_uri($mnt,$command) { return self::uri($mnt,'?'.$command); } public static function section_uri($mnt,$section) { return self::command_uri($mnt,'section&name='.$section); } public static function automap_uri($mnt) { if ((!self::is_mounted($mnt))||(!self::instance($mnt)->map_defined())) return null; return self::section_uri($mnt,'AUTOMAP'); } public static function normalize_uri($uri) { return str_replace('\\','/',$uri); } public static function uri_to_mnt($uri) { if (! self::is_a_phk_uri($uri)) throw new Exception($uri.': Not a PHK URI'); $buf=substr(self::normalize_uri($uri),6); $buf=substr($buf,0,strcspn($buf,'/')); return trim($buf); } public static function php_version_check() { if (version_compare(PHP_VERSION,'5.1.0') < 0) { echo PHP_VERSION.': Unsupported PHP version ' .'- PHK needs at least version 5.1.0'; exit(1); } } } } if (!class_exists('PHK_Base',false)) { abstract class PHK_Base { const VERSION='1.4.0'; const F_CRC_CHECK=4; const F_NO_MOUNT_SCRIPT=8; const F_CREATOR=16; protected $mnt; protected $parent_mnt; protected $options=null; protected $build_info=null; protected $flags; protected $path; protected $plugin=null; protected $caching=null; protected $mtime; protected $backend=null; protected static $mime_table=array( '' => 'text/plain', 'gif' => 'image/gif', 'jpeg' => 'image/jpeg', 'jpg' => 'image/jpeg', 'png' => 'image/png', 'psd' => 'image/psd', 'bmp' => 'image/bmp', 'tif' => 'image/tiff', 'tiff' => 'image/tiff', 'iff' => 'image/iff', 'wbmp' => 'image/vnd.wap.wbmp', 'ico' => 'image/x-icon', 'xbm' => 'image/xbm', 'txt' => 'text/plain', 'htm' => 'text/html', 'html' => 'text/html', 'css' => 'text/css', 'php' => 'application/x-httpd-php', 'phk' => 'application/x-httpd-php', 'pdf' => 'application/pdf', 'js' => 'application/x-javascript', 'swf' => 'application/x-shockwave-flash', 'xml' => 'application/xml', 'xsl' => 'application/xml', 'xslt' => 'application/xslt+xml', 'mp3' => 'audio/mpeg', 'ram' => 'audio/x-pn-realaudio', 'svg' => 'image/svg+xml' ); public function __construct($parent_mnt,$mnt,$path,$flags,$mtime) { $this->parent_mnt=$parent_mnt; $this->mnt=$mnt; $this->path=$path; $this->flags=$flags; $this->mtime=$mtime; } public function init($options,$build_info) { try { $this->options=$options; $this->build_info=$build_info; $this->supports_php_version(); if ($this->option('crc_check') || ($this->flags & self::F_CRC_CHECK)) $this->crc_check(); if (is_null($this->parent_mnt)) { if (!is_null($extensions=$this->option('required_extensions'))) PHK_Util::load_extensions($extensions); } if ($this->map_defined()) { Automap::mount($this->automap_uri(),$this->base_uri(),$this->mnt); } if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT) && (!is_null($mpath=$this->option('mount_script')))) { require $this->uri($mpath); } if (!is_null($c=$this->option('plugin_class'))) $this->plugin=new $c($this->mnt); } catch (Exception $e) { throw new Exception('While initializing PHK instance - '.$e->getMessage()); } } public function map_defined() { if ($this->flags & PHK::F_CREATOR) return false; return $this->build_info('map_defined'); } public function mtime() { return $this->mtime; } public function set_cache($toggle) { $this->caching=$toggle; } public static function file_is_package($path) { return PHK_Proxy::file_is_package($path); } public static function data_is_package($data) { return PHK_Proxy::data_is_package($data); } public function cache_enabled($command,$params,$path) { if ($this->flags & PHK::F_CREATOR) return false; if ($this->option('no_cache')===true) return false; if (!PHK_Cache::cache_present()) return false; if (!is_null($this->caching)) return $this->caching; return true; } public function umount() { if (!is_null($this->plugin)) unset($this->plugin); if (!($this->flags & PHK::F_NO_MOUNT_SCRIPT)) { if (!is_null($upath=$this->option('umount_script'))) { require($this->uri($upath)); } } if ($this->map_defined()) Automap::umount($this->mnt); } public function mnt() { return $this->mnt; } public function flags() { return $this->flags; } public function path() { return $this->path; } public function uri($path) { return PHK_Mgr::uri($this->mnt,$path); } public function section_uri($section) { return PHK_Mgr::section_uri($this->mnt,$section); } public function command_uri($command) { return PHK_Mgr::command_uri($this->mnt,$command); } public function base_uri() { return PHK_Mgr::base_uri($this->mnt); } public function automap_uri() { return PHK_Mgr::automap_uri($this->mnt); } public function option($key) { return (isset($this->options[$key]) ? $this->options[$key] : null); } public function options() { return $this->options; } public function parent_mnt() { return $this->parent_mnt; } public function web_access_allowed($path) { $plen=strlen($path); foreach(PHK_Util::mk_array($this->option('web_access')) as $apath) { if ($apath=='/') return true; $alen=strlen($apath); if (($plen >= $alen) && (substr($path,0,$alen)==$apath) && (($alen==$plen)||($path{$alen}=='/'))) return true; } return false; } private function goto_main($web_run_script) { if ($this->option('web_main_redirect')) { PHK_Util::http_301_redirect($web_run_script); } else return 'require(\''.$this->uri($web_run_script).'\');'; } public function web_tunnel($path=null,$webinfo=false) { if (is_null($path)) $path=PHK::get_subpath(); $last_slash=(substr($path,-1)=='/'); if ($path!='/') $path=rtrim($path,'/'); $web_run_script=$this->option('web_run_script'); $mnt=$this->mnt(); if ($path=='') { if (!is_null($web_run_script)) return $this->goto_main($web_run_script); else PHK_Util::http_301_redirect('/'); } if ((!$webinfo) && (!$this->web_access_allowed($path)) && ($path!==$web_run_script)) { if (!is_null($web_run_script)) return $this->goto_main($web_run_script); else PHK_Util::http_403_fail(); } $uri=$this->uri($path); if (($a=@stat($uri))===false) PHK_Util::http_404_fail(); if (($a['mode'] & 0170000) == 040000) { $file_path=null; if ($last_slash) { foreach(array('index.htm', 'index.html', 'index.php') as $fname) { if (is_file($this->uri($path.'/'.$fname))) { $file_path=$path.'/'.$fname; break; } } if (is_null($file_path)) PHK_Util::http_404_fail(); } else PHK_Util::http_301_redirect($path.'/'); } else $file_path=$path; if ((!$webinfo) && ($this->is_php_source_path($file_path))) { return "require('".$this->uri($file_path)."');"; } else { return "PHK_Mgr::instance('".$this->mnt."')->mime_header('$file_path');\n" ."readfile('".$this->uri($file_path)."');"; } } public function mime_header($path) { if (!is_null($type=$this->mime_type($path))) header('Content-type: '.$type); } public function mime_type($path) { $ext=PHK_Util::file_suffix($path); if ((!is_null($mtab=$this->option('mime_types'))) && isset($mtab[$ext])) return $mtab[$ext]; if (isset(self::$mime_table[$ext])) return self::$mime_table[$ext]; if (strpos($ext,'php')!==false) return 'application/x-httpd-php'; return null; } public function is_php_source_path($path) { return ($this->mime_type($path)==='application/x-httpd-php'); } public function proxy() { return PHK_Mgr::proxy($this->mnt); } public function crc_check() { $this->proxy()->crc_check(); } public function supports_php_version() { if ((!is_null($minv=$this->option('min_php_version'))) && (version_compare(PHP_VERSION,$minv) < 0)) throw new Exception("PHP minimum supported version: $minv (current is ".PHP_VERSION.")"); if ((!is_null($maxv=$this->option('max_php_version'))) && (version_compare(PHP_VERSION,$maxv) > 0)) throw new Exception("PHP maximum supported version: $maxv (current is ".PHP_VERSION.")"); } public function plugin() { return $this->plugin; } public static function accelerator_is_present() { return false; } public function build_info($name=null) { if (is_null($name)) return $this->build_info; if (!isset($this->build_info[$name])) throw new Exception($name.': unknown build info'); return $this->build_info[$name]; } public static function subpath_url($path) { return PHK_Backend::subpath_url($path); } public static function get_subpath() { $path=''; if (isset($_REQUEST['_PHK_path'])) $path=urldecode($_REQUEST['_PHK_path']); else { $path=isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : ''; if ($path=='' && isset($_SERVER['ORIG_PATH_INFO'])) $path=$_SERVER['ORIG_PATH_INFO']; } if (($path!='') && ($path{0}!='/')) $path='/'.$path; return $path; } private function backend() { if (is_null($this->backend)) $this->backend=new PHK_Backend($this); return $this->backend; } public function __call($method,$args) { return PHK_Util::call_method($this->backend($this),$method,$args); } public static function prolog($file,&$cmd,&$ret) { if ($cli=(!PHK_Util::is_web())) { ini_set('display_errors',true); ini_set('memory_limit','1024M'); } PHK_Mgr::php_version_check(); try { $mnt=PHK_Mgr::mount($file); $phk=PHK_Mgr::instance($mnt); } catch (Exception $e) { if (getenv('PHK_DEBUG')!==false) throw $e; echo '** Fatal error: Cannot mount PHK file - '.$e->getMessage()."\n"; exit(1); } $tmp=get_included_files(); $main=(($tmp[0]===$file) || (realpath($tmp[0]) === $file)); if (!$main) { if (!is_null($script=$phk->option('lib_run_script'))) { require($phk->uri($script)); } if ($phk->option('auto_umount')) { PHK_Mgr::umount($mnt); $ret=''; } else $ret=$mnt; return; } if ($cli) { if (($_SERVER['argc']>1) && ($_SERVER['argv'][1]!='') && ($_SERVER['argv'][1]{0}=='@')) { $ret=$phk->builtin_prolog($file); return; } if (!is_null($run_path=$phk->option('cli_run_script'))) { $cmd="require('".$phk->uri($run_path)."');"; } return; } else { if (file_exists($file.'.webinfo')) { PHK_Util::run_webinfo($phk); } else { $cmd=$phk->web_tunnel(); } } } } } if (!class_exists('PHK',false)) { class PHK extends PHK_Base { public static function need_php_runtime() { } } } if (!class_exists('PHK_Backend',false)) { class PHK_Backend { private $front; public function __construct($front) { $this->front=$front; } public function __get($name) { return $this->front->$name(); } public function __call($method,$args) { return call_user_func_array(array($this->front,$method),$args); } public function test() { error_reporting(($errlevel=error_reporting()) & ~E_NOTICE); if (!is_null($test_script=$this->option('test_script'))) { $test_uri=$this->uri($test_script); require($test_uri); } elseif (!is_null($phpunit_test_package=$this->option('phpunit_test_package'))) { if (!is_null($phpunit_package=$this->option('phpunit_package'))) { $phpunit_package_mnt=require $this->uri($phpunit_package); } else $phpunit_package_mnt=null; $phpunit_test_package_mnt=require $this->uri($phpunit_test_package); _phk_load_phpunit_interface(); define('PHPUnit_MAIN_METHOD', 'PHPUnit_TextUI_PHK::main'); PHPUnit_TextUI_PHK::main(); if (!is_null($phpunit_package_mnt)) PHK_Mgr::umount($phpunit_package_mnt); if (!is_null($phpunit_test_package_mnt)) PHK_Mgr::umount($phpunit_test_package_mnt); } else echo "No unit tests\n"; error_reporting($errlevel); } public function envinfo() { $html=PHK_Util::is_web(); self::info_section($html,'PHK Accelerator'); self::start_info_table($html); if (PHK::accelerator_is_present()) PHK::accel_techinfo(); else self::show_info_line($html,'PHK Accelerator','No'); self::info_section($html,'Automap Accelerator'); self::start_info_table($html); if (Automap::accelerator_is_present()) Automap::accel_techinfo(); else self::show_info_line($html,'Automap Accelerator','No'); self::info_section($html,'Cache'); self::show_info_line($html,'Cache system used',PHK_Cache::cache_name()); self::end_info_table($html); self::info_section($html,'Environment'); self::start_info_table($html); self::show_info_line($html,'PHP SAPI',php_sapi_name()); self::show_info_line($html,'Mount point',$this->mnt); $string=''; $class=new ReflectionClass('PHK'); foreach($class->getConstants() as $name => $value) { if ((strlen($name)>1) && (substr($name,0,2)=='F_') && ($this->flags & $value)) $string .= ','.strtolower(substr($name,2)); } unset($class); $string=trim($string,','); self::show_info_line($html,'Current mount options' ,$string=='' ? '<none>' : $string); self::end_info_table($html); } public function showfiles() { $this->proxy()->showfiles(); } public function showmap($subfile_to_url_function=null) { if ($this->map_defined()) Automap::instance($this->mnt)->show($subfile_to_url_function); else echo "Automap not defined\n"; } private function plugin_info($html) { self::info_section($html,'Plugin'); if (is_null($class=$this->option('plugin_class'))) { echo ($html ? '<p>' : '')."Not defined\n"; return; } if ($this->is_callable_plugin_method('_webinfo')) { $this->call_plugin_method('_webinfo',$html); echo $html ? '<p>' : "\n"; } self::start_info_table($html); self::show_info_line($html,'Class',$class); $rc=new ReflectionClass($class); foreach ($rc->getMethods() as $method) { if ((!$method->isPublic())||($method->isStatic()) ||($method->isConstructor())||($method->isDestructor()) ||($method->getName()==='_webinfo')) continue; $name=$method->getName(); $a=array(); foreach($method->getParameters() as $param) { $s='$'.$param->getName(); if ($param->isPassedByReference()) $s='&'.$s; if ($param->isArray()) $s = 'Array '.$s; if ($param->isOptional()) { if ($param->isDefaultValueAvailable()) $s .= ' = '.var_export($param->getDefaultValue(),true); $s = '['.$s.']'; } $a[]=$s; } self::show_info_line($html,'Method',$name.' ( '.implode(', ',$a).' )'); } self::end_info_table($html); } private function show_option($html,$opt,$default=null) { $str1=ucfirst(str_replace('_',' ',$opt)); $url=null; $newwin=true; if (is_null($val=$this->option($opt))) $val=$default; if ($html && ereg('^(.*)[ 	]<([^ 	]+)>.*$',$val,$regs)) { $str2=trim($regs[1]); $url=$regs[2]; if ($str2=='') $str2=$url; } else { $str2=$val; $vlen=strlen($val); if (($vlen>=7)&&(substr($val,0,7)=='http://')) $url=$val; elseif (($vlen>=1) && ($val{0}=='/') && file_exists($this->uri($val))) { $url=PHK::subpath_url('/view/'.trim($val,'/')); $newwin=false; } } self::show_info_line($html,$str1,$str2,$url,$newwin); } public static function info_section($html,$title) { echo $html ? '<h2>'.htmlspecialchars($title).'</h2>' : "\n==== ".str_pad($title.' ',70,'='). "\n\n"; } public static function show_info_line($html,$string,$value,$url=null ,$newwin=true) { if (is_null($value)) $value='<>'; if (is_bool($value)) $value=PHK_Util::bool2str($value); if ($html) { echo '<tr><td>'.htmlspecialchars($string).':&nbsp;</td><td>'; if ($url) { echo '<a href="'.$url.'"'; if ($newwin) echo ' target="_blank"'; echo '>'; } echo htmlspecialchars($value); if ($url) echo '</a>'; echo '</td></tr>'; } else { echo "$string: $value"; if ((!is_null($url)) && ($url{0}!='/')) echo " <$url>"; echo "\n"; } } public static function start_info_table($html) { echo $html ? '<table border=0>' : ''; } public static function end_info_table($html) { echo $html ? '</table>' : ''; } public function info() { $html=PHK_Util::is_web(); if ($html && (!is_null($info_script=$this->option('info_script')))) { require($this->uri($info_script)); } else { self::start_info_table($html); $this->show_option($html,'name'); $this->show_option($html,'summary'); $this->show_option($html,'version'); $this->show_option($html,'release'); $this->show_option($html,'distribution'); $this->show_option($html,'license'); $this->show_option($html,'copyright'); $this->show_option($html,'url'); $this->show_option($html,'author'); $this->show_option($html,'packager'); $this->show_option($html,'requires'); $req=implode(' ',PHK_Util::mk_array($this->option('required_extensions'))); if ($req=='') $req='<none>'; self::show_info_line($html,'Required extensions',$req); self::end_info_table($html); } } public function techinfo() { $html=PHK_Util::is_web(); self::info_section($html,'Package'); self::start_info_table($html); $this->show_option($html,'name'); $this->show_option($html,'summary'); $this->show_option($html,'version'); $this->show_option($html,'release'); $this->show_option($html,'distribution'); $this->show_option($html,'license'); $this->show_option($html,'copyright'); $this->show_option($html,'url'); $this->show_option($html,'author'); $this->show_option($html,'packager'); $this->show_option($html,'requires'); self::show_info_line($html,'Signed',$this->proxy()->signed()); self::show_info_line($html,'Automap defined',$this->map_defined()); self::show_info_line($html,'File path',$this->path); self::show_info_line($html,'File size',filesize($this->path)); $req=implode(', ',PHK_Util::mk_array($this->option('required_extensions'))); if ($req=='') $req='<none>'; self::show_info_line($html,'Required extensions',$req); self::show_info_line($html,'Build date' ,PHK_Util::timestring($this->build_info('build_timestamp'))); $this->show_option($html,'icon'); $this->show_option($html,'crc_check',false); $this->show_option($html,'help_prefix'); $this->show_option($html,'license_prefix'); $this->show_option($html,'auto_umount',false); $this->show_option($html,'no_cache',false); $this->show_option($html,'no_opcode_cache',false); $this->show_option($html,'prolog_code_creator',false); $this->show_option($html,'plain_prolog',false); self::show_info_line($html,'File count',count($this->path_list())); self::end_info_table($html); $this->plugin_info($html); self::info_section($html,'Package scripts'); self::start_info_table($html); $this->show_option($html,'cli_run_script'); $this->show_option($html,'web_run_script'); $this->show_option($html,'lib_run_script'); $this->show_option($html,'info_script'); $this->show_option($html,'mount_script'); $this->show_option($html,'umount_script'); $this->show_option($html,'test_script'); $this->show_option($html,'phpunit_package'); $this->show_option($html,'phpunit_test_package'); self::end_info_table($html); self::info_section($html,'Module versions'); self::start_info_table($html); self::show_info_line($html,'PHK_Creator',$this->build_info('PHK_Creator_version')); self::show_info_line($html,'PHK min version',$this->build_info('PHK_min_version')); self::show_info_line($html,'Automap_Creator class',$this->build_info('Automap_creator_version')); self::show_info_line($html,'Automap min version',$this->build_info('Automap_min_version')); self::show_info_line($html,'PHK_PSF class',$this->build_info('PHK_PSF_version')); self::end_info_table($html); self::info_section($html,'Sub-packages'); ob_start(); $this->proxy()->display_packages(); $data=ob_get_clean(); if ($data==='') echo ($html ? '<p>' : '')."None\n"; else echo $data; self::info_section($html,'Web direct access'); self::start_info_table($html); $list=PHK_Util::mk_array($this->option('web_access')); self::show_info_line($html,'State',count($list) ? 'Enabled' : 'Disabled'); $this->show_option($html,'web_main_redirect',false); foreach($list as $path) self::show_info_line($html,'Path',$path); self::end_info_table($html); self::info_section($html,'Package options'); $a=$this->options(); $data=(is_null($a) ? '<>' : print_r($a,true)); echo ($html ? ('<pre>'.htmlspecialchars($data).'</pre>') : $data); self::info_section($html,'Sections'); $this->proxy()->stree()->display(false); } public function auto_file($prefix) { $html=PHK_Util::is_web(); $txt_suffixes=array('.txt',''); $suffixes=($html ? array('.htm','.html') : $txt_suffixes); $base_path=$this->uri($prefix); foreach($suffixes as $suffix) { if (is_readable($base_path.$suffix)) { return PHK_Util::readfile($base_path.$suffix); break; } } if ($html) { foreach ($txt_suffixes as $suffix) if (is_readable($base_path.$suffix)) return '<pre>'.htmlspecialchars(PHK_Util::readfile($base_path.$suffix)) .'</pre>'; } return null; } public function auto_option($name) { $data=null; $prefix=$this->option($name.'_prefix'); if (!is_null($prefix)) $data=$this->auto_file($prefix); if (is_null($data)) { $data='<No '.$name.' file>'."\n"; if (PHK_Util::is_web()) $data=htmlspecialchars($data); } return $data; } public function is_callable_plugin_method($method) { return (is_null($this->plugin)) ? false : is_callable(array($this->plugin,$method)); } public function call_plugin_method($method) { if (!$this->is_callable_plugin_method($method)) throw new Exception($method.': Undefined plugin method'); $args=func_get_args(); array_shift($args); return call_user_func_array(array($this->plugin,$method),$args); } public function path_list() { return unserialize(file_get_contents($this->command_uri(__FUNCTION__))); } public function section_list() { return unserialize(file_get_contents($this->command_uri(__FUNCTION))); } public static function subpath_url($path) { if ($path{0}!='/') $path=PHK::get_subpath().'/'.$path; $path=ereg_replace('//+','/',$path); return PHK_Util::http_base_url().((php_sapi_name()=='cgi') ? ('?_PHK_path='.urlencode($path)) : $path); } private static function cmd_usage($msg=null) { if (!is_null($msg)) echo "** ERROR: $msg\n"; echo "\nAvailable commands:\n\n"; echo "	- @help             Display package help\n"; echo "	- @license          Display license\n"; echo "	- @get <path>       Display a subfile content\n"; echo "	- @showmap          Display automap, if present\n"; echo "	- @showfiles        List subfiles\n"; echo "	- @option <name>    Display a package option\n"; echo "	- @set_interp <string>  Set the first line of the PHK to '#!<string>'\n"; echo "	- @info             Display information about the PHK file\n"; echo "	- @techinfo         Display technical information\n"; echo "	- @dump <directory> Extracts the files\n"; echo "	- @test [switches] [UnitTest]  Run the package's unit tests\n"; if (!is_null($msg)) exit(1); } public function builtin_prolog($file) { $retcode=0; try { $this->proxy()->crc_check(); $command=PHK_Util::substr($_SERVER['argv'][1],1); array_shift($_SERVER['argv']); $param=isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : null; switch($command) { case 'get': if (is_null($param)) self::cmd_usage($command.": needs argument"); $uri=$this->uri($param); if (is_file($uri)) readfile($uri); else throw new Exception("$param: file not found"); break; case 'test': $this->test(); break; case 'showmap': case 'info': case 'techinfo': case 'showfiles': $this->$command(); break; case 'option': $res=$this->$command($param); if (is_null($res)) throw new Exception('Option not set'); echo "$res\n"; break; case 'set_interp': if (is_null($param)) self::cmd_usage($command.": needs argument"); if (file_put_contents($file ,PHK_Proxy::set_buffer_interp($file,$param))===false) throw new Exception('Cannot write file'); break; case 'license': case 'help': echo $this->auto_option($command); break; case 'dump': if (is_null($param)) self::cmd_usage($command.": needs argument"); $this->proxy()->ftree()->dump($param); break; case '': self::cmd_usage(); break; default: self::cmd_usage($command.': Unknown command'); } PHK_Util::display_slow_path(); } catch (Exception $e) { if (getenv('PHK_DEBUG')!==false) throw $e; echo "** ERROR: Command failed ($command) - ".$e->getMessage()."\n"; $retcode=1; } return $retcode; } } } if (!class_exists('PHK_Stream',false)) { class PHK_Stream extends PHK_Util { private $uri; private $mnt; private $path; private $command; private $params; private $data; private $size; private $position; private $raise_errors=true; private function raise_warning($msg) { if ($this->raise_errors) trigger_error("PHK: $msg",E_USER_WARNING); } public static function get_file($dir,$uri,$mnt,$command,$params,$path,$cache=null) { $cache_id=PHK_Cache::cache_id('node',$uri); if (is_null($data=PHK_Cache::get($cache_id))) { $can_cache=true; if (is_null($data=($dir ? PHK_Stream_Backend::get_dir_data($mnt,$command,$params,$path) : PHK_Stream_Backend::get_file_data($mnt,$command,$params,$path ,$can_cache)))) throw new Exception("$uri: File not found"); if ($can_cache && (($cache===true) || (is_null($cache) && PHK_MGR::cache_enabled($mnt,$command,$params,$path)))) PHK_Cache::set($cache_id,$data); } if ($dir && (!is_array($data))) throw new Exception('Not a directory'); if ((!$dir) && (!is_string($data))) throw new Exception('Not a regular file'); return $data; } public function stream_open($uri,$mode,$options,&$opened_path) { try { $this->uri=$uri; $this->raise_errors=($options & STREAM_REPORT_ERRORS); if ($options & STREAM_USE_PATH) $opened_path=$uri; if (($mode!='r')&&($mode!='rb')) throw new Exception($mode.': unsupported mode (Read only)'); self::parse_uri($uri,$this->command,$this->params,$this->mnt,$this->path); if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt); $this->data=self::get_file(false,$uri,$this->mnt,$this->command ,$this->params,$this->path); $this->size=strlen($this->data); $this->position=0; } catch (Exception $e) { $msg=$uri.': Open error - '.$e->getMessage(); $this->raise_warning($msg); return false; } return true; } public function stream_read($nb) { if ($this->position==$this->size) return false; $max=$this->size-($pos=$this->position); if ($nb > $max) $nb=$max; $this->position+=$nb; return substr($this->data,$pos,$nb); } public function stream_eof() { return ($this->position==$this->size); } public function stream_tell() { return $this->position; } public function stream_seek($offset,$whence) { switch($whence) { case SEEK_CUR: $this->position+=$offset; break; case SEEK_END: $this->position=$this->size+$offset; break; default: $this->position=$offset; break; } if ($this->position > $this->size) $this->position=$this->size; if ($this->position < 0) $this->position=0; return true; } public function dir_opendir($uri,$options) { try { $this->uri=$uri; $this->raise_errors=($options & STREAM_REPORT_ERRORS); self::parse_uri($uri,$this->command,$this->params,$this->mnt ,$this->path); if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt); $this->data=self::get_file(true,$uri,$this->mnt,$this->command ,$this->params,$this->path); $this->size=count($this->data); $this->position=0; } catch (Exception $e) { $msg=$uri.': PHK opendir error - '.$e->getMessage(); $this->raise_warning($msg); return false; } return true; } public function dir_readdir() { if ($this->position==$this->size) return false; return $this->data[$this->position++]; } public function dir_rewinddir() { $this->position=0; } private static function stat_array($mode,$size,$mtime) { return array( 'dev' => 0, 'ino' => 0, 'mode' => $mode, 'nlink' => 1, 'uid' => 0, 'gid' => 0, 'rdev' => -1, 'size' => $size, 'atime' => $mtime, 'mtime' => $mtime, 'ctime' => $mtime, 'blksize' => 8192, 'blocks' => 1); } public function stream_stat() { return $this->url_stat($this->uri,0,true); } public function url_stat($uri,$flags,$fstat=false) { try { $this->raise_errors=!($flags & STREAM_URL_STAT_QUIET); if (!$fstat) { self::parse_uri($uri,$this->command,$this->params,$this->mnt ,$this->path); if (!is_null($this->mnt)) PHK_Mgr::validate($this->mnt); } $cache_id=PHK_Cache::cache_id('stat',$uri); if (is_null($data=PHK_Cache::get($cache_id))) { try { $cache=true; $mode=$size=$mtime=null; PHK_Stream_Backend::get_stat_data($this->mnt,$this->command ,$this->params,$this->path,$cache,$mode,$size,$mtime); $data=array($mode,$size,$mtime); } catch (Exception $e) { $data=''; } if ($cache && (!is_null($this->mnt)) && PHK_MGR::cache_enabled($this->mnt ,$this->command,$this->params,$this->path)) { PHK_Cache::set($cache_id,$data); } } if (is_array($data)) { list($mode,$size,$mtime)=$data; return self::stat_array($mode,$size,$mtime); } else throw new Exception('File not found'); } catch (Exception $e) { $msg=$uri.': PHK Stat error - '.$e->getMessage(); $this->raise_warning($msg); return false; } } public static function parse_uri($uri,&$command,&$params,&$mnt,&$path) { if (! PHK_Mgr::is_a_phk_uri($uri=str_replace('\\','/',$orig_uri=$uri))) throw new Exception('Not a PHK URI'); $uri=substr($uri,6); if (($pos=strpos($uri,'?'))!==false) { $cmd=PHK_Util::substr($uri,$pos+1); $uri=substr($uri,0,$pos); if (($pos=strpos($cmd,'&'))!==false) { $command=substr($cmd,0,$pos); parse_str(PHK_Util::substr($cmd,$pos+1),$params); } else $command=$cmd; if ($command=='') throw new Exception('Empty command'); } $uri=trim($uri,'/'); if ($uri!='') { $a=explode('/',$uri,2); $mnt=$a[0]; $path=isset($a[1]) ? $a[1] : ''; } if (is_null($command) && is_null($mnt)) throw new Exception('Empty URI'); } } stream_wrapper_register('phk','PHK_Stream'); } if (!class_exists('PHK_Stream_Backend',false)) { class PHK_Stream_Backend { private static $tmp_data=null; private static function command_open_or_stat($stat_flag,$mnt,$command,$params ,$path,&$cache) { $cache=true; try { if (is_null($mnt)) { switch($command) { case 'test': return "Test line 1/3\nTest line2/3\nTest line 3/3\n"; break; case 'tmp': $cache=false; return self::$tmp_data; break; default: throw new Exception($command.': Unknown global command'); } } else { $proxy=PHK_Mgr::proxy($mnt); switch ($command) { case 'section': case 'magic_field': if (!isset($params['name'])) throw new Exception($command .': command needs this argument: name'); return $proxy->$command($params['name']); case 'path_list': case 'section_list': return serialize($proxy->$command()); default: throw new Exception($command.': Unknown command'); } } } catch (Exception $e) { throw new Exception($command.': Error during command execution - ' .$e->getMessage()); } } public static function get_file_data($mnt,$command,$params,$path,&$cache) { $cache=true; try { if (is_null($command)) { $node=PHK_Mgr::proxy($mnt)->ftree()->lookup_file($path,false); if (is_null($node)) return null; return $node->read(); } else { return self::command_open_or_stat(false,$mnt,$command,$params,$path,$cache); } } catch (Exception $e) { return null; } } public static function get_dir_data($mnt,$command,$params,$path) { try { if (!is_null($command)) return null; $node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path,false); if (is_null($node)) return null; return $node->getdir(); } catch (Exception $e) { return null; } } public static function get_stat_data($mnt,$command,$params,$path,$cache ,&$mode,&$size,&$mtime) { if (!is_null($command)) { $mode=0100444; $size=strlen(self::command_open_or_stat(true,$mnt,$command,$params ,$path,$cache)); } else { $node=PHK_Mgr::proxy($mnt)->ftree()->lookup($path); $mode=$node->mode(); $size=$node->size(); } $mtime=(is_null($mnt) ? time() : PHK_Mgr::instance($mnt)->mtime()); } public static function _strip_string($str) { if (getenv('PHK_NO_STRIP')!==false) return $str; $save=self::$tmp_data; self::$tmp_data=$str; $res=php_strip_whitespace('phk://?tmp'); self::$tmp_data=$save; return $res; } public static function _include_string($str) { $save=self::$tmp_data; self::$tmp_data=$str; $res=require('phk://?tmp'); self::$tmp_data=$save; return $res; } } } if (!class_exists('PHK_DC',false)) { class PHK_DC { private $csz; private $rsz; private $flags; private $off; private $data=null; private $fspace=null; const COMPRESS_TYPE=7; const COMPRESS_NONE=0; const COMPRESS_GZIP=1; const COMPRESS_BZIP2=2; private static $compression_method_names=array('none','gzip','bzip2'); private static $compression_needed_extensions=array(null,'zlib','bz2'); public function clear_cache() { $data=null; } public function set_fspace($fspace) { $this->fspace=$fspace; } private function compression_type() { return $this->flags & self::COMPRESS_TYPE; } private function expand($buf) { $ctype=$this->compression_type(); if ($buf==='' || $ctype==self::COMPRESS_NONE) return $buf; switch($ctype) { case self::COMPRESS_BZIP2: if(is_int($rbuf=bzdecompress($buf))) throw new Exception("Cannot bzdecompress data - Error code $buf"); break; case self::COMPRESS_GZIP: if(($rbuf=gzuncompress($buf))===false) throw new Exception("Cannot gzuncompress data"); break; default: throw new Exception("Unknown compression method : $ctype"); } return $rbuf; } public function read() { if (is_null($this->data)) { if ($this->rsz==0) $this->data=''; else { $rbuf=$this->expand($this->fspace->read_block($this->off,$this->csz)); if (strlen($rbuf)!=$this->rsz) throw new Exception('Wrong expanded size'); $this->data=$rbuf; } } return $this->data; } private static function compression_ratio($rsz,$csz) { return ($rsz==0) ? '-' : (round(($csz/$rsz)*100)); } public function flag_string() { if ($ctype=$this->flags & self::COMPRESS_TYPE) return 'compress/'.self::$compression_method_names[$ctype] .' ('.self::compression_ratio($this->rsz,$this->csz).'%)'; return ''; } public function size() { return $this->rsz; } public function import($edata) { list($this->flags,$this->csz,$this->rsz,$this->off) =array_values(unpack('va/V3b',$edata)); $this->data=null; } public function __construct() { $this->set_flags(0); $this->set_data(''); $this->csz=$this->off=null; } public function set_flags($flags) { $this->flags=($flags & PHK_TNode::TN_DC_FLAG_MASK); } public function set_data($data) { $this->rsz=strlen($this->data=$data); } } } if (!class_exists('PHK_Tree',false)) { class PHK_Tree { public $fspace; private $edata; private $nodes; private static $eclasses=array( 'D' => 'PHK_TDir', 'F' => 'PHK_TFile'); public static function create_from_edata($serial_edata ,PHK_FileSpace $fspace) { $tree=new self($fspace); $tree->edata=unserialize($serial_edata); return $tree; } public function path_list() { return array_keys($this->edata); } public function path_exists($rpath) { return array_key_exists($rpath,$this->edata); } public function count() { return count($this->edata); } public function walk($method) { $args=func_get_args(); array_shift($args); foreach($this->path_list() as $path) { $node=$this->rlookup($path); call_user_func_array(array($node,$method),$args); } } private function realpath($path) { $a=explode('/',trim($path,'/')); $ra=array(); foreach($a as $comp) { switch($comp) { case '': case '.': break; case '..': if (count($ra)) array_pop($ra); break; default: $ra[]=$comp; } } if (!count($ra)) return ''; return '/'.implode('/',$ra); } public function lookup($path,$exception_flag=true) { return $this->rlookup(self::realpath($path),$exception_flag); } private function rlookup($path,$exception_flag=true) { if (array_key_exists($path,$this->edata)) { if (!array_key_exists($path,$this->nodes)) { $edata=$this->edata[$path]; $class=self::$eclasses[$edata{0}]; $node=$this->nodes[$path]=new $class($path,$this); $node->import(substr($edata,1)); } return $this->nodes[$path]; } if ($exception_flag) throw new Exception($path.': path not found'); else return null; } public function lookup_file($path,$exception_flag=true) { $f=$this->lookup($path,$exception_flag); if ((!is_null($f)) && (!($f instanceof PHK_TFile))) { if ($exception_flag) throw new Exception($path.': No such file'); else return null; } return $f; } public function display_header($html) { if ($html) echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 ' .'cellspacing=0 style="border-collapse: collapse"><tr><th>T</th>' .'<th>Name</th><th>Size</th><th>Flags</th></tr>'; } public function display_footer($html) { if ($html) echo '</table>'; } public function display($link) { $html=PHK_Util::is_web(); $this->display_header($html); $this->walk('display',$html,$link); $this->display_footer($html); } public function display_packages() { $html=PHK_Util::is_web(); ob_start(); $this->walk('display_package',$html); $data=ob_get_clean(); if ($data!=='') { $this->display_header($html); $this->walk('display_package',$html); $this->display_footer($html); } } public function dump($base) { $this->walk('dump',$base); } public static function dir_base_name($path) { $dir=ereg_replace('/[^/]*$','',$path); $base=ereg_replace('^.*/','',$path); return array($dir,$base); } private function __construct($fspace) { $this->fspace=$fspace; $this->nodes=array(); } } } if (!class_exists('PHK_TNode',false)) { abstract class PHK_TNode { protected $flags; protected $path; protected $tree=null; const TN_DC_FLAG_MASK=PHK_DC::COMPRESS_TYPE; const TN_STRIP_SOURCE=8; const TN_NO_AUTOLOAD=16; const TN_PKG=32; abstract public function type(); public function display_package($html) {} public function is_package() { return ($this->flags & self::TN_PKG); } public function getdir() { throw new Exception($this->path.': Cannot getdir() on a '.$this->type()); } public function read() { throw new Exception($this->path.': Cannot read() a '.$this->type()); } protected function flag_string() { $flag_string=''; if ($this->flags & self::TN_PKG) $flag_string .=',package'; else { if ($this->flags & self::TN_STRIP_SOURCE) $flag_string .=',strip'; if ($this->flags & self::TN_NO_AUTOLOAD) $flag_string .=',no_autoload'; } return $flag_string; } protected function __construct($path,$tree) { $this->path=$path; $this->tree=$tree; $this->flags=0; } protected function import($edata) { list($this->flags)=array_values(unpack('va',$edata)); return substr($edata,2); } } } if (!class_exists('PHK_TDir',false)) { class PHK_TDir extends PHK_TNode { private $children; public function type() { return 'dir'; } public function mode() { return 040555; } public function size() { return count($this->children); } public function get_needed_extensions() {} public function display($html,$link) { $path=$this->path; if ($path=='') $path='/'; if ($html) echo '<tr><td nowrap colspan=4>&nbsp;<b><i>'.$path .'</i></b></td></tr>'; else echo "D $path\n"; } public function getdir() { return $this->children; } public function dump($base) { $path=$base.$this->path; if (mkdir($path)===false) throw new Exception($path.': cannot create directory'); } public function import($edata) { $this->children=explode(';',parent::import($edata)); } public function __construct($path,$tree) { parent::__construct($path,$tree); $this->children=array(); } public function subpath($name) { return $this->path.'/'.$name; } } } if (!class_exists('PHK_TFile',false)) { class PHK_TFile extends PHK_TNode { private $dc; public function type() { return 'file'; } public function mode() { return 0100444; } public function __call($method,$args) { try { return call_user_func_array(array($this->dc,$method),$args); } catch (Exception $e) { throw new Exception($this->path.': '.$e->getMessage()); } } public function read() { return $this->dc->read(); } public function flag_string() { $string=parent::flag_string().','.$this->dc->flag_string(); $string=trim($string,','); return $string; } public function display_package($html) { if ($this->flags & self::TN_PKG) $this->display($html); } public function display($html,$link=false) { $flag_string=$this->flag_string(); $path=$this->path; if ($html) { if ($this->flags & self::TN_PKG) $link=false; $field= ($link ? '<a href="'.PHK::subpath_url('/view/' .trim($path,'/')).'">'.$path.'</a>' : $path); echo '<tr><td nowrap>F</td><td nowrap>'.$field.'</td><td nowrap>' .$this->size().'</td><td nowrap>'.$flag_string.'</td></tr>'; } else { if ($flag_string!='') $flag_string = ' ('.$flag_string.')'; echo 'F '.str_pad($this->size(),11).' '.$path.$flag_string."\n"; } } public function dump($base) { $path=$base.$this->path; if (file_put_contents($path,$this->read())===false) throw new Exception($path.': cannot dump file'); } public function __construct($path,$tree) { parent::__construct($path,$tree); $this->dc=new PHK_DC(); $this->dc->set_fspace($tree->fspace); } public function import($edata) { $this->dc->import(parent::import($edata)); } public function set_flags($flags) { parent::set_flags($flags); $this->dc->set_flags($flags); } } } if (!class_exists('PHK_Webinfo',false)) { class PHK_Webinfo { const VERSION='0.2.5'; private $PHK; private $cmd_titles=array( 'info' => 'Home', 'techinfo' => 'Technical information', 'showmap' => 'Automap', 'showfiles' => 'Files', 'test' => 'Unit tests'); public function __construct($phk) { $this->PHK=$phk; PHK_Mgr::set_cache(false); } private static function display_tab($url,$name) { echo '<li id="'.$name.'"><a href="'.PHK::subpath_url($url) .'"><span>'.$name.'</span></a></li>'; } private function header($title=null) { if (is_null($name=$this->PHK->option('name'))) $name=basename($this->PHK->path()); $win_title=(is_null($title) ? $name : "$name - $title"); echo '<head>' ."<title>$win_title</title>" .'<link href="'.PHK::subpath_url('/php_section/STATIC/tabs/tabs.css.php') .'" rel="stylesheet" type="text/css">' ."<style type=text/css><!--\n" ."a,a:active,a:link { color: blue; text-decoration: none; }\n" ."a:hover { color: blue; text-decoration: underline; }\n" .'--></style>' ."</head>\n"; echo '<table width=100% border=0 cellpadding=0 cellspacing=0>'; echo '<tr><td><div class="tabs"><ul>'; self::display_tab('/info','Home'); if (!is_null($this->PHK->option('help_prefix'))) self::display_tab('/auto_option/help','Help'); if (!is_null($this->PHK->option('license_prefix'))) self::display_tab('/auto_option/license','License'); self::display_tab('/techinfo','Info'); self::display_tab('/showfiles','Files'); if ($this->PHK->map_defined()) self::display_tab('/showmap','Automap'); if ((!is_null($this->PHK->option('test_script'))) ||(!is_null($this->PHK->option('phpunit_test_package')))) self::display_tab('/test','Tests'); if (!is_null($tabs=$this->PHK->option('tabs'))) foreach($tabs as $n => $url) self::display_tab($url,$n); echo '</ul></div></td></tr>'; $bg_string=(is_null($opt=$this->PHK->option('icon_bgcolor')) ? '' : 'bgcolor="'.$opt.'"'); if (is_null($icon_width=$this->PHK->option('icon_width'))) $icon_width='150'; echo '<tr><td width=100%><table width=100% border=1 bordercolor="#aaaaaa"' .' cellpadding=3 cellspacing=0>'; echo "<tr><td width=$icon_width $bg_string align=center>"; $url=$this->PHK->option('url'); if (!is_null($url)) echo '<a href="'.$url.'" target=_blank>'; if (!is_null($icon_path=$this->PHK->option('icon'))) echo '<img border=0 src="'.PHK::subpath_url('/file/'.trim($icon_path,'/')) .'" alt="Package Home">'; elseif (!is_null($url)) echo '&lt;Website&gt;'; if (!is_null($url)) echo '</a>'; echo "</td>\n"; echo '<td bgcolor="#D7E2FF" align=center><h1>'.$name.'</h1></td>'; echo '<td width=151 align=center><a href="http://phk.tekwire.net"' .' target=_blank><img width=151 height=88 border=0 src="' .PHK::subpath_url('/section/STATIC/phk_logo.png') .'" alt="PHK Home"></a></td>'; echo '</tr>'; echo '</table></td></tr></table>'; if (!is_null($title)) echo "<p><h1>$title</h1>"; @flush(); } public function run() { if (isset($_REQUEST['debug'])) { echo "<hr>"; echo "<h2>Environment:</h2>"; echo "<h3>_REQUEST :</h3>"; echo "<pre>"; var_dump($_REQUEST); echo "</pre>"; echo "<h3>_SERVER :</h3>"; echo "<pre>"; print_r($_SERVER); echo "</pre>"; } $command=trim(PHK::get_subpath(),'/'); if (($pos=strpos($command,'/'))!==false) { $arg=substr($command,$pos+1); $command=substr($command,0,$pos); } else $arg=''; if ($command=='') $command='info'; self::send_cache_header(); switch($command) { case 'view': $arg='/'.$arg; $this->header("File: $arg"); $path=$this->PHK->uri($arg); if (!is_file($path)) { echo '* ERROR: '.$arg.': File not found<p>'; break; } echo "<table border=0>\n"; echo '<tr><td>Size:</td><td>'.filesize($path).'</td></tr>'; echo '<tr><td>Storage flags:</td><td>' .$this->PHK->proxy()->ftree()->lookup($arg)->flag_string().'</td></tr>'; echo "</table><hr/>"; switch($mime_type=$this->PHK->mime_type($arg)) { case 'application/x-httpd-php': highlight_file($path); break; case 'text/html': echo PHK_Util::readfile($path); break; default: if (strpos($mime_type,'image/')===0) echo 'Image: <img src="'.PHK::subpath_url('/file'.$arg).'">'; else echo '<pre>'.htmlspecialchars(PHK_Util::readfile($path)) .'</pre>'; } break; case 'run': $this->header(); eval($this->PHK->web_tunnel($arg,true)); break; case 'file': eval($this->PHK->web_tunnel($arg,true)); return; case 'info': case 'techinfo': case 'envinfo': case 'showmap': case 'showfiles': case 'test': if (isset($this->cmd_titles[$command])) $t=$this->cmd_titles[$command]; else $t=ucfirst($command); $this->header($t); $this->PHK->$command(array(__CLASS__,'view_subfile_url')); break; case 'auto_file': $this->header(); echo $this->PHK->auto_file('/'.$arg); break; case 'auto_option': $this->header(ucfirst($arg)); echo $this->PHK->auto_option($arg); break; case 'php_section': require($this->PHK->section_uri($arg)); return; case 'section': eval($this->PHK->web_tunnel('/?section&name='.$arg,true)); return; default: echo '<b>'.$command.': Unknown subcommand</b><p>'; } self::footer(); } public static function view_subfile_url($fname) { return PHK::subpath_url('/view/'.trim($fname,'/')); } private static function send_cache_header() { header('Expires: '.gmdate('D, d M Y H:i:s \G\M\T',time()+600)); header('Cache-Control: public, max-age=600'); header('Last-Modified: '.gmdate('D, d M Y H:i:s \G\M\T',time())); } private static function footer() { echo '<hr>'; echo '<font size="-1"><i>For more information about the PHK package format:' .' <a href="http://phk.tekwire.net" target="_blank">' .'http://phk.tekwire.net</i></font>'; } } } if (!function_exists('_phk_load_phpunit_interface')) { function _phk_load_phpunit_interface() { if (!class_exists('PHPUnit_Runner_PHKTestSuiteLoader',false)) { class PHPUnit_Runner_PHKTestSuiteLoader implements PHPUnit_Runner_TestSuiteLoader { public function load($suiteClassName, $suiteClassFile = '') { if (class_exists($suiteClassName, true)) { return new ReflectionClass($suiteClassName); } else throw new RuntimeException("Class $suiteClassName could not be found"); } public function reload(ReflectionClass $aClass) { return $aClass; } } } if (!class_exists('PHPUnit_TextUI_PHK',false)) { class PHPUnit_TextUI_PHK { public static function main() { PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT'); self::handleLoader('PHPUnit_Runner_PHKTestSuiteLoader'); $arguments=self::handleArguments(); $runner= new PHPUnit_TextUI_TestRunner; $suite = $runner->getTest($arguments['test'],'',$arguments['syntaxCheck']); try { if (PHK_Util::is_web()) echo "<pre>\n"; $result = $runner->doRun($suite,$arguments); if (PHK_Util::is_web()) echo "</pre>\n"; } catch (Exception $e) { throw new RuntimeException('Could not create and run test suite: ' . $e->getMessage()); } if (!PHK_Util::is_web()) { if ($result->wasSuccessful()) exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); else if($result->errorCount() > 0) exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); else exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT); } } protected static function handleArguments() { $arguments = array('syntaxCheck' => TRUE); $longOptions = array( 'configuration=', 'exclude-group=', 'filter=', 'group=', 'help', 'loader=', 'log-json=', 'log-tap=', 'log-xml=', 'repeat=', 'skeleton', 'stop-on-failure', 'tap', 'testdox', 'testdox-html=', 'testdox-text=', 'no-syntax-check', 'verbose', 'version', 'wait'); if (class_exists('Image_GraphViz', FALSE)) $longOptions[] = 'log-graphviz='; if (extension_loaded('pdo')) { $longOptions[] = 'test-db-dsn='; $longOptions[] = 'test-db-log-rev='; $longOptions[] = 'test-db-log-prefix='; $longOptions[] = 'test-db-log-info='; } if (extension_loaded('xdebug')) { $longOptions[] = 'coverage-html='; $longOptions[] = 'coverage-xml='; $longOptions[] = 'log-metrics='; $longOptions[] = 'log-pmd='; $longOptions[] = 'report='; } try { $options = PHPUnit_Util_Getopt::getopt( isset($_SERVER['argv']) ? $_SERVER['argv'] : array(),'d:',$longOptions); } catch (RuntimeException $e) { PHPUnit_TextUI_TestRunner::showError($e->getMessage()); } $arguments['test']=(isset($options[1][0]) ? $options[1][0] : 'AllTests'); $arguments['testFile'] = ''; foreach ($options[0] as $option) { switch ($option[0]) { case '--configuration': $arguments['configuration'] = $option[1]; break; case '--coverage-xml': $arguments['coverageXML'] = $option[1]; break; case 'd': $ini = explode('=', $option[1]); if (isset($ini[0])) { if (isset($ini[1])) { ini_set($ini[0], $ini[1]); } else ini_set($ini[0], TRUE); } break; case '--help': self::showHelp(); exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); break; case '--filter': if (preg_match('/^[a-zA-Z0-9_]/', $option[1])) $arguments['filter'] = '/^' . $option[1] . '$/'; else $arguments['filter'] = $option[1]; break; case '--group': $arguments['groups'] = explode(',', $option[1]); break; case '--exclude-group': $arguments['excludeGroups'] = explode(',', $option[1]); break; case '--loader': self::handleLoader($option[1]); break; case '--log-json': $arguments['jsonLogfile'] = $option[1]; break; case '--log-graphviz': $arguments['graphvizLogfile'] = $option[1]; break; case '--log-tap': $arguments['tapLogfile'] = $option[1]; break; case '--log-xml': $arguments['xmlLogfile'] = $option[1]; break; case '--log-pmd': $arguments['pmdXML'] = $option[1]; break; case '--log-metrics': $arguments['metricsXML'] = $option[1]; break; case '--repeat': $arguments['repeat'] = (int)$option[1]; break; case '--stop-on-failure': $arguments['stopOnFailure'] = TRUE; break; case '--test-db-dsn': $arguments['testDatabaseDSN'] = $option[1]; break; case '--test-db-log-rev': $arguments['testDatabaseLogRevision'] = $option[1]; break; case '--test-db-prefix': $arguments['testDatabasePrefix'] = $option[1]; break; case '--test-db-log-info': $arguments['testDatabaseLogInfo'] = $option[1]; break; case '--coverage-html': case '--report': $arguments['reportDirectory'] = $option[1]; break; case '--skeleton': if (isset($arguments['test'])) self::doSkeleton($arguments['test'],''); else { self::showHelp(); exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); } break; case '--tap': $arguments['printer'] = new PHPUnit_Util_Log_TAP; break; case '--testdox': $arguments['printer'] = new PHPUnit_Util_TestDox_ResultPrinter_Text; break; case '--testdox-html': $arguments['testdoxHTMLFile'] = $option[1]; break; case '--testdox-text': $arguments['testdoxTextFile'] = $option[1]; break; case '--no-syntax-check': $arguments['syntaxCheck'] = FALSE; break; case '--verbose': $arguments['verbose'] = TRUE; break; case '--version': PHPUnit_TextUI_TestRunner::printVersionString(); exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); break; case '--wait': $arguments['wait'] = TRUE; break; } } if (!isset($arguments['test']) && isset($arguments['configuration'])) { $configuration= new PHPUnit_Util_Configuration($arguments['configuration']); $testSuite = $configuration->getTestSuiteConfiguration(); if ($testSuite !== NULL) $arguments['test'] = $testSuite; } if ((isset($arguments['testDatabaseLogRevision']) && !isset($arguments['testDatabaseDSN']))) { self::showHelp(); exit(PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); } return $arguments; } protected static function doSkeleton($test, $testFile) { if ($test !== FALSE) { PHPUnit_TextUI_TestRunner::printVersionString(); try { $skeleton = new PHPUnit_Util_Skeleton($test, $testFile); $skeleton->write(); } catch (Exception $e) { print $e->getMessage() . "\n"; printf('Could not write test class skeleton for "%s" to "%s".' . "\n", $test,$testFile); exit(PHPUnit_TextUI_TestRunner::FAILURE_EXIT); } printf('Wrote test class skeleton for "%s" to "%s".' . "\n", $test,$skeleton->getTestSourceFile()); exit(PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); } } protected static function handleLoader($loaderName) { if (!class_exists($loaderName, FALSE)) { PHPUnit_Util_Fileloader::checkAndLoad(str_replace('_', '/', $loaderName) . '.php'); } if (class_exists($loaderName, FALSE)) { $class = new ReflectionClass($loaderName); if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') && $class->isInstantiable()) { $loader = $class->newInstance(); } } if (!isset($loader)) { PHPUnit_TextUI_TestRunner::showError( sprintf('Could not use "%s" as loader.',$loaderName)); } PHPUnit_TextUI_TestRunner::setLoader($loader); } public static function showHelp() { PHPUnit_TextUI_TestRunner::printVersionString(); print "Usage: php <package> [switches] [UnitTest]\n\n"; if (class_exists('Image_GraphViz', FALSE)) { print "  --log-graphviz <file>  Log test execution in GraphViz markup.\n"; } print "  --log-json <file>      Log test execution in JSON format.\n" . "  --log-tap <file>       Log test execution in TAP format to file.\n" . "  --log-xml <file>       Log test execution in XML format to file.\n"; if (extension_loaded('xdebug')) { print "  --log-metrics <file>   Write metrics report in XML format.\n" . "  --log-pmd <file>       Write violations report in PMD XML format.\n\n" . "  --coverage-html <dir>  Generate code coverage report in HTML format.\n" . "  --coverage-xml <file>  Write code coverage information in XML format.\n\n"; } if (extension_loaded('pdo')) { print "  --test-db-dsn <dsn>    DSN for the test database.\n" . "  --test-db-log-rev <r>  Revision information for database logging.\n" . "  --test-db-prefix ...   Prefix that should be stripped from filenames.\n" . "  --test-db-log-info ... Additional information for database logging.\n\n"; } print "  --testdox-html <file>  Write agile documentation in HTML format to file.\n" . "  --testdox-text <file>  Write agile documentation in Text format to file.\n\n" . "  --filter <pattern>     Filter which tests to run.\n" . "  --group ...            Only runs tests from the specified group(s).\n" . "  --exclude-group ...    Exclude tests from the specified group(s).\n\n" . "  --loader <loader>      TestSuiteLoader implementation to use.\n" . "  --repeat <times>       Runs the test(s) repeatedly.\n\n" . "  --tap                  Report test execution progress in TAP format.\n" . "  --testdox              Report test execution progress in TestDox format.\n\n" . "  --no-syntax-check      Disable syntax check of test source files.\n" . "  --stop-on-failure      Stop execution upon first error or failure.\n" . "  --verbose              Output more verbose information.\n" . "  --wait                 Waits for a keystroke after each test.\n\n" . "  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.\n\n" . "  --help                 Prints this usage information.\n" . "  --version              Prints the version and exits.\n\n" . "  --configuration <file> Read configuration from XML file.\n" . "  -d key[=value]         Sets a php.ini value.\n"; } } } } } 
a:12:{s:0:"";s:42:"D  FTREE;AUTOMAP;STATIC;OPTIONS;BUILD_INFO";s:8:"/AUTOMAP";s:17:"F        F  ";s:11:"/BUILD_INFO";s:17:"F          ÷]  ";s:6:"/FTREE";s:17:"F    F  F      ";s:8:"/OPTIONS";s:17:"F        ì[  ";s:7:"/STATIC";s:20:"D  tabs;phk_logo.png";s:20:"/STATIC/phk_logo.png";s:17:"F    i<  i<    ";s:12:"/STATIC/tabs";s:45:"D  left.gif;right.gif;bottom.gif;tabs.css.php";s:23:"/STATIC/tabs/bottom.gif";s:17:"F    #   #   ¨  ";s:21:"/STATIC/tabs/left.gif";s:17:"F    Â  Â  Í  ";s:22:"/STATIC/tabs/right.gif";s:17:"F    
  
  	  ";s:25:"/STATIC/tabs/tabs.css.php";s:17:"F    ¸  ¸  Ë  ";}a:14:{s:0:"";s:194:"D  PHO_Display.php;PHO_File.php;PHO_Getopt.php;PHO_HTTP.php;PHO_IP.php;PHO_JSON.php;PHO_Modifiable.php;PHO_Persistent.php;PHO_Time.php;PHO_Util.php;PHO_VarContainer.php;PHO_XPage.php;license.txt";s:16:"/PHO_Display.php";s:17:"F    y  y      ";s:13:"/PHO_File.php";s:17:"F        y  ";s:15:"/PHO_Getopt.php";s:17:"F    ó$  ó$  #  ";s:13:"/PHO_HTTP.php";s:17:"F        rH  ";s:11:"/PHO_IP.php";s:17:"F    F  F  P  ";s:13:"/PHO_JSON.php";s:17:"F    l|  l|  ÌS  ";s:19:"/PHO_Modifiable.php";s:17:"F    ²  ²  8Ð  ";s:19:"/PHO_Persistent.php";s:17:"F        êÛ  ";s:13:"/PHO_Time.php";s:17:"F        ñ  ";s:13:"/PHO_Util.php";s:17:"F    È
  È
  õ  ";s:21:"/PHO_VarContainer.php";s:17:"F    ç  ç  Ùÿ  ";s:14:"/PHO_XPage.php";s:17:"F        À ";s:12:"/license.txt";s:17:"F   ã  ã  Ç ";}AUTOMAP  M M1.1.0        V1.1.0        FS903     a:2:{s:3:"map";a:18:{s:12:"Lpho_display";s:16:"SPHO_Display.php";s:9:"Lpho_file";s:13:"SPHO_File.php";s:11:"Lpho_getopt";s:15:"SPHO_Getopt.php";s:9:"Lpho_http";s:13:"SPHO_HTTP.php";s:7:"Lpho_ip";s:11:"SPHO_IP.php";s:20:"CSERVICES_JSON_SLICE";s:13:"SPHO_JSON.php";s:21:"CSERVICES_JSON_IN_STR";s:13:"SPHO_JSON.php";s:21:"CSERVICES_JSON_IN_ARR";s:13:"SPHO_JSON.php";s:21:"CSERVICES_JSON_IN_OBJ";s:13:"SPHO_JSON.php";s:21:"CSERVICES_JSON_IN_CMT";s:13:"SPHO_JSON.php";s:25:"CSERVICES_JSON_LOOSE_TYPE";s:13:"SPHO_JSON.php";s:14:"Lservices_json";s:13:"SPHO_JSON.php";s:15:"Lpho_modifiable";s:19:"SPHO_Modifiable.php";s:15:"Lpho_persistent";s:19:"SPHO_Persistent.php";s:9:"Lpho_time";s:13:"SPHO_Time.php";s:9:"Lpho_util";s:13:"SPHO_Util.php";s:17:"Lpho_varcontainer";s:21:"SPHO_VarContainer.php";s:10:"Lpho_xpage";s:14:"SPHO_XPage.php";}s:7:"options";a:0:{}}GIF89a	 ,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    	 , ÿ@P±É`H$!%Cq Ve2X­ÌJ(Ä +32$ÀÆ ¼kvä-Ëçõu*"}ã|}|~q("$f'l(&&$r&! )¢¤{¨£¥r­ª°©¯±¯¬´¦·»º³®«§¾¶ÃÂÀ¿²¹ÇÄËÆ²ÌÉÎµÒ½Í¼ÔÈÓ×Ð¸ÙÝÕÏÙÊâÜßãçæê¾äÛÅëÇíáîÖìéïøñ÷õüÑðåùü¤Pß?ÇÛBmåAÎáÀ%VÜî!Çk÷Ø/áÄ;^¤¨²$Æ#Mf)fÍ(WÎLæKçÒ° I)L:eD¡Cµ´x*4U¨h 
%A«£^ÁNKb¬Ùe§X± ´k»x!ÁÖí2tÝÖ	 !¯5tÛæéÀ]$¬´%Xíâ.i[¬]Y­ÊfEëõkg`µ:zëçÒ;£}ºµj×aaM¶é×¸cç½»vïÛºóî8ðáÈ'?®¼9óç©G_>Ýyuè¬_ß]zwêß­Ç¾º¼mîæµG~½ûôÞá/>ùööÙ«Ïÿ¿ÿýÿÅà|ÖWà} v ;GIF89a,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    , ÿ@pH,È¤rÉl:Ð¨tJ­Z¯Ø¬vh<¬pkL.Ïè´zÍn»ßð¸|N¯Ûïø¼~ÏwVa+ *)^,*ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃ¶)'ÆÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæÚ¥("ðñòóôõö÷øùúûüýþÿ 
H° ÁòK"RHH±¢Å3jÜÈ±£Ç CI²¤É(Sª\éÅu&@ Á²¦Í8sêÜÉ³§Oÿ(Â±DÐ£H*]Ê´©Ó§P£JJµªÕ«X³jÝÊµ«×¯S84± hÓª]Ë¶­Û·pãÊK·®Ý»xóêÝË·¯ß¿Ó} âDÌf(^Ì¸±ãÇ#KL¹²åË3kÞÌ¹³çÏ Cm¹ðCÄHXÍºµë×°cËM»¶íÛ¸sëÞÍ»·ïßÀN÷ÃJ Á®¹óçÐ£KN½ºõëØ³kßÎ½»÷ïàÃO¾<v1+_.³½û÷ðãËO¿¾ýûøóëßÏ¿¿ÿÿ (à_YÉ@Ár5èàF(áVháf¨ávèÿá (â$¨a¤H,¶èâ0Æ(ã4Öhâ	*¨"<öèã@)äDiäH&©äL6éäPF)åT&©\;V©å\véå`)æZ^%	d¦©æl¶éæpþhfqÖiçxæ©çsRæ*è ÂÙç&ªè¢6:ä¡F*é¤Æ	i¥fªé¦O^Êé§ Ê©§¢jê©êª¬¶Ê¦ª®Æ*ë¬SÂJë­¸æ*¤­ºöêë¬¼þ*ì°¥Kì±ÈVjl²Ì6è²ÎF+-ÐNkíµkVí¶Üv©m·àÛ©tkî¹Q~ÿîºìò¨n»ðûn¼ôr;o½øN{o¾ü2»o¿ ûoÀë:pÁK®	7íÁGl*ÄWü)Åg)Æw)Ç¬(È",(É&§'Ê*·léÂº,3¥,Ïl35ß¬30ïìó³=ÿ,t 9m´E­´A/ítI?-5QOm5U_=uÖZ?Íu×KöÑb=tÙfÿvÚ;¯ÍöÍn¿=sÜr»LwÝ*ß·Ézï-rß~{xàN¸Å.qâ;Ìxã	?yÁOpå÷yæùnÎy½oè¢·Kzéëú¹ª¯.në®{ìö6Mÿ»Ö³ß~mîºëk{ïRó¼³ÂïïïÆ+]|òÇ.Ï¼ÀÈ?/´óÒûJ}õG½Î×ok÷Þ+%Ãá«­}ùv~Þê¯ÏwûîÿüÏOáößxþú/Îÿû #'ÀR®¼¨¹2°s| è"(ÁÑQ°¦» S§Á²®|C(»°vãÙ		ÂF|.dc82ÒPZ3¼aªl¨Ãfå°Dã!õÃ!ê©F¤(,$2±NN|¢¡(Åìµ°L!¶ÈÅ.zñ`£ÇHÆ.zaH£×ÈÆ6ºñp£çHÇ:ÚÿñxÌ£÷ÈÇ>úñdÇ@ L¤"ÉÈF:ò¤$9  (8&ÉÉNzò ¥(G©FB^²!Ë¨ )WÉÊVºò°l¤)1wÄò¸Ì¥.wÊYºäà¥0IÌbó¾|ÉHpÌf:óÐìepJ±}È¦6·ÉÍnzóà§8û0 Â%"¸æ8×ÉÎvºóð§<ÉPÎQ`ò%×$>÷ÉÏ~úó ¨@JÐô M¨BÊÐ:ô¡¨D'ZPKF Ö¼&16ÊÑzô£ ©HGJRb ÷Lç5ÏÁÒºô¥ÿ0©LgJÓ#(e>¯Óúô§@ªPJÔ¢õ¨HMªRÊÔ¦:õ©PªT§JÕª&5;%U·ÊÕ®zõ«`«XÇJV«ÂC§ÑjY×ÊÖ¶ºõ­p«\U´À¦xÍ«^÷Ê×¾úõ¯ÐÀi)$ô°M¬bËØÆ:v,à²Í¬f7ËÙÎzö³ ­hGKÚÒö´¨M­jWËÚÖºöµ°­*$ÛSPô¶¸Í­nwËÛÞúö·ÀÅm + â¸ÈM®rËÜæ:÷¹ÐE®?±9ÏêZ÷ºØÍ®v¿9î"ºÛ¯xÇKÞòbÑLÿ¯z×Ë^A¢·½ð¯|ç÷Ò÷¾øÍ¯0í«ßþú÷¿¡ä/Là»×ÀN°ï(à;øÁ	n0'LaýJ¸ÂÎ0{/¬á{Øþ°G|ËøÄ(¥SÌâCrÅ.±	ãÛøÆv¬1wÌc6ê¸Ç@ÞñLd¹ÈHNñÌd/¹ÉPÎð£LeO¹ÊXp·|â+sùËýõ2ÇL_1ùÌí53×M5³ùÍÇt3ç¼_:ÛÙÂwÎsõÌgøÊ¹Ïp ýÌ?úÐ/F´¢ë¼èFãÒÐt!-éJãÒÎô1­éN»ÓuÿA-êPºÔ>5ª3­êUWºÕ®4¬cÝèYÓZÑ¶¾õ¡s­ëAóº×þ5°ù,ìaç¹ØÆ¶3²=çe3ûÍÎ~ö£-í3S»Úc¾6¶¿¬ímo¹ÛÞÆ2¸ÃMåqÊæ>7Ó­n$³»ÝD~7¼,ïyó¸ÞöÆ1¾ómã}óÛÈÿvµ¿Þâ\É/µÁNâ3ÜÉ÷´Ã#ÞáS\ÊguÆ-mñO¸ã0ÈC¾à\Ë'_´ÉS^à³|À.ùc.ó0×Ð4¿9~s®ó=÷¼Ï<ÿy|.ô4]ÏD?ºz®ô67]ÙO§3Ó£ÞÌ©SÄWvÖÙl>õ­3Úëdî:Øu)ö±?ÚìÙF;Ë®öW²½í­|;ÜW)÷¹²îvtÞË½w¾÷Ý|à×=xÂÞÝA  ;GIF89a    °Ç   ,       D ;<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

//-- We must change the returned mime type (default is text/html)
//-- And we must do it before any output

header('Content-type: text/css');

//=============================================================================
?>

/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */

DIV.tabs
{
   float            : left;
   width            : 100%;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/bottom.gif'); ?>') repeat-x bottom;
   margin-bottom    : 0px
}

DIV.tabs UL
{
   margin           : 0px;
   padding-left     : 10px;
   list-style       : none;
}

DIV.tabs LI, DIV.tabs FORM
{
   display          : inline;
   margin           : 0px;
   padding          : 0px;
}

DIV.tabs FORM
{
   float            : right;
}

DIV.tabs A
{
   float            : left;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/right.gif'); ?>') no-repeat right top;
   border-bottom    : 1px solid #84B0C7;
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none
}

DIV.tabs A:hover
{
   background-position: 100% -150px;
}

DIV.tabs A:link, DIV.tabs A:visited,
DIV.tabs A:active, DIV.tabs A:hover
{
       color: #1A419D;
}

DIV.tabs SPAN
{
   float            : left;
   display          : block;
   background       : url('<?php echo PHK::subpath_url('/section/STATIC/tabs/left.gif'); ?>') no-repeat left top;
   white-space      : nowrap; padding-left:9px; padding-right:9px; padding-top:5px; padding-bottom:5px
}

DIV.tabs INPUT
{
   float            : right;
   display          : inline;
   font-size        : 1em;
}

DIV.tabs TD
{
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none;
}



/* Commented Backslash Hack hides rule from IE5-Mac \*/
DIV.tabs SPAN {float : none;}
/* End IE5-Mac hack */

DIV.tabs A:hover SPAN
{
   background-position: 0% -150px;
}

DIV.tabs LI#current A
{
   background-position: 100% -150px;
   border-width     : 0px;
}

DIV.tabs LI#current SPAN
{
   background-position: 0% -150px;
   padding-bottom   : 6px;
}

DIV.nav
{
   background       : none;
   border           : none;
   border-bottom    : 1px solid #84B0C7;
}
PNG

   IHDR      X   ø!e   bKGD ÿ ÿ ÿ ½§   	pHYs        tIME×00Eÿ?    IDATxÚí½i¬$Ùu&ö{o,¹¿ýÕÚUÕÕì}å*îwÔÆI3Ð,6 Àðÿ¶X2,Ã²Ûð Éc${ÆÚ(5)J×^ØÝd5»ØK-¯¶·çÛ½÷øÇÌÈå½Wìn5î,^FfDd,_{Îw¾s.áu¾F³ØºÉÞk/jP¥JµF­ZÎz> Âqò3ñ¯zØÜÍ2$iÌYkìê1Á+Ä*Y!aX <üODxëõ·ëõºîÖ,·oØÖËôDôwo\µhïñ==ö.Óþ# / -Ââ
ayM ¹HªºÙ\¤íFºÂnàRãz<à­hnq\©RºzôñÓd×ñ|02  óÿ3SgÏ.óËÙFã=û5ý3OýnílYÙü&ÆïË/ åAH¨T	µ&ñÒ*aqEp£(E=?Äz6-lVkÔz:Ã$æ«ñ ÛYÂ©¶)^?IÉÚI¡d=,"b ú-kø#.fö/¾ xéyý/|Kÿ'_}2[èí3ña@óÝÔAÌ %åH$ÂèVÖ×°BìTª´QmàZ¥F{¾(¬Õ¯Æ¾¤3Úq²°DÙÒÅÕ:ö)«7`Ã
Yé!&B@[CûHàbæð{Ïeïú+úW?óûñ;¯]²y>¨ælúýËDÎ@­AXX!n-­ÖA´a+uÚ²/y>úA¸Ö$-$6=¼jÚaÑÂ2e*öÃzÍe$+UëÐJ¡ äÃ²%"~N? ¸9üîÓÙÇþúÏÒ_ùÜÄìm³ipøxäu_È³ãÿnH®7	õqµVZ¸± á:[Üò|t+uTkd	_µ»~@ZQXÅ@*t-ê¯GiÒj± èè­áÿ¬ X×^N>þ¹ßOÿÏÿ?É£{Û¬õ«^ÈÂÃÛÉuæ®?sxDî½n(+@P!àzÃÐX])±ïhÐ¡íûØ	ªØH¸ZGoõ8v×O¡»´FI"%BÀ~ÿAÇt`}çöO]xÚüøÛæ±WØc;ÿÑë¸Ù·³|ØºG>x¤eÒ
ÀHI

ðp­A¶Ú !A
dB¢ëyØÚR"?Ä~µJ?@V`[Ë´·¼k'Ði."Q>p9¡þQé0`=ûìþO=õÔî/_øïíßýªïõ»ãÍ@µÁh.[! 3,ÈR@g££	:ÙïíZ³Ûgìµs:¶4#ÖkØ°VØó åQWl	²°»°HJºÖ0èæ"Ìò::\n.`¯Ö@T m!pÀ ·Ù¿!ÖOÞüå×¾?¶ùâ¢¿ùZ,s¡ïýÀ¢²²ÔoBSÂ³ð$y¤àIJäØXVÉL"¥² SBL0nc¸}~Þmìß¾uÇÉ®Q¡R!¬ ðDli¾ò`-Zm?Äï#©Ô­GZoa#¬âF­¨µA½Dy¸E× ´HÿPÀÅÌásÏµ?ñä7ÿ«¿þ«ÍÇªåí½²rÃªg@Í°i~×Â I¡2@jÐÊBJ$CÎýá@P
_yð½ ¾ Á
d=°ñÁÚÉ$²T KiB¹u$Xíh·×3ü¾jÍ°Þû ò°,Aù@+% <pX¡g-zB@Uèæ"t¥Îâ
¶NÇKçïÇ×Æ3Já*ì°r4XÁºýâoþÊ¾pãkW7'°ùý&Ãi ì"m¾S'[íó¸yY9ÿ,,KÃÏ42XÊ ÊÀ"DÈ,R@dÒ¤	·	@I)$P¤à{BßGàð½ ô bdñÀh4&¤±¢ÓX KØÐ¡nîgX§d·;ìÎ'ÿ
:(öCØ0Ä ±í3wáÖ}áÅÞ³´' ä3Ë»ïýÊ_oÿÆüÉÆÛ··êÜ¹
Ò'píÅ´>ÄÉºr¼t÷;ìæI\}YÌ¹<zë(Xó÷ 0ãð=È8 "#)°L`E#z iABB@B
"/aø ¡À÷<H@Ø Â Öw1È"4vï&°%0S~Ír÷CàQë7dsA@. 	BØJÉwáÖÇ~ùÀ;ð«õ]þAÁ¥·nÆ§¾ýìÞ/}þó×ß±½=ZgP*DÊ10ÀÃâ®jiÙB(ÒË`víáçünàoKãÍcK0Âå1Ñð-¹­aò0zG*ö±'¾®æ/;jA¡¨È^
ç)T0@¥å@XU<QDÁ­Ö
:ñ c,QÐ5kr0ZfBñ0ã¢x­G>ã»Ñ6ùös·9hÌÎ Az¨ìïàÌåøûü4µ]ú×.k­úÌ¿»þà÷¾×þÙë×{RëÆ¤°ÖäÁ.;0äà2¶F'0¬ÝQYÕ¬m ø² <Z.r|BUûÝñåCùz;ÐÕ*!Î¯>sënd	ÁR	J0@>bhJò.bÜ	 " ¾ï9 O91PøTä
È +°ñaÒ &ñaR£Ø
X-a áx¤ÂyS"£3+r&È&Ày0C è´³à~ÜÜÀ?oïrXoâÿêö²*±¿®üóßúÖvEëZ§06óÐM<iS `[¬ã,Oþ «7s¿ó¬ÞÄ2Àâ Ëà© «§plmÛ»UØDBñÄpÅ2#Æ.®Ø?Ff9ÅTxõ£Ñ]B "!¹FÎ¯d´|À÷à/áU	ò¨*|Qd}­³Vû°Z5*¯ÀV(rf}Èü®?Ý6È  KA_kA_ûÿmkùO s»¾óÂþÒÆÆà}ÛÛXl­;X\ÆfXÜXÈü*3>b ÅýÎJ óÅç~ÏS'zMÈg6ØA7³ 8Ó|v÷NèTÉYÃ Ñ)¬N`	4b¸®½¯ÓQRÁ£:¤PÁSR
HEð=¿âÃWÆ x!ldB°ñÀVº¿Æk·£s! 0)é}'WñÏ>ò3¸ÁÌß8j$©  M­×d]¸°{Në$ÉáÿxÁ[2ÛÃmÆ¾ÒÁ KÁ´:¶ð¸ +`dyPÀ`hDPÊÃbãUGôéHðHgúD¤ ¬ß@«qÍV½¶eoDß¨¢ÁÈÿjîÃ²Alw`ÙBÀÊò*Zñ{`LÂ"F}ÑAÄ¼.¤$(%¡J)g½A5¢D¾ómÓ©Y6©I¿ñåÏà®Õuügøi|7Ï\×¯êYf>ùÂw¶H1°ò+Øiÿiêùv¹µ³9<VaÎvea(hÚûQÇÛÀ0ê@M=tüPkÔ¨:¤¥Õ ÁSC~yx.IË5ZU¢â7Ð¨­ Á:ª¥èx1 çÃUÃ[=±^ ,ÀÈ#9EÆlê§°¥C¦5d3EBÅ¯¢Nw­SÐ(^¤Z!Ï ë,ÃdÞÖÞAø/áÇú1<ÎÌ;õR ðüóÛáÆFïvT»b«iÿißUÂÀ_gÜÀ¹ ;êP
@°AAÁo"LáÕ»`#IúH³B
X6ÇVrò8HR¹5ç2°ÕHR£L+È}È A
	
êÕeÃÊ×`R÷\¤K`Î¹'}_9Uó^¤&g°Á$)l¢ÛZËø- Ù[5%"iº±SÆÇÂs¹ÑÁàbfüöo¿èu:ÉYc&5¶^#ÿi%Åýq¾¦,Ýhf·ß!Ä³ûã$áÝdiÙ\rÂç*¬04¡ÀCwÅ;:3¾1¨õziu¨Eò¤(:A¹§Z&AFDP¢.#+`Ëèö:¨ùÉ(¢&J4 ËÙÔÍõdfuÕ°
ºëç¥2>©áõÔ@ûjÇ¯B!l¿ûdc v÷P{þxìÑÇ= ?j´(±Þ$° Ä(EneÈãgÍc|ÒÃRÍÕÕBÀº\£Õ
lÌ'²:Ï3¦ñ ÈR	d:cD)Å°aöès|®«kýÔÏÝÿY¯qâ/úý´föÎë×âüÆ×;ç¯_K$hCåDvØÎ¹ÄU1!PMØ`ûH¾KUåâø/b ª£JP2@£ºÐo"bf4Ô)nMØnï`¥ºêSYAtýîúþwðAf~á0¤¸×%`1ça,/ri8+ú&<¦£<Jòèûû¸ã}Öèñ5ÌkPB@)¯ +ÁLRB	|4Tvÿ®~ß+È£ã1`iGA3Ã²-û\sXnbF½%Ì»ÞµöwÜuüáÊE½[1º4uÀ²Öíßpf¼Ï©k5~($`$YZ§È2	i>¬Òõp¹¨q<DÁ2òBÕÉR03tU:rDAàf;÷e5èwiùÒEÜÿ" 
.¥°§5¼]ybf>­0sáÂQîÐ@A£Ú;=ìíßÈ@9Rý@
Ïð=ãk«8·²zÙeãñuçÈ°Ö@H;óiôMÆ`çÜd[[ÉúõëýO>õÔ­»66veC`YGD¾tNó0Q0ûØ ÖmShÙÂùÁÐ\lÕ±~ò2`sknpjé,äÞÃ°©f²@´L¬$HW`)ÊÓnå Ä}V{[8ÆLÇ \:\äyBãLTXî	'ÁtDîcäÆÎú9ÛòTJÁa0ÛâRDÂC-ÌÀu;Ö³ÅÒZ.kÖZHòÁ´G2iS Ðí¦rs³W¿reG¤iX CP¸Î}âþÆÃó/]"$·zÆÂÈ1³Ì¡ÕÀ=÷,î?øÄýZí½NÛü/iï´M*Û!´©¸u £BÂm®G¨AÛ¤Ð`ø4ºmú=Ðî6V­ÁéÃÀ% À÷¥§µ»q4r®CÇÐJqas²u8þz×Øv<¤ÎPò%)(¢hi>>0çù½å²ÈE[ RP>ÖÂr² 1&âëÌº¬áuÐÆÅYûãáÅ ±XæÇÆÐÚºD<ñìcÊßV×BýwþÖã?þ¶7u¯k§}Ìwk}Î9gò%jH³ä¥åÛo&À úÞ6äÐÒÔLÅ$3ÒÜòÇçÜ2,×ATUðô:â*¡:W@¸¿$ )<@QµKäÒf²yZhhí,3µ eKÔÂ<²7MI& ªVº¾O%`¯Ö¤L1ÒÜDµ³b
Dªä§ÖÂYÃ£6½mnnß´ÿäÙowåþlïäKKêJ»ßfº­D¹â*$CÃK`Ø:*ªèÏ2ÃZZÞxÕYðCÅ $1SÀrï©W<(ÏçþÛ)3IEL
xz-'rÑ'hø íä^æ¦Äå¶WRkÄÑ¥â,µ$í81&Aß Q«)ãy3eD G&|&Í1âÒ»î|H³§ç*"Ö _°þÞ6î¢ímÝ)ZúÄÙØâ`*CÊÓ`ØL­¢*º±\gÿ¶tÆ+7®â3Äø\8ÖSÀÂ]kxêÉ}yä"wè#ÇÎ=å¹/1JQYæß|;ûÝò~æàòvXÌcpÛÓTIÂ´}×ÁT)!)§`Ê£C¡ôNGs½³Ì3Ì?ÁÂNølÅ` ê1®¾BP +x¨"@M7.©EApT¿@ä!ÛO0è·Á^ßiëJ c"DÈÝMÔ %dÖ°èy¢>d!¥µ13ò3@ç¼ZæQ´x¨å,æT	¾JÇF)K0Í§° Îz;Úv®â@4 }æ_'ï_©5dºwim¥wÅ eáÔ´SXÒye_pÖ¾s_ÇeÅèÚGqv÷ÖeË±"ÍçÆ&>³°¹µ[×¿&OÜ}ÝQ²	V¯ßíïb	 e Z.¥Dc0È&cW&K0ºìN_	G:?{d÷AËGæLg[ ç4 cí(Ï6Ò«ÍúÙ0ÿF¦.>¯Ï+%
ir
õRÔûªûÀNGÀ18í[8§c+Å)DCO¤wMè@²¨ä>8§u`qD\P·ïîzû¸#ËpæPp	A#Ë5òI¡¤SQÍû\CU¬;ÜrÍå9Â¢~DýWY½À("mhñPpèÇtÄPJÍ#AG±ïÅ¤åµ0èsi.I¸9Î`ìøx
j	ìaºÙÂËf§
²)
!¼TÁÌðl@5`ç×Ç]8 ô2°ö¦×,¢jÛ×Ñ8Ô¡^/£"°rru®C}®¿1ÌÆÛdÎs#Y	î 8}¿bQmh(È S[Ö0Äì>J¡úíªg'"Óy¾ß¼hMÀwjaºJ[@FÃlíÑ¬Òë0H%WXèt µ±bdý8B=H¡£êÁÌÐ+¾Ïk[úC-WXTùMÑGð¹Fªq8D$¢çzæP
@ÖöQ¹ã:üÎk$L¡ýÊ¸gÖ`¶°ÈE9õíçsnêÑ]HåCãØr±s"Umè"hËë$YËÏ#hÔC(
ÐOÍº ,w'ýj!J£	a}ó:Î%v.¸PF#0 ¥ [Å~PIAÀcUE(FrG.ÏÒtæwgk§ïw¿#;8¶^Ç}÷Ã1ÚqVJo¹Ü"ÙäjÔùRk¾É¸íxy=¦YÖ,³°®è¬0SQ;¦$C¬«éw>vZ_ßÃgÙåIÁ03`0· dÐÚßA@®½À4C¯/­-¡ó1´á)fy¡/0íy&hL¢À2O2ê}Ð¾¸@·Y,.VÌãï;÷ê?þï|õôÉ¥lxãÆ¼ç¨íw:#qÔãÃAÇ>Ú³\Ãã²ÖÂØÔ3¶ºNîß-{ÊÃÝçN>ýwøÊ/ý§ïùw¼ãäv%TSÀiªÁª;É3ºûLqO0cu®Ïeµ,ÜÁ/¼Î¶º¬?$¸5â¹R 1ø)B£4Z4ÒsYXèü¯Ñ.;ÏLãÀa¢þX`}­©ßñcõ§?úá»÷ÇÞ}záOþèµ_&¢¥2°ÜM´lreÄmAÏ9V{ÖoH«o¤)¼À xLÁÐáû¼åVÓ³O¼ÿÎù4ÿ«+õNà«Fk!üx¯å*4õrmÞ´¢³Ï4Ð$Æê¼£Ê2­YpQ"!Ïå*µáZøÉ^.ãÀ!èL^lÀ)!û õm\éR(ÿ»²1kóúC®,Ë°Ð)A«@~àÌSïy|á·Îß¹üÙzÝ¿WJú%Ç	ú¡Û°	ÈÐÇxïæK~¦%7¥ýÐðÜhtýqf8féçÉ¦½s@Ø³g[WßvúJ§T´±ßk6ü_ a,#ÉzNÕÝ¥¨æÍ®Ïµ\I¢IkëUã¡CIg«'ÒóV:ô\ÐÐãð¨Nkukï.%ßÎë%¤PRBI	)Ü2å¡ Êõâúé¾ïÞµ§îyàßzàáæçî½gµ ­õÆéqTlØ¤Ît¨OGUÀ4Æh÷¿,Ki&7MYúáðÝÄXuþÐ9ÀzitÛÌD°A £J·µNkxÿ{qA,Sþµkøôµ×øÄ¼Qij¼I`Bº¡Íg89Î·§<a'Ùé¨Ë$ÑèèGk¸2lÖ+¡z8çrvê®æS¼=ø­ZøüùsËm"bfÃP%ÿLC`qÎs9M×E²ÍmëÛPÒck:®t*Zbýönz°<1LN.=Ì23QÕç|çÒG,ÛËRÐÞ6B ÏíÕêÍ » /­Ûëc5LµË@4Àòæ5^vYÊi¿ê÷3J]KóÉmÅÜâ¬/3
¥®Òl^Nqfúèö^C/´ªæñÿèÜÆ»Þ~ês'N´þÍù;¿uþÜr· ÃMj5/¡¡æ±à[kAÎ°\3@ÆÖbko¯ô	äU×ã<"WÌ*,´ê8½þ´·WaSÌTDPÊ¥7cp¥©ô'*×oæà"ù)öwìZã? ¯¯¬Ôº¾/{ÌX*Ëá ßá-E`4G:²¢Ýk³ì¶© 1ª~?CJX¹ÊsUg;u ËmËý`¹fêÔyX1|4pËUóáÞõÝ}äß8{féÏÏ]Üm5+éNjU/ñ[#ËæQ(Ò8¨|.MûÑ`¦¸@F8½$Ã
¢@¤<ÙÃìÃ@DLèÎ¯ýþ§ç_ç¤ùxkÈ½¦/3ÀÌÍ²ìï01óÝÌ8à)põºÅ®Bi.D|Ã=#R	²!ûM<Ö©$ÓE¹nÓxµ¡ýØGï¹øÓ|ð¿¿ëüò¿;sfi0-N+UÊÀ*ªQ±¶`@°yO í&#©mFÌðKDj:HÌo§ÝhàòEÛøßL?Þ\¤&±6oÜå¯Ëã¸e¿¶y­¤éË2#»%Azdû» ^+IN½êRc]SÚéëp¶rMö6òb(W"öjÔ}þä'îõïÿÂc¿ræôâ?ÞL(ÔÔPéÜÿc!ýã¤Î"?Õü. ìÊ®¦Õ²®¸ ¦s¬³öë¢á±2Â±ôÑ8ÿhI2:I@×¯ppó*wkjP¨æ~£8Z¤¦!-¥VOWTÅ·®]¶µÙàêeÇºÎ¹?Q&mæuRú<NyìsEþQ«	<úñÉÍ~eý~Z1Æ
$AE)Àû¿óµþôCÿõý÷­èÐæ&¬(ãîO¡Ükd¹rMÍï"+Gë<`	R° e aÁ,ÉSÂ\Î/8NóÁùÙÃr·EßCåøU"átLÀZF?êÁ2Ì>n&Ä1Î\ºÈ«³"F52Ý,Z,.£RÅ¥I4JÛý2çæÉæSgBûóÿàØ?ô©G¥R{ | Jk[ãÌïtãj§7ÒÔgÏ,=Õj8¹ià°ÖÕ°ÍzÌoHRXB!ôhÊ`©aÇÀ &dÚµìÊi¿Å¨sx¢4RqhþUxÒ3.NÕ ¨ËÉ0êqò~Ç+IÏòaQ×·oòÊ¬QÅq45QÉ~A®[.ÎÀÁ£a±P¥=ÏrÍ jM>òy"ñÆ¾l*+5­yvÌ'ÀúzÍ>øÐùvn{{«_»|y¡ÓÎ<K¸Ë¤:ôxJÍ9;¸ñÜÇé~°j0h«³ llÂ[¹
ée vÛ{  êIDAT (´Âã¸úíS(:³ûÐgR§èõ#xk1ÕQ~g)M°çKJTZÊ2SãÒ=ªÛ«7±ZEv,Á)$¼áÉtÆ:K¹O7á%¥ØÒé½÷a´X´jóZ¾"¼÷î?ù§þÒ7_øÆ7®¼ûþäÅ_ú«/_=Äv,çÏ9-¼ôl¢çt;`zyQuûZU{xêÍÍ6®]{)öFn>øcïT' ³å±æ-IfX¤ÜÃnòE æÅ"ÑMKlÅÖ`a\BZs0	,fÎå·Tªú,5*dÙBn±Ðæ¥[ÅuxoÿF½rG~CJ2E`9*Âéè]yO¸<,&4Z²südíOl=ùÀýÇ?w÷]ë/·°gfgËÛ$´«!P(fKzýAÅÎï@tç¤]X§×_ÑGHlÄ
=×f*D6S`ÙM	ûöSðé^Sªßd­V±£àh!/É',(r&ý TÄí¼@ö<Ö-Ùq¿k]Ø0GíP| ¬eúØR=ñFxÀr»qàS·9U»9&Ré(Ê =EÀ:§Ü	
º½AÍQ1ù@	ÀH¹ç¾*­¨«¯pu*Z¬V´v°f<OgTçN\èëU %Ms$}
rsü¦MñP©x=ß\ÖH,h5Ì¨t^ÖaÖ¡×f$±0Ôk¾{ ªbf¡SÃ\1¿¼DÍ@ø1+%ùPæIH;Ýî<#êaýÃt&a´`)Å5DIÊ7H#1}ZF4à;¯½f&#FU«ùÊ;Xy)O·ù×Ì¶$,w³ø­2½ñ¦ ¬ZU}Ï<©éÏ3,`Ç¹ °èuúì»ýz&Ub
XÌ8N¡LAÒ2_¹à(?»"Y¦A*REÌRcò!ázªº{ ±½¿íõÔ}	G:øÉ	´o4szZ Ð@°P#¨)5 ô»¼ÜÞãÅÉQÕëef
X<êjCÖ43¸®È¥2FÃpåc÷¿¥Tòr]½u¥MV»ß¸ãNeWT2O2ûúÁåE7$QËÅ¿®ßôa)M¨ÏbÐ³Ugm4S©xSÀrõ¤§gZÅi+ä×ÄÈ±NSVñT¦Ùl½Bîû!á~g/>ã
o@$°¶´3­ B6`ôÁz+XkdÀN03ZÝÝ²`Ç&#F*H3]¸0â&î^Ly0hãêBZ(/¼q¾ÐÍ²áÇ*á»J*<±hxâì;îTÏÌÊ®¿A+ñ`ðtU¹±.A\o9ÛiztT¤,?'p52õ<±ëû"bæJX+= ³¼OÐÁÂC©EÞ©B2]Û1'eHî!çlíÎ p&<¬WúÊBg4¿TÕÑRÈÕúÌhuóºBâ>cÐ KúùX4ä¹ì
óï[hh°µc¯Ý½Ñ!Ïl! ¤ÀéSö|ûK¾ÓÿÍµãêoÖ«ÐË<Oò°ÌXºqØÀüI#òùáâfZ5ä'>Të4èåüÔc7¥] "°iÂ¯%X=­a2rí¬ëj3Á' QÚGFk¨?"&f¶æAR·¦4+7¡I |$£)T¥ÈÁ\"¸³ÇH"^ïìqXrè}_Ö¢(°X¡sëØçCèç,»;)×õÅ$öPEÃúz?ò¡·½òè£'~uy%ü¬ÈþåÐûÔ~0öe[,Û»1¾úÌóð=5TM(û0±Ñ¨àïýÇî>öã§þzS|}Z
Uß÷EJ<Wó\¬ÑR¼ðê·VPR9k-¼\ä¨ IèàÊÆ6øF6<êB½¹·;ºx ÁVVÀ	6NkóI´ftw3°6SªZ,Ä:3È8B½¦÷eO*8½ãÜdØx0ÔÄìZý¸ò)EÊóD­?p5EqÓÏ»Lú¬Hq
d=Ï1e÷³V$>ýG_üïþÆw,|×ó9@aÊÃÈÛ±rR
ö}9¶k:«-öÛÙÛ¡ýäùîû?pÇ¯-­Êé4|lµê§¾/u±Ûæ}çu¦ñâÅËÒuk&P>=f¤$|T Ít¡½yç.¼«· É)qeA+!ÀØÅ.4Gsâ4Æ^¼¥!CGÞb<Ñ8SJè´3¤WuÊ³Èb1£é÷ñàÍ+åQI)ý^:ÁïäÅ èÉâ@XA8wæ$ñ®^¨Ã§!½ÌaçÂbð7åyéX÷½iÌßñx>iÏF)2R÷Á$xÁó	~@ö¥âMñËRÑÀóiày½ßçö<ÒÊ:ûÙ§²AH[B`$Í.0>ã*l0Gø©ßüïþÍ3w,þkkõ¢´<OH¥6%ËÂiflF·e¸:å¥=´w3WÀ[ A 1ÒR 6ì¶HBx ÂBjhm§e é/_¾K×6FzV.ä 6O`¡FûSbEf`gËí=ª#F%%5zýt¢fÑ´³\<­þ2!ô8sâN4Í:n\00C¾Ê¶Èöo~QÓS_¾U#Â9f¥b!ÏÔl\ïÂP ¬û!qöÁ~@ð°ç	( ±¹& ³g¼_»S-Îä´
»É¤F3¢1x¸·4`BàlýLwåñ«/µ«/EøÆyê+1ío,<Ú¾|r­¡%4§ù¼A\ËîïØ2y	áôÉ~ê÷ag+ÅþìUô{	ònÐ á¬mCïîÉÛ	[oà~î1|à'îq¢1d¸ðâüÎï=ÍÈeÁR
6®AÝ¼`8R½¨fÅ ¿?¯Û¹e©RSgªT%5»¤¬|ØM<Wb\1<Â«,ÃÚõÅgïqý³¬sZmî¼Z¶ÈÛu»Úa{¯±"6ïfS¨"ÒÑíZt;Å¦ll/)[H¡
yeÿçÌÅ= >ó{Àþ`óBàÃo¥ ¤ç\8ZAÓ®L¨KiÖ°pWàÅ?÷4£óXÃ©ÿÌÜEPZ¸©^,»ÉPß¶ÒÂ}ÇÏáX«éj/stKÃÓÇë¸°»cu>ãF»èàS`#dÜõ²wÀòGòczQµ³¤±Ht"ÆjÔýÚ%KaÞm4þß¸¨Ñïg%`+b4,¨c/\Çþ v îocñ!7á|óîIæÆxè\n2|O¹xÏ1Êl	Öº÷Cº¨køFßèÑ÷zXIù:ÃâÝ³cNnä0
ÓÓPé;×Ò= ~
j2}á&
ø£Î¤ÀÍ«'RúîLÉÛw^%üîÿ¬ñûáp³Åp5û;ç±&Ï»ÔVð¾¹kâKX]mà¸÷.¶°§/â¦þ»ï¦ ) kÈîwÚØ6ÀÂG¥ PØ»²ä®!:û=[ßÙ´£ù]j(-yã7!Î3i¡í }=Âë£§ÓMK£D9GîxÝ¡+rÎ]0÷W
Ç	) û+NäßÖRõ!H@H§oW$Ü>IHæ£ÌÇ=ÃÿýOÈÄC½Tþ©Ëp|®ÅhÃ9-MüÅHÞd-) !SÏäªJ9Û¡bÅýM4
Ëî½_¥By{o¦YÃêR+ Û8©¢5!2£¹#eXHR¡Dý^VøÕBY#ÝuÐïðÛ®¼l«C§^ð³Ìe­EÔjuÂsFO¶(R\nAþ£úxñ¡pg.sFÛ¿wß1zàä÷Þ}FBÖ³è÷¹ewpÄð	ý 0å}äÝþ(bàc{ÿêUÚéh`Qí=^Çb»w	]s=÷-?Àjã{i?D°´fÍj4óÈ0ÿÚíðÛ·lkHÀ)c¬(VþXk¡Mý¶}´VrÖÚÅ5(Û)ãGXÁ´Ã7å(ZþñßÂ{ÁïNDÐlVÐ¨- ßUØì@éË)õ,4×QÙxÄ^ôi5¤ô°º|{7¾sýÍ¼Ë Ý ilÊ)À[×N¡ÚAim%&eL~ß¢3hc¥"¢ÁáKBsZìç ûÛ¬7©oÚ0Þ=ËK5__EÜ÷°³{RðÈÃ'ð¾w=½-\¿èDå
|	 x "Ö!¼Â'DZ#1"Uo]3ÔZôïbÆ× $®ÚÚòX]ê`g¯åõÕzÑàð|²`av
1"ï´èÄoë=ÔKUÜw÷di«× 1À#Àû >ï]që5	¶@U¬!ðjN6-=È®ÄÖ%À¤;Mxµa0h{£éõ+¤Ò ±cí[¶psZ [Û]Ü{*Bs±Í£²uÔ²·Aq±¼	#»yÃýbEöXS,à)MXA¸3.,­;?~=J{µùo)°UÜ÷¶óÙ®¿¶Ð¬ã¾{Oá½ï:Á^×/ÅèµCd±ç3¼ÐRJÐåAÉFäµ¨DÐq¤ÐE}9Æò)4ò0h{èî½6ß¼î"F²ÐÌ 3cow öúh.2Äm?ä´ mì|½ÄPRÑr!E2ê¬ë¿JÕÐ(ÎèaÇ\±kÔFÀxêPíß{\Ò?ùì¸zSø;^ÓbZð=½néÍµÉïË¶gÏö("¡×BU.ãäÒÞ)ìÜ$Ô¢¨]l_à¹¿èw	8yUö±r±w£`q°u¥R­37î­Â>*U+-D]/¯lê£º %MÄ=í]{ÿÆ+&`f¨8É<=X c¥ØnoãôSXxEawëèjbÅM¤	¡g<axÎdæ*M8êþ]Þó:Ëâq^)Ë7¦×uÑ?,Cñ·ÆMïF ¡qJ¬0³{ÉfO§7µ>÷ïùg«øX²Èv{[ÈVÂºE¿áúeFw«$u¼C	Äq`ùDN£½®F£µ½Î>D²#|¤± Ap¶¿-¡³oîjïSu¨ÈÂ@ KÀZ.\Á=<{9g¾bÄ·gú#?mÝZ¦YQÏy^i\oDÇÜ_Õù(ëôCDÍÛ_qtË@sÎ³ìo8ü H­&Ì^CÁÄHObw½}ÏÊf,A÷¢ßëÁÈ.+È-¨ëØJ7±´XéUA-@ìì¡Ûî!hÞDmÀÞ`åxs	Àkby¹òôù»§TÃ©Qnmuð_{w¾½ó÷{ÞtaJÁ<£¤¸Àó+fm7¯eæaë~ó)í(e ÃzÍÂgCruD¬r°"ÏûIWghóî¬\oxv@!xÿâ Ä>£ÿÒ\Ï
Gé³\Je$[h_¯c÷j44+K¡j](³ýÝã»yb;hµªèmWAõkh,e¥ëì·Ð»~ýkhï2­¬Ëw2CªLÛ¿~äáãüüs×ó4¡Ï¹Wzuá¥ëXY~ïýàû°¿#qãþ¡ù®GQcuetôí&ÄÖeÎCç ÎóöõLúPDÓÜ6ì³*²=j¡Z0pt)7å³Í¬Cô®ØµûÃSf÷4º=,%¤ý*$«Q$×ËYÁ$
©6.G0ïÎRboopé±Ç¿:ê£P ÖP¢µÁß|ýûxuë|èï*¬S ÂõutKvHÜêÐÚÊYÍm Ã!%tGh{Øòäï©Y±E^¨0ÅÒù+8ûÞpö±Ô®	I}Ø £÷\¯fu4òÀFÁDÕ«,ôqìMydõ¥F=M»zsÃZ\¨$ëkg=OOR3¬á%LRûGOãÓÔøÿâ=øË?Txñ¹YjßÔzÃ×mÉ°8Y²ÉÏf­{Ød¥u&­¦{èµnÉbÎ³Â24òÑ E´1ÀÎ~¥Z½¶Åc)Ë©k'eÏc1aO;Ú>zqý+ë/²	A×>±·ùêî»WM÷Ý·gÛ	¬ÑÆÿýoÁw.\Ç?úùÇqîÞ5|ýÉ»[:ã*ÍózAvà¼! Ãº*b¢[àïõlªÏ*¦;èC#jí+¬­® ¨'HS¡4 k»Ñë=#¢rª© -/¶pÇ·cÐ9ÔQmÔ @z;7-ºýìÔÊqÈ_ûµf~fc7Òøì·¯zÙÀ*¾¶¶zøê7/âÜýïûÀ*`ö\)*Gv?D°ÑIÊ¼ ì(ÑááQãÁëeÛYÇL|?+"¥#3	¯±F­4Õê	°ÐÆ ð%t&0ÈÚØno¢ßË0èQôA1è2ú]N´ mU$±¨6`$â4ÁÝyxðÑÚ¿V øÑGO\øÏüÒK~åµ-¬!fúÿê÷¿ów¾<qÎ<º¨bçÄÞ-d IdÏ¢²nä7K1Okóæ[ªÉÍfçQ#Bk©wv4¯pñÆpbÞÝ¸tÅDõÄ\±:¢| åÉ®Ê¿a¡½,Þµ©¡3F5ÑTNîaõ®>jBðÚûFjâJù6¥%LWbáØ6Ä 6dý*L³ÖÉ=	6^«RX?A²Þw/Üü?þÓ~ãÿ_yøÆ¬É[,!NoáÜU[]D=XMªº
qÆ5wù­a.ªT¼á<lLí0®«äï0¯´NÉ²RÖð&>ãmJ`¥Ù­ÂGú*.§ÈºÀ×éNÏ'9>iËpB!{Ø'Ïa#¡sÉ¸÷=ö¯×ÐÝõ&|	+vot¬]¥±Ê#,/øßþxõ+eùÊµkûÿÝG?|ï¯ýég¾sÿînÿHÀràdDQW^ÝÆ+¯nCæ`«×,¶ª|T±BÊÇL<M4oX¡â\f'IÏ©ácúÇg34(Uzv ý9ÃQ¹ÛÑÍ²æåRW	Ñà%,âEU¤}:UH²èì Û¨Å)¤Ë­$¤®¢×÷%"o%KÆ5°»ÜºfVÔð <OÆÛÛ½'Ûødÿöþ½Õí>ñDRù(É[cAÁ Åæfo½þý¿<O¢Ù¨`uy`¡± Táêh:Ò¦1zÔókj"i+6@µ!¨M?õºÀ¤./×:O<~þ=OÔ@ýìÓÏ\}ô{/Ýq¢¬·^?¯,3ØÙíag·"@
åI4U,/5ÐÐ¨¯IàfL)ùQ
	â¬ÃW\S;U¶õF'>þÀÍõSôÇj2ÇÌW?ò¡{ÿ×Åê·ï8½ø÷¾úõ×>öíç6Nlm÷h8³Ù[ÀúÛýr%¶¢66·:â:ÊSÞK`´EêÑLÀÃW£àÓ?þðÞmÃ«&U$:ÌüçË+õï>½ø­<ñóß½pãÏ¿p­¾»;@jö°þV¬ ÃØÛüÀûk4B|ì£÷]ÿèïùÎYúãÇ½C8ZÆ×¿yé®W^Ý~ßÞÞà±4Õ_¿Ñy`ãÚ¾wáÅrãêEq­ÚÀÎ\]©¼>!èÜ?ÕsZÇõ'¼czCò6Vç`½¯F#ÄÏ|úáøÉ~ýáNü«ûî=¶GDGëäûêÆØËWö~æêÒ­­nãäñÖ§vw£:IðÝlsuÑDÚ8ò÷7lð[Jû¹e.¶PMÒÉ)eæûÕ*%"+¥)ÄRúÂimcÎ2¦q$qÅX-Ñ*I¢j&c¬-,ÇmÀác­-ÑC½X©å
¢fm+õ³zµÑ|D)r>39by²RærGfÆµëmºtivv®¡Ý½)ÀúÔÃ7>ññ~ý¡Oü_÷ßwlwØÃnõ£íµXéõ2¹µÝm¢¸j]ôK¥;.èÁ:¼v.3¡)Ïãz­i|?°DÊóY
ÅÕ¨ò½p1­µEÊtFYR¿ßA$ÑyDÌd-bÝ9ø¾äìÕÏ¥°=ïÂE<ÁÆÚáÔîÐÜ£a·Lã{#GyþÐqãÍF¤3Ê__o¾;MõÇ®\Ý}dk«Wù/¾$:.í"N+#¥«ÿ¾W½à§?õÈÍOòÁ_àþã¿7´XoØ°ð#VÙCøÑ~ÑµfPðÆÍvýû/oVÁh®­5~ÎZn\¼xë'¯ßìÿìç¿.nÒövq¬â¨×9òÕ:>þ±ûo}è÷ü÷Ý»þ/ßv×j{²ëÐúÍxëõ>ìÌLÌð±ôÌ³WÕ@¾owgðÓívTç±U¤I½>hÔþ;n¸bàiü)OÏÙï§~ÿ}ÇâYó.ýØìdSì    IEND®B`a:10:{s:4:"name";s:5:"phool";s:7:"summary";s:31:"The PHP Object-Oriented Library";s:7:"version";s:3:"1.3";s:7:"release";s:1:"1";s:6:"author";s:48:"Francois Laupretre <mailto:francois@tekwire.net>";s:8:"packager";s:48:"Francois Laupretre <mailto:francois@tekwire.net>";s:9:"copyright";s:58:"Copyright Francois Laupretre <mailto:francois@tekwire.net>";s:3:"url";s:24:"http://phool.tekwire.net";s:7:"license";s:71:"GNU Lesser General Public License (LGPL) <http://www.gnu.org/licenses/>";s:14:"license_prefix";s:8:"/license";}a:7:{s:15:"build_timestamp";i:1360951519;s:11:"map_defined";b:1;s:19:"PHK_Creator_version";s:5:"1.4.0";s:15:"PHK_min_version";s:5:"1.4.0";s:23:"Automap_creator_version";s:5:"1.1.0";s:19:"Automap_min_version";s:5:"1.1.0";s:15:"PHK_PSF_version";s:5:"0.1.3";}<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <francois@tekwire.net>
* @license http://www.gnu.org/licenses GNU Lesser General Public License, V 3.0
*/
//============================================================================

//============================================================================
/**
* Static functions used to display messages (normal, trace, debug...)
*/

class PHO_Display
{
private static $prefix=array(
	 2 => '>> ',			// Debug
	 1 => '> ',				// Trace
	 0 => '',				// Info
	-1 => '*Warning* ', 	// Warning
	-2 => "\n***Error*** "	// Error
	);

/** @var integer Verbose level, default=0 */

private static $verbose_level=0;

/** @var integer Array containing the error msgs since the beginning */

private static $errors=array();

//----------------------------------------------------------------------------
/**
* Increment verbose level
*
* @return void
*/

public static function inc_verbose()
{
self::$verbose_level++;
}

//----------------------------------------------------------------------------
/**
* Set verbose level
*
* @param integer $level integer
* @return void
*/

public static function set_verbose($level)
{
self::$verbose_level=$level;
}

//----------------------------------------------------------------------------
/**
* Conditionnally display a string to stderr
*
* Display the string if the message level is less or equal to the verbose level
*
* @param string $msg The message
* @param integer $level The message level
* @return void
*/

private static function _display($msg,$level)
{
if ($level <= self::$verbose_level)
	{
	$msg=self::$prefix[$level].$msg."\n";
	if (defined('STDERR')) fprintf(STDERR,"%s",$msg);
	else echo $msg;
	}
}

//----------------------------------------------------------------------------
/**
* Display an error message
*
* @param string $msg The message
* @return void
*/

public static function error($msg)
{
self::_display($msg,-2);
self::$errors[]=$msg;
}

//----------------------------------------------------------------------------
/**
* Display a warning message
*
* @param string $msg The message
* @return void
*/

public static function warning($msg)
{
self::_display($msg,-1);
}

//----------------------------------------------------------------------------
/**
* Return the current error count
*
* @return int
*/

public static function error_count()
{
return count(self::$errors);

}

//----------------------------------------------------------------------------
/**
* Return the error array
*
* @return array
*/

public static function get_errors()
{
return self::$errors;
}

//----------------------------------------------------------------------------
/**
* Display a level 0 message
*
* @param string $msg The message
* @return void
*/

public static function msg($msg)
{
self::_display($msg,0);
}

//----------------------------------------------------------------------------
/**
* Display an info message
*
* @param string $msg The message
* @return void
*/

public static function info($msg)
{
self::_display($msg,0);
}

//----------------------------------------------------------------------------
/**
* Display a trace message
*
* @param string $msg The message
* @return void
*/

public static function trace($msg)
{
self::_display($msg,1);
}

//----------------------------------------------------------------------------
/**
* Display a debug message
*
* @param string $msg The message
* @return void
*/

public static function debug($msg)
{
self::_display($msg,2);
}

//----------------------------------------------------------------------------
/**
* Convert a boolean to a displayable string
*
* @param bool $val The boolean value to convert
* @return string The string to display
*/

public static function bool_str($val)
{
return ($val ? 'yes' : 'no');
}

//----------------------------------------------------------------------------
/**
* Converts a variable through var_dump()
*
* @param any $var The value to convert
* @return string The dumped value
*/

public static function vdump($var)
{
ob_start();
var_dump($var);
return ob_get_clean();
}

//----------------------------------------------------------------------------
/**
* Display current stack trace
*
* @return void
*/

public static function show_trace()
{
$e=new Exception();
print_r($e->getTrace());
}

//----------------------------------------------------------------------------
/**
* Return displayable type of a variable
*
* @param any $var
* @return string
*/

public static function var_type($var)
{
return is_object($var) ? 'object '.get_class($var) : gettype($var);
}

//----------------------------------------------------------------------------
/**
* Convert a boolean to a displayable string
*
* @param any $var
* @return string
*/

public static function bool2str($var)
{
return $var ? 'Yes' : 'No';
}

//----------------------------------------------------------------------------
} // End of class PHO_Display
?><?php
//----------------------------------------------------------------------------
/**
* @package Phool
*/
//----------------------------------------------------------------------------
/**
* @package Phool
*/

class PHO_File
{

//----

public static function file_suffix($filename)
{
$dotpos=strrpos($filename,'.');
if ($dotpos===false) return '';

return strtolower(substr($filename,$dotpos+1));
}

//---------
// Combines a base directory and a relative path. If the base directory is
// '.', returns the relative part without modification
// Use '/' separator on stream-wrapper URIs

public static function combine_path($dir,$rpath)
{
if ($dir=='.' || $dir=='') return $rpath;
if ($rpath==='' || $rpath==='.') return $dir;
$rpath=trim($rpath,'/');
$rpath=trim($rpath,'\\');

$separ=(strpos($dir,':')!==false) ? '/' : DIRECTORY_SEPARATOR;
if (($dir==='/') || ($dir==='\\')) $separ='';
else
	{
	$c=substr($dir,-1,1);
	if (($c==='/') || ($c=='\\')) $dir=rtrim($dir,$c);
	}

return $dir.$separ.$rpath;
}

//---------

public static function readfile($path)
{
if (($data=@file_get_contents($path))===false)
	throw new Exception($path.': Cannot get file content');
return $data;
}

//---------
// Throws exceptions and removes '.' and '..'

public static function scandir($path)
{
if (($subnames=scandir($path))===false)
	throw new Exception($path.': Cannot read directory');

$a=array();
foreach($subnames as $f)
	if (($f!='.') && ($f!='..')) $a[]=$f;

return $a;
}

//---------------------------------

public static function atomic_write($path,$data)
{
$tmpf=tempnam(dirname($path),'tmp_');

if (file_put_contents($tmpf,$data)!=strlen($data))
	throw new Exception($tmpf.": Cannot write");

// Windows does not support renaming to an existing file (looses atomicity)

if (PHK_Util::is_windows()) @unlink($path);

if (!rename($tmpf,$path))
	{
	unlink($tmpf);
	throw new Exception($path,'Cannot replace file');
	}
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

public static function path_unique_id($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//----------
} // End of class
//=============================================================================
?>
<?php
/* vim: set expandtab tabstop=4 shiftwidth=4: */
// +----------------------------------------------------------------------+
// | PHP Version 5                                                        |
// +----------------------------------------------------------------------+
// | Copyright (c) 1997-2003 The PHP Group                                |
// +----------------------------------------------------------------------+
// | This source file is subject to version 3.0 of the PHP license,       |
// | that is bundled with this package in the file LICENSE, and is        |
// | available through the world-wide-web at the following url:           |
// | http://www.php.net/license/3_0.txt.                                  |
// | If you did not receive a copy of the PHP license and are unable to   |
// | obtain it through the world-wide-web, please send a note to          |
// | license@php.net so we can mail you a copy immediately.               |
// +----------------------------------------------------------------------+
// | Author: Andrei Zmievski <andrei@php.net>                             |
// | Modified by Francois Laupretre <francois@tekwire.net>                |
// +----------------------------------------------------------------------+

//-------------------------------------------------------------------------
// Changes from original version: see class description
//-------------------------------------------------------------------------

/**
 * Command-line options parsing class.
 *
 * @author Andrei Zmievski <andrei@php.net>
 *
 */
class PHO_Getopt {
    /**
     * Parses the command-line options.
     *
     * The first parameter to this function should be the list of command-line
     * arguments without the leading reference to the running program.
     *
     * The second parameter is a string of allowed short options. Each of the
     * option letters can be followed by a colon ':' to specify that the option
     * requires an argument, or a double colon '::' to specify that the option
     * takes an optional argument.
     *
     * The third argument is an optional array of allowed long options. The
     * leading '--' should not be included in the option name. Options that
     * require an argument should be followed by '=', and options that take an
     * option argument should be followed by '=='.
     *
     * The return value is an array of two elements: the list of parsed
     * options and the list of non-option command-line arguments. Each entry in
     * the list of parsed options is a pair of elements - the first one
     * specifies the option, and the second one specifies the option argument,
     * if there was one.
     *
     * Long and short options can be mixed.
     *
     * Most of the semantics of this function are based on GNU getopt_long().
     *
     * Changes from original version:
	 *		- switch to PHP 5 object syntax
	 *		- make independant from PEAR error handling using exceptions
	 *
	 * @param array  $args           an array of command-line arguments
     * @param string $short_options  specifies the list of allowed short options
     * @param array  $long_options   specifies the list of allowed long options
     *
     * @return array two-element array containing the list of parsed options and
     * the non-option arguments
     *
     * @throws Exception
     *
     */
    public static function getopt2($args, $short_options, $long_options = null)
    {
        return self::doGetopt(2, $args, $short_options, $long_options);
    }

    /**
     * This function expects $args to start with the script name (POSIX-style).
     * Preserved for backwards compatibility.
     * @see getopt2()
     */    
    public static function getopt($args, $short_options, $long_options = null)
    {
        return self::doGetopt(1, $args, $short_options, $long_options);
    }

    /**
     * The actual implementation of the argument parsing code.
     */
    private static function doGetopt($version, $args, $short_options, $long_options = null)
    {
        if (empty($args)) {
            return array(array(), array());
        }
        $opts     = array();
        $non_opts = array();

        settype($args, 'array');

        if ($long_options) {
            sort($long_options);
        }

        /*
         * Preserve backwards compatibility with callers that relied on
         * erroneous POSIX fix.
         */
        if ($version < 2) {
            if (isset($args[0]{0}) && $args[0]{0} != '-') {
                array_shift($args);
            }
        }

        reset($args);
        while (list($i, $arg) = each($args)) {

            /* The special element '--' means explicit end of
               options. Treat the rest of the arguments as non-options
               and end the loop. */
            if ($arg == '--') {
                $non_opts = array_merge($non_opts, array_slice($args, $i + 1));
                break;
            }

            if ($arg{0} != '-' || (strlen($arg) > 1 && $arg{1} == '-' && !$long_options)) {
                $non_opts = array_merge($non_opts, array_slice($args, $i));
                break;
            } elseif (strlen($arg) > 1 && $arg{1} == '-') {
                self::_parseLongOption(substr($arg, 2), $long_options, $opts, $args);
            } else {
                self::_parseShortOption(substr($arg, 1), $short_options, $opts, $args);
            }
        }

        return array($opts, $non_opts);
    }

    private static function _parseShortOption($arg, $short_options, &$opts, &$args)
    {
        for ($i = 0; $i < strlen($arg); $i++) {
            $opt = $arg{$i};
            $opt_arg = null;

            /* Try to find the short option in the specifier string. */
            if (($spec = strstr($short_options, $opt)) === false || $arg{$i} == ':')
            {
                throw new Exception("self: unrecognized option -- $opt");
            }

            if (strlen($spec) > 1 && $spec{1} == ':') {
                if (strlen($spec) > 2 && $spec{2} == ':') {
                    if ($i + 1 < strlen($arg)) {
                        /* Option takes an optional argument. Use the remainder of
                           the arg string if there is anything left. */
                        $opts[] = array($opt, substr($arg, $i + 1));
                        break;
                    }
                } else {
                    /* Option requires an argument. Use the remainder of the arg
                       string if there is anything left. */
                    if ($i + 1 < strlen($arg)) {
                        $opts[] = array($opt,  substr($arg, $i + 1));
                        break;
                    } else if (list(, $opt_arg) = each($args))
                        /* Else use the next argument. */;
                    else
                        throw new Exception("Console_Getopt: option requires an argument -- $opt");
                }
            }

            $opts[] = array($opt, $opt_arg);
        }
    }

    private static function _parseLongOption($arg, $long_options, &$opts, &$args)
    {
        @list($opt, $opt_arg) = explode('=', $arg);
        $opt_len = strlen($opt);

        for ($i = 0; $i < count($long_options); $i++) {
            $long_opt  = $long_options[$i];
            $opt_start = substr($long_opt, 0, $opt_len);

            /* Option doesn't match. Go on to the next one. */
            if ($opt_start != $opt)
                continue;

            $opt_rest  = substr($long_opt, $opt_len);

            /* Check that the options uniquely matches one of the allowed
               options. */
            if ($opt_rest != '' && $opt{0} != '=' &&
                $i + 1 < count($long_options) &&
                $opt == substr($long_options[$i+1], 0, $opt_len)) {
                throw new Exception("Console_Getopt: option --$opt is ambiguous");
            }

            if (substr($long_opt, -1) == '=') {
                if (substr($long_opt, -2) != '==') {
                    /* Long option requires an argument.
                       Take the next argument if one wasn't specified. */;
                    if (!strlen($opt_arg) && !(list(, $opt_arg) = each($args))) {
                        throw new Exception("Console_Getopt: option --$opt requires an argument");
                    }
                }
            } else if ($opt_arg) {
                throw new Exception("Console_Getopt: option --$opt doesn't allow an argument");
            }

            $opts[] = array('--' . $opt, $opt_arg);
            return;
        }

        throw new Exception("Console_Getopt: unrecognized option --$opt");
    }

    /**
    * Safely read the $argv PHP array across different PHP configurations.
    * Will take care on register_globals and register_argc_argv ini directives
    *
    * @return array the $argv PHP array
	* @throws Exception if not registered
    */
    public static function readPHPArgv()
    {
        global $argv;
        if (!is_array($argv)) {
            if (!@is_array($_SERVER['argv'])) {
                if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) {
                    throw new Exception("Console_Getopt: Could not read cmd args (register_argc_argv=Off?)");
                }
                return $GLOBALS['HTTP_SERVER_VARS']['argv'];
            }
            return $_SERVER['argv'];
        }
        return $argv;
    }

}

?>
<?php
//----------------------------------------------------------------------------
/**
* @package Phool
*/
//----------------------------------------------------------------------------
/**
* @package Phool
*/

class PHO_HTTP
{

//---------

public static function get_arg($name)
{
if (!array_key_exists($name,$_GET))
	throw new Exception("$name: GET argument missing");
return trim($_GET[$name]);
}

//---------
// Compute the base URL we were called with

public static function base_url()
{
if (!PHO_Util::is_web()) return '';

if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF'];

$phpself=$_SERVER['PHP_SELF'];
$slen=strlen($phpself);

$pathinfo=$_SERVER['PATH_INFO'];
$ilen=strlen($pathinfo);

// Remove PATH_INFO from PHP_SELF if it is at the end. Don't know
// which config does this, but some servers put it, some don't.

if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo))
	$phpself=substr($phpself,0,$slen-$ilen);

return $phpself;
}

//---------------------------------
// Sends an HTTP 301 redirection

public static function http_301_redirect($path)
{
header('Location: http://'.$_SERVER['HTTP_HOST'].self::http_base_url().$path);
header('HTTP/1.1 301 Moved Permanently');
exit(0);
}

//---------------------------------
// Sends an HTTP 400 failure

public static function http_400_fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 400 Bad Request".$msg);
exit(1);
}

//---------------------------------
// Sends an HTTP 403 failure

public static function http_403_fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 403 Forbidden".$msg);
exit(1);
}

//---------------------------------
// Sends an HTTP 404 failure

public static function http_404_fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 404 Not Found".$msg);
exit(1);
}

//---------------------------------
// Sends a mime header

public static function mime_header($type)
{
header("Content-type: $type");
}

//----------
} // End of class
//=============================================================================
?>
<?php

class PHO_IP
{

public function network($ip,$mask)
{
self::validate($ip);
self::validate($mask);

$a_ip=self::string_to_array($ip);
$a_mask=self::string_to_array($mask);

$a_res=array();
for ($i=0;$i<4;$i++) $a_res[]=intval($a_ip[$i]) & intval($a_mask[$i]);

return self::array_to_string($a_res);
}

//-----------

public function validate($string)
{
$a=self::string_to_array($string);
for ($i=0;$i<4;$i++)
	{
	$val=$a[$i];
	if ((!is_numeric($val))||($val < 0) || ($val > 255))
		throw new Exception("$val/$string: Invalid IP address");
	}
return $string;
}

//-----------

public function string_to_array($string)
{
$res=explode('.',$string);
if (count($res)!==4) throw new Exception("$string: Invalid IP address");
return $res;
}

//-----------

public function array_to_string($a)
{
return implode('.',$a);
}

//-----------
}
?><?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/**
* This file is adapted from the PEAR Services_JSON package version 1.0.3,
* available at http://pear.php.net/package/Services_JSON.
*
* Changes from PEAR version:
*		- switch to PHP 5 object syntax
*		- make independant from PEAR error handling using exceptions . Also
*		  remove SERVICES_JSON_SUPPRESS_ERRORS flag (replace with a try/catch
*		  construct)

/**
 * Converts to and from JSON format.
 *
 * JSON (JavaScript Object Notation) is a lightweight data-interchange
 * format. It is easy for humans to read and write. It is easy for machines
 * to parse and generate. It is based on a subset of the JavaScript
 * Programming Language, Standard ECMA-262 3rd Edition - December 1999.
 * This feature can also be found in  Python. JSON is a text format that is
 * completely language independent but uses conventions that are familiar
 * to programmers of the C-family of languages, including C, C++, C#, Java,
 * JavaScript, Perl, TCL, and many others. These properties make JSON an
 * ideal data-interchange language.
 *
 * This package provides a simple encoder and decoder for JSON notation. It
 * is intended for use with client-side Javascript applications that make
 * use of HTTPRequest to perform server communication functions - data can
 * be encoded into JSON notation for use in a client-side javascript, or
 * decoded from incoming Javascript requests. JSON format is native to
 * Javascript, and can be directly eval()'ed with no further parsing
 * overhead
 *
 * All strings should be in ASCII or UTF-8 format!
 *
 * LICENSE: Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met: Redistributions of source code must retain the
 * above copyright notice, this list of conditions and the following
 * disclaimer. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * @category
 * @package     Services_JSON
 * @author      Michal Migurski <mike-json@teczno.com>
 * @author      Matt Knapp <mdknapp[at]gmail[dot]com>
 * @author      Brett Stimmerman <brettstimmerman[at]gmail[dot]com>
 * @author      Francois Laupretre <francois@tekwire.net>
 * @copyright   2005 Michal Migurski
 * @version     CVS: $Id: JSON.php,v 1.31 2006/06/28 05:54:17 migurski Exp $
 * @license     http://www.opensource.org/licenses/bsd-license.php
 * @link        http://pear.php.net/pepr/pepr-proposal-show.php?id=198
 */

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
define('SERVICES_JSON_SLICE',   1);

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
define('SERVICES_JSON_IN_STR',  2);

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
define('SERVICES_JSON_IN_ARR',  3);

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
define('SERVICES_JSON_IN_OBJ',  4);

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
define('SERVICES_JSON_IN_CMT', 5);

/**
 * Behavior switch for Services_JSON::decode()
 */
define('SERVICES_JSON_LOOSE_TYPE', 16);

/**
 * Converts to and from JSON format.
 *
 * Brief example of use:
 *
 * <code>
 * // create a new instance of Services_JSON
 * $json = new Services_JSON();
 *
 * // convert a complexe value to JSON notation, and send it to the browser
 * $value = array('foo', 'bar', array(1, 2, 'baz'), array(3, array(4)));
 * $output = $json->encode($value);
 *
 * print($output);
 * // prints: ["foo","bar",[1,2,"baz"],[3,[4]]]
 *
 * // accept incoming POST data, assumed to be in JSON notation
 * $input = file_get_contents('php://input', 1000000);
 * $value = $json->decode($input);
 * </code>
 */
class Services_JSON
{
   /**
    * constructs a new JSON instance
    */

	/** @var int object behavior flags; combine with boolean-OR */

	private $use;

	/**
    * @param    int     $use    object behavior flags; combine with boolean-OR
    *
    *                           possible values:
    *                           - SERVICES_JSON_LOOSE_TYPE:  loose typing.
    *                                   "{...}" syntax creates associative arrays
    *                                   instead of objects in decode().
    */
    public function __construct($use = 0)
    {
        $this->use = $use;
    }

   /**
    * convert a string from one UTF-16 char to one UTF-8 char
    *
    * Normally should be handled by mb_convert_encoding, but
    * provides a slower PHP-only method for installations
    * that lack the multibye string extension.
    *
    * @param    string  $utf16  UTF-16 character
    * @return   string  UTF-8 character
    */
    private function utf162utf8($utf16)
    {
        // oh please oh please oh please oh please oh please
        if(function_exists('mb_convert_encoding')) {
            return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16');
        }

        $bytes = (ord($utf16{0}) << 8) | ord($utf16{1});

        switch(true) {
            case ((0x7F & $bytes) == $bytes):
                // this case should never be reached, because we are in ASCII range
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0x7F & $bytes);

            case (0x07FF & $bytes) == $bytes:
                // return a 2-byte UTF-8 character
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0xC0 | (($bytes >> 6) & 0x1F))
                     . chr(0x80 | ($bytes & 0x3F));

            case (0xFFFF & $bytes) == $bytes:
                // return a 3-byte UTF-8 character
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0xE0 | (($bytes >> 12) & 0x0F))
                     . chr(0x80 | (($bytes >> 6) & 0x3F))
                     . chr(0x80 | ($bytes & 0x3F));
        }

        // ignoring UTF-32 for now, sorry
        return '';
    }

   /**
    * convert a string from one UTF-8 char to one UTF-16 char
    *
    * Normally should be handled by mb_convert_encoding, but
    * provides a slower PHP-only method for installations
    * that lack the multibye string extension.
    *
    * @param    string  $utf8   UTF-8 character
    * @return   string  UTF-16 character
    */
    private function utf82utf16($utf8)
    {
        // oh please oh please oh please oh please oh please
        if(function_exists('mb_convert_encoding')) {
            return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8');
        }

        switch(strlen($utf8)) {
            case 1:
                // this case should never be reached, because we are in ASCII range
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return $utf8;

            case 2:
                // return a UTF-16 character from a 2-byte UTF-8 char
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0x07 & (ord($utf8{0}) >> 2))
                     . chr((0xC0 & (ord($utf8{0}) << 6))
                         | (0x3F & ord($utf8{1})));

            case 3:
                // return a UTF-16 character from a 3-byte UTF-8 char
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr((0xF0 & (ord($utf8{0}) << 4))
                         | (0x0F & (ord($utf8{1}) >> 2)))
                     . chr((0xC0 & (ord($utf8{1}) << 6))
                         | (0x7F & ord($utf8{2})));
        }

        // ignoring UTF-32 for now, sorry
        return '';
    }

   /**
    * encodes an arbitrary variable into JSON format
    *
    * @param    mixed   $var    any number, boolean, string, array, or object to be encoded.
    *                           see argument 1 to Services_JSON() above for array-parsing behavior.
    *                           if var is a strng, note that encode() always expects it
    *                           to be in ASCII or UTF-8 format!
    *
    * @return   mixed   JSON string representation of input var
    * @throws Exception if a problem occurs
    */
    public function encode($var)
    {
        switch (gettype($var)) {
            case 'boolean':
                return $var ? 'true' : 'false';

            case 'NULL':
                return 'null';

            case 'integer':
                return (int) $var;

            case 'double':
            case 'float':
                return (float) $var;

            case 'string':
                // STRINGS ARE EXPECTED TO BE IN ASCII OR UTF-8 FORMAT
                $ascii = '';
                $strlen_var = strlen($var);

               /*
                * Iterate over every character in the string,
                * escaping with a slash or encoding to UTF-8 where necessary
                */
                for ($c = 0; $c < $strlen_var; ++$c) {

                    $ord_var_c = ord($var{$c});

                    switch (true) {
                        case $ord_var_c == 0x08:
                            $ascii .= '\b';
                            break;
                        case $ord_var_c == 0x09:
                            $ascii .= '\t';
                            break;
                        case $ord_var_c == 0x0A:
                            $ascii .= '\n';
                            break;
                        case $ord_var_c == 0x0C:
                            $ascii .= '\f';
                            break;
                        case $ord_var_c == 0x0D:
                            $ascii .= '\r';
                            break;

                        case $ord_var_c == 0x22:
                        case $ord_var_c == 0x2F:
                        case $ord_var_c == 0x5C:
                            // double quote, slash, slosh
                            $ascii .= '\\'.$var{$c};
                            break;

                        case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):
                            // characters U-00000000 - U-0000007F (same as ASCII)
                            $ascii .= $var{$c};
                            break;

                        case (($ord_var_c & 0xE0) == 0xC0):
                            // characters U-00000080 - U-000007FF, mask 110XXXXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c, ord($var{$c + 1}));
                            $c += 1;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xF0) == 0xE0):
                            // characters U-00000800 - U-0000FFFF, mask 1110XXXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}));
                            $c += 2;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xF8) == 0xF0):
                            // characters U-00010000 - U-001FFFFF, mask 11110XXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}));
                            $c += 3;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xFC) == 0xF8):
                            // characters U-00200000 - U-03FFFFFF, mask 111110XX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}),
                                         ord($var{$c + 4}));
                            $c += 4;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xFE) == 0xFC):
                            // characters U-04000000 - U-7FFFFFFF, mask 1111110X
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}),
                                         ord($var{$c + 4}),
                                         ord($var{$c + 5}));
                            $c += 5;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;
                    }
                }

                return '"'.$ascii.'"';

            case 'array':
               /*
                * As per JSON spec if any array key is not an integer
                * we must treat the the whole array as an object. We
                * also try to catch a sparsely populated associative
                * array with numeric keys here because some JS engines
                * will create an array with empty indexes up to
                * max_index which can cause memory issues and because
                * the keys, which may be relevant, will be remapped
                * otherwise.
                *
                * As per the ECMA and JSON specification an object may
                * have any string as a property. Unfortunately due to
                * a hole in the ECMA specification if the key is a
                * ECMA reserved word or starts with a digit the
                * parameter is only accessible using ECMAScript's
                * bracket notation.
                */

                // treat as a JSON object
                if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {
                    $properties = array_map(array($this, 'name_value'),
                                            array_keys($var),
                                            array_values($var));
                    return '{' . join(',', $properties) . '}';
                }

                // treat it like a regular array
                $elements = array_map(array($this, 'encode'), $var);
                return '[' . join(',', $elements) . ']';

            case 'object':
                $vars = get_object_vars($var);

                $properties = array_map(array($this, 'name_value'),
                                        array_keys($vars),
                                        array_values($vars));
                return '{' . join(',', $properties) . '}';

            default:
                 throw new Exception(gettype($var)." can not be encoded as JSON string");
        }
    }

   /**
    * array-walking function for use in generating JSON-formatted name-value pairs
    *
    * @param    string  $name   name of key to use
    * @param    mixed   $value  reference to an array element to be encoded
    *
    * @return   string  JSON-formatted name-value pair, like '"name":value'
    */
    private function name_value($name, $value)
    {
        return $this->encode(strval($name)) . ':' . $this->encode($value);
    }

   /**
    * reduce a string by removing leading and trailing comments and whitespace
    *
    * @param    $str    string      string value to strip of comments and whitespace
    *
    * @return   string  string value stripped of comments and whitespace
    */
    private function reduce_string($str)
    {
        $str = preg_replace(array(

                // eliminate single line comments in '// ...' form
                '#^\s*//(.+)$#m',

                // eliminate multi-line comments in '/* ... */' form, at start of string
                '#^\s*/\*(.+)\*/#Us',

                // eliminate multi-line comments in '/* ... */' form, at end of string
                '#/\*(.+)\*/\s*$#Us'

            ), '', $str);

        // eliminate extraneous space
        return trim($str);
    }

   /**
    * decodes a JSON string into appropriate variable
    *
    * @param    string  $str    JSON-formatted string
    *
    * @return   mixed   number, boolean, string, array, or object
    *                   corresponding to given JSON input string.
    *                   See argument 1 to Services_JSON() above for object-output behavior.
    *                   Note that decode() always returns strings
    *                   in ASCII or UTF-8 format!
    */
    public function decode($str)
    {
        $str = $this->reduce_string($str);

        switch (strtolower($str)) {
            case 'true':
                return true;

            case 'false':
                return false;

            case 'null':
                return null;

            default:
                $m = array();

                if (is_numeric($str)) {
                    // Lookie-loo, it's a number

                    // This would work on its own, but I'm trying to be
                    // good about returning integers where appropriate:
                    // return (float)$str;

                    // Return float or int, as appropriate
                    return ((float)$str == (integer)$str)
                        ? (integer)$str
                        : (float)$str;

                } elseif (preg_match('/^("|\').*(\1)$/s', $str, $m) && $m[1] == $m[2]) {
                    // STRINGS RETURNED IN UTF-8 FORMAT
                    $delim = substr($str, 0, 1);
                    $chrs = substr($str, 1, -1);
                    $utf8 = '';
                    $strlen_chrs = strlen($chrs);

                    for ($c = 0; $c < $strlen_chrs; ++$c) {

                        $substr_chrs_c_2 = substr($chrs, $c, 2);
                        $ord_chrs_c = ord($chrs{$c});

                        switch (true) {
                            case $substr_chrs_c_2 == '\b':
                                $utf8 .= chr(0x08);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\t':
                                $utf8 .= chr(0x09);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\n':
                                $utf8 .= chr(0x0A);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\f':
                                $utf8 .= chr(0x0C);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\r':
                                $utf8 .= chr(0x0D);
                                ++$c;
                                break;

                            case $substr_chrs_c_2 == '\\"':
                            case $substr_chrs_c_2 == '\\\'':
                            case $substr_chrs_c_2 == '\\\\':
                            case $substr_chrs_c_2 == '\\/':
                                if (($delim == '"' && $substr_chrs_c_2 != '\\\'') ||
                                   ($delim == "'" && $substr_chrs_c_2 != '\\"')) {
                                    $utf8 .= $chrs{++$c};
                                }
                                break;

                            case preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6)):
                                // single, escaped unicode character
                                $utf16 = chr(hexdec(substr($chrs, ($c + 2), 2)))
                                       . chr(hexdec(substr($chrs, ($c + 4), 2)));
                                $utf8 .= $this->utf162utf8($utf16);
                                $c += 5;
                                break;

                            case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F):
                                $utf8 .= $chrs{$c};
                                break;

                            case ($ord_chrs_c & 0xE0) == 0xC0:
                                // characters U-00000080 - U-000007FF, mask 110XXXXX
                                //see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 2);
                                ++$c;
                                break;

                            case ($ord_chrs_c & 0xF0) == 0xE0:
                                // characters U-00000800 - U-0000FFFF, mask 1110XXXX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 3);
                                $c += 2;
                                break;

                            case ($ord_chrs_c & 0xF8) == 0xF0:
                                // characters U-00010000 - U-001FFFFF, mask 11110XXX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 4);
                                $c += 3;
                                break;

                            case ($ord_chrs_c & 0xFC) == 0xF8:
                                // characters U-00200000 - U-03FFFFFF, mask 111110XX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 5);
                                $c += 4;
                                break;

                            case ($ord_chrs_c & 0xFE) == 0xFC:
                                // characters U-04000000 - U-7FFFFFFF, mask 1111110X
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 6);
                                $c += 5;
                                break;

                        }

                    }

                    return $utf8;

                } elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) {
                    // array, or object notation

                    if ($str{0} == '[') {
                        $stk = array(SERVICES_JSON_IN_ARR);
                        $arr = array();
                    } else {
                        if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                            $stk = array(SERVICES_JSON_IN_OBJ);
                            $obj = array();
                        } else {
                            $stk = array(SERVICES_JSON_IN_OBJ);
                            $obj = new stdClass();
                        }
                    }

                    array_push($stk, array('what'  => SERVICES_JSON_SLICE,
                                           'where' => 0,
                                           'delim' => false));

                    $chrs = substr($str, 1, -1);
                    $chrs = $this->reduce_string($chrs);

                    if ($chrs == '') {
                        if (reset($stk) == SERVICES_JSON_IN_ARR) {
                            return $arr;

                        } else {
                            return $obj;

                        }
                    }

                    //print("\nparsing {$chrs}\n");

                    $strlen_chrs = strlen($chrs);

                    for ($c = 0; $c <= $strlen_chrs; ++$c) {

                        $top = end($stk);
                        $substr_chrs_c_2 = substr($chrs, $c, 2);

                        if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) {
                            // found a comma that is not inside a string, array, etc.,
                            // OR we've reached the end of the character list
                            $slice = substr($chrs, $top['where'], ($c - $top['where']));
                            array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false));
                            //print("Found split at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                            if (reset($stk) == SERVICES_JSON_IN_ARR) {
                                // we are in an array, so just push an element onto the stack
                                array_push($arr, $this->decode($slice));

                            } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {
                                // we are in an object, so figure
                                // out the property name and set an
                                // element in an associative array,
                                // for now
                                $parts = array();
                                
                                if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {
                                    // "name":value pair
                                    $key = $this->decode($parts[1]);
                                    $val = $this->decode($parts[2]);

                                    if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                                        $obj[$key] = $val;
                                    } else {
                                        $obj->$key = $val;
                                    }
                                } elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {
                                    // name:value pair, where name is unquoted
                                    $key = $parts[1];
                                    $val = $this->decode($parts[2]);

                                    if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                                        $obj[$key] = $val;
                                    } else {
                                        $obj->$key = $val;
                                    }
                                }

                            }

                        } elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) && ($top['what'] != SERVICES_JSON_IN_STR)) {
                            // found a quote, and we are not inside a string
                            array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c}));
                            //print("Found start of string at {$c}\n");

                        } elseif (($chrs{$c} == $top['delim']) &&
                                 ($top['what'] == SERVICES_JSON_IN_STR) &&
                                 ((strlen(substr($chrs, 0, $c)) - strlen(rtrim(substr($chrs, 0, $c), '\\'))) % 2 != 1)) {
                            // found a quote, we're in a string, and it's not escaped
                            // we know that it's not escaped becase there is _not_ an
                            // odd number of backslashes at the end of the string so far
                            array_pop($stk);
                            //print("Found end of string at {$c}: ".substr($chrs, $top['where'], (1 + 1 + $c - $top['where']))."\n");

                        } elseif (($chrs{$c} == '[') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a left-bracket, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false));
                            //print("Found start of array at {$c}\n");

                        } elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) {
                            // found a right-bracket, and we're in an array
                            array_pop($stk);
                            //print("Found end of array at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        } elseif (($chrs{$c} == '{') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a left-brace, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false));
                            //print("Found start of object at {$c}\n");

                        } elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) {
                            // found a right-brace, and we're in an object
                            array_pop($stk);
                            //print("Found end of object at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        } elseif (($substr_chrs_c_2 == '/*') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a comment start, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false));
                            $c++;
                            //print("Found start of comment at {$c}\n");

                        } elseif (($substr_chrs_c_2 == '*/') && ($top['what'] == SERVICES_JSON_IN_CMT)) {
                            // found a comment end, and we're in one now
                            array_pop($stk);
                            $c++;

                            for ($i = $top['where']; $i <= $c; ++$i)
                                $chrs = substr_replace($chrs, ' ', $i, 1);

                            //print("Found end of comment at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        }

                    }

                    if (reset($stk) == SERVICES_JSON_IN_ARR) {
                        return $arr;

                    } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {
                        return $obj;

                    }

                }
        }
    }
}    
?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @author Francois Laupretre <francois@tekwire.net>
* @license http://www.gnu.org/licenses GNU Lesser General Public License, V 3.0
*/
//============================================================================

//============================================================================
/**
* This abstract class allows to know whether an object has been modified or not
* since it was created or read from persistent storage
*
* Each time a property is modified, the descendant class must call the
* {@link set_modified()} method.
*
* When it is saved, {@link clear_modified()} must be called
* 
* The current state can be retrieved via the {@link modified()} method.
*
* When the instance is created, the state is set to 'not-modified'
*/

abstract class PHO_Modifiable
{
/** @var boolean True if the object was modified since creation/load/save */

private $modified_flag=false;

//----------------------------------------------------------------------------
/**
* Class constructor
*
* Ensures that the instance is in 'non-modified' state at creation time
*
* @return void
*/

protected function __construct()
{
$this->clear_modified();
}

//----------------------------------------------------------------------------
/**
* Set the 'modified' state depending on an input toggle
*
* The input toggle allows to pass a boolean return code as argument
*
* @param boolean $toggle If true, set the state, if false, do nothing
* @return void
*/

protected function set_modified($toggle=true)
{
if ($toggle) $this->modified_flag=true;
}

//----------------------------------------------------------------------------
/**
* Set the 'not-modified' state
* Should be called only when the instance is transferred to persistent storage
* @return void
*/

protected function clear_modified()
{
$this->modified_flag=false;
}

//----------------------------------------------------------------------------
/**
* Returns the modified state
*
* @return boolean the current state
*/

public function modified()
{
return $this->modified_flag;
}

//----------------------------------------------------------------------------
} // End of class PHO_Modifiable
?><?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @author Francois Laupretre <francois@tekwire.net>
* @license http://www.gnu.org/licenses GNU Lesser General Public License, V 3.0
*/
//============================================================================

//============================================================================
/**
* This abstract class implements an object which can be saved and retrieved
* to/from a file on  disk.
*
* It exposes the {@link load()} and {@link save()} methods.
*
* It also provides a checksum mechanism transparent to the descendant
* class. Everytime an object is read from storage, its checksum is computed
*  and compared to the value that was stored at save() time.
*
* The descendant class must define two methods named serialize and
* unserialize to transmit/retrieve the data to save.
*
* Note: Late static binding would allow to access the descendant class
* properties and get the magic string from the toplevel class at runtime.
* Unfortunately, it is implemented in versions of PHP >= 5.3, which is too
* restrictive. So, we use another way.
*/

//----------------------------------------------------------------------------

abstract class PHO_Persistent extends PHO_Modifiable
{
// @var string The magic string to write and check

private $magic;

// @var string The last loaded path. Allows to call save() without argument.

private $path=null;

//----------------------------------------------------------------------------
/**
* Return the properties to save as a string
*
* @return string
*/

abstract protected function serialize();

//----------------------------------------------------------------------------
/**
* Restore data from the result of a previous {@link __serialize()} execution
*
* @param mixed $data The data returned by a previous {@link __serialize()}
* execution
*
* @return void
*/

abstract protected function unserialize($data);

//----------------------------------------------------------------------------
/**
* Class constructor
*
* @param string $magic The magic string to use when writing/reading a file
* @param string|null $path A file to load if not null
* @return void
*/

protected function __construct($magic,$path=null)
{
$this->magic=$magic;
parent::__construct();
if (!is_null($path)) $this->load($path);
}

//----------------------------------------------------------------------------
/**
* Records a path
*
* @param string $path
* @return void
*/

public function set_path($path)
{
$this->path=$path;
}

//----------------------------------------------------------------------------
/**
* Restore data from a save()d file
*
* @param string $path Path of the file to load
* @return void
* @throws Exception if file cannot be loaded
*/

public function load($path)
{
if (!file_exists($path)) throw new Exception("$path: File does not exist");

try
	{
	$buf=file_get_contents($path);
	if ($buf===false) throw new Exception("$path: Cannot get file contents");
	//-- Check magic
	if (substr($buf,0,strlen($this->magic))!==$this->magic)
		throw new Exception("Bad magic string");
	//-- Skip magic string
	$buf=substr($buf,strlen($this->magic));
	//-- Unserialize toplevel array
	$a=unserialize($buf);
	if ((!is_array($a))
		||(!array_key_exists('crc',$a))
		||(!array_key_exists('data',$a)))
		throw new Exception('Invalid format');

	$data=$a['data'];
	if (crc32($data) !== $a['crc'])
		throw new Exception('Wrong checksum');

	$this->unserialize($data);
	}
catch (Exception $e)
	{
	throw new Exception("$path: Cannot load file: ".$e->getMessage());
	}

$this->set_path($path);
}

//----------------------------------------------------------------------------
/**
* Save data to a file on disk
*
* @param string|null $path Path to save or null if same as load()
* @return void
* @throws Exception if write failed or path cannot be determined
*/

public function save($path=null)
{
if (is_null($path))
	{
	if (is_null($this->path))
		throw new Exception('Save path cannot be determined');
	$path=$this->path;
	}

$value=$this->serialize(); // Call toplevel method
$data=serialize(array(
	'crc' => crc32($value),
	'data' => $value
	));

if (file_put_contents($path,$this->magic.$data)===false)
	throw new Exception("$path: Cannot write file");

//-- Write is OK. Now we can clear the 'modified' flag

parent::clear_modified();
}

//----------------------------------------------------------------------------
/**
* Save object to a file if it was modified since last load() or save()
*
* @param string|null $path Path to save or null if same as load()
* @return void
* @throws Exception if write failed
*/

public function save_if_modified($path=null)
{
if ($this->modified()) $this->save($path);
}

} // End of class PHO_Persistent
?><?php
//----------------------------------------------------------------------------
/**
* @package Phool
*/
//----------------------------------------------------------------------------
/**
* @package Phool
*/

class PHO_Time
{

//---------
// Converts a timestamp to a string
// @ to suppress warnings about system timezone

public static function timestring($time=null)
{
if ($time=='unlimited') return $time;
if (is_null($time)) $time=time();
return @strftime('%d-%b-%Y %H:%M %z',$time);
}

//---------

public function compound_string($t='now',$tz)
{
$d=new DateTime($t,new DateTimeZone($tz));
return $d->format('d-M-Y H:i:s (U)');
}

//---------
// $start=microtime() float

public static function delta_ms($start)
{
$delta=microtime(true)-$start;

return round($delta*1000,2).' ms';
}

//----------
} // End of class
//=============================================================================
?>
<?php
//----------------------------------------------------------------------------
/**
* @package Phool
*/
//----------------------------------------------------------------------------
/**
* @package Phool
*/

class PHO_Util
{

//---------

public static function env_is_web()
{
return (php_sapi_name()!='cli');
}

//----

public static function env_is_windows()
{
return (substr(PHP_OS, 0, 3) == 'WIN');
}

//---------
// Adapted from PEAR

public static function load_extension($ext)
{
if (extension_loaded($ext)) return;

if (PHP_OS == 'AIX') $suffix = 'a';
else $suffix = PHP_SHLIB_SUFFIX;

@dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix);

if (!extension_loaded($ext)) throw new Exception("$ext: Cannot load extension");
}

//---------
// Require several extensions. Allows to list every extensions that are not
// present.

public static function load_extensions($ext_list)
{
$failed_ext=array();
foreach($ext_list as $ext)
	{
	try { self::load_extension($ext); }
	catch (Exception $e) { $failed_ext[]=$ext; }
	}
if (count($failed_ext))
	throw new Exception('Cannot load the following required extension(s): '
		.implode(' ',$failed_ext));
}

//---------
// Replacement for substr()
// Difference : returns '' instead of false (when index out of range)

public static function substr($buf,$position,$len=NULL)
{
$str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len);
if ($str===false) $str='';
return $str;
}

//---------
// This function must be called before every file access
// In PHP 6, magic_quotes_runtime is suppressed and set_magic_quotes_runtime()
// does not exist any more.

private static $mqr_exists=null;
private static $mqr_level=0;
private static $mqr_save;

public static function disable_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

if (self::$mqr_level==0)
	{
	self::$mqr_save=get_magic_quotes_runtime();
	set_magic_quotes_runtime(0);
	}
self::$mqr_level++;
}

//---------
// This function must be called after every file access

public static function restore_mqr()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

self::$mqr_level--;
if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save);
}

//---------

public static function mk_array($data)
{
if (is_null($data)) return array();
if (!is_array($data)) $data=array($data);
return $data;
}

//---------------------------------

public static function call_method($object,$method,$args)
{
return call_user_func_array(array($object,$method),$args);
}

//----------
} // End of class
//=============================================================================
?>
<?php

abstract class PHO_VarContainer
{

protected $vars=array();

//------------------

public static function bool_val($val)
{
return ($val ? 'Y' : '');
}

//------------------

public function val_is_set($vname)
{
return array_key_exists($vname,$this->vars);
}

//------------------

public function val_is_true($vname)
{
return ($this->val_is_set($vname) ? ($this->val($vname) != '') : false);
}

//------------------

public function __get($vname)
{
return $this->val($vname);
}

//------------------
// Difference with __get() method. This one allows to retrieve any variable name, even containing characters forbidden
// in variable names (like '/').

public function val($vname)
{
if (!$this->val_is_set($vname)) throw new Exception("$vname: Variable not set");
return $this->vars[$vname];
}

//------------------

public function val_array()
{
return $this->vars;
}

//------------------

public function setval($name,$value)
{
$this->vars[$name]=trim($value);
}

//------------------
}
?><?php
//----------------------------------------------------------------------------
/**
* This class allows to browse an XML or XHTML document
*
* @package XPage
*/
//----------------------------------------------------------------------------

//error_reporting(E_ERROR | E_CORE_ERROR | E_USER_ERROR);

//----------------------------------------------------------------------------
/**
* @package XPage
*/

class PHO_XPage
{

/** @var string Buffer containing the document

public $page;

/** @var DOMDocument The document as a DOMDocument instance */

public $xdoc=null;

#--------
/** Creates the DOM instance and imports the data
*
* @param string $data The content of the page/document
* @param boolean $html Is the format html (or xml) ?
* @returns void
* @throws DOMException
*/

public function __construct($data,$html=true)
{
$this->page=$data;
$this->xdoc=new DOMDocument;

$method=($html ? 'loadHTML' : 'loadXML');
if (!@$this->xdoc->$method($data))
	throw new DOMException('Cannot load data');
}

#--------
/**
* Returns a list of nodes corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNodeList (can be empty)
*/

public function nodes($xpath,$base=null)
{
$xp=new DOMXPath($this->xdoc);
if (is_null($base)) $base=$this->xdoc->documentElement;
$n=$xp->query($xpath,$base);
unset($xp);
return $n;
}

//------------
/**
* Returns the first node corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNode|null null if no match
*/

public function node($xpath,$base=null)
{
$node_list=$this->nodes($xpath,$base);
return ($node_list->length ? $node_list->item(0) : null);
}

//------------
/**
* Returns the last node corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNode|null null if no match
*/

public function last_node($xpath,$base=null)
{
$node_list=$this->nodes($xpath,$base);
return ($node_list->length ? $node_list->item($node_list->length-1) : null);
}

#--------
/**
* Returns the values of the nodes corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns array empty if no match
*/

public function values($xpath,$base=null)
{
$a=array();
$res=$this->nodes($xpath,$base);
if (!$res->length) return $a;
foreach($res as $node) $a[]=$node->nodeValue;
return $a;
}

#--------
/**
* Returns the value of the first node corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns string|null null if no match
*/

public function value($xpath,$base=null)
{
$node=$this->node($xpath,$base);

return (($node===null) ? null : $node->nodeValue);
}

#--------
/**
* Returns the number of nodes corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns int
*/

public function nb($xpath,$base=null)
{
return $this->nodes($xpath,$base)->length;
}

#--------
/**
* Returns the text and target of an hyperlink node as an
* array('text' => <text>, 'url' => <target>)
*
* @param DOMNode $node Node of type 'a'
*
* @returns array(text,url)
*
* @throws Exception
*/

public static function a_info($node)
{
if ((! $node instanceof DOMElement))
	throw new Exception('Arg should be a DOMElement');

if ($node->tagName != 'a')
	throw new Exception('Node should be an anchor ('.$node->tagName.')');

return array('text' => $node->textContent
	,'url' => $node->attributes->getNamedItem('href')->nodeValue);
}

#--------

public function recursive_back_nodes($start_node,$item)
{
$a=array();
$node=$start_node;

while (true)
	{
	$nodes=$this->nodes($item,$node);
	if ($nodes->length)
		{
		for ($i=0;$i<$nodes->length;$i++) $a[]=$nodes->item($i);
		}
	if ($node->isSameNode($this->xdoc)) break; // if root node
	$node=$node->parentNode;
	}
return $a;
}

#--------

public function recursive_back_node($start_node,$item)
{
$nodes=$this->recursive_back_nodes($start_node,$item);
return ((count($nodes)==0) ? null : $nodes[0]);
}

#--------

public function recursive_back_values($start_node,$item)
{
$a=array();
foreach ($this->recursive_back_nodes($start_node,$item) as $node)
	$a[]=$node->nodeValue;
return $a;
}

#--------

public function recursive_back_value($start_node,$item)
{
$node=$this->recursive_back_node($start_node,$item);
return (is_null($node) ? null : $node->nodeValue);
}

//----------
} // End of class XPage
//=============================================================================
?>
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.
