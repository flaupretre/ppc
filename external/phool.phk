<?php                                                         ?><?php #PHK M M2.0.0        V3.0.0        FS226268      PO241         SSO92080       STO92697       FTO118158      SIO226268      CRCcabeab08 PCO952         PCS91128       ?><?php
 if (!class_exists('PHK',0)) { $_phk_fp=fopen(__FILE__,'rb'); $_phk_buf=fread($_phk_fp,241); fseek($_phk_fp,(int)(substr($_phk_buf,212,11)),SEEK_SET); $_phk_size=(int)(substr($_phk_buf,227,11)); $_phk_code=''; while (strlen($_phk_code) < $_phk_size) $_phk_code .=fread($_phk_fp,$_phk_size-strlen($_phk_code)); fclose($_phk_fp); eval($_phk_code); unset($_phk_code); unset($_phk_fp); unset($_phk_buf); unset($_phk_size); } $_phk_cmd=null; $_phk_ret=0; try { PHK::prolog(__FILE__,$_phk_cmd,$_phk_ret); } catch (Exception $e) { if (getenv('SHOW_EXCEPTION')!==false) throw $e; trigger_error($e->getMessage(),E_USER_ERROR); } if (!is_null($_phk_cmd)) eval($_phk_cmd); return $_phk_ret; __halt_compiler(); ?>ÿÿÿÿ
 namespace Automap { if (!class_exists('Automap\Mgr',false)) { class Mgr { const T_FUNCTION='F'; const T_CONSTANT='C'; const T_CLASS='L'; const T_EXTENSION='E'; const F_SCRIPT='S'; const F_EXTENSION='X'; const F_PACKAGE='P'; const NO_AUTOLOAD=1; const CRC_CHECK=2; const PECL_LOAD=4; private static $type_strings=array( self::T_FUNCTION => 'function', self::T_CONSTANT => 'constant', self::T_CLASS => 'class', self::T_EXTENSION => 'extension', self::F_SCRIPT => 'script', self::F_EXTENSION => 'extension file', self::F_PACKAGE => 'package' ); private static $failureHandlers=array(); private static $successHandlers=array(); private static $supportConstantAutoload; private static $supportFunctionAutoload; private static $maps=array(); private static $load_index=1; public static function init() { $f=new \ReflectionFunction('function_exists'); self::$supportFunctionAutoload=($f->getNumberOfParameters()==2); $f=new \ReflectionFunction('defined'); self::$supportConstantAutoload=($f->getNumberOfParameters()==2); } public static function registerFailureHandler($callable) { self::$failureHandlers[]=$callable; } private static function callFailureHandlers($type,$name) { foreach (self::$failureHandlers as $callable) $callable($type,$name); } public static function registerSuccessHandler($callable) { self::$successHandlers[]=$callable; } private static function callSuccessHandlers($entry,$id) { foreach (self::$successHandlers as $callable) $callable($entry,$id); } public static function key($type,$name) { return $type.trim($name,'\\'); } public static function typeToString($type) { if (!isset(self::$type_strings[$type])) throw new \Exception("$type: Invalid type"); return self::$type_strings[$type]; } public static function stringToType($string) { $type=array_search($string,self::$type_strings,true); if ($type===false) throw new \Exception("$type: Invalid type"); return $type; } public static function isActiveID($id) { return isset(self::$maps[$id]); } private static function validate($id) { if (!self::isActiveID($id)) throw new \Exception($id.': Invalid map ID'); return $id; } public static function map($id) { self::validate($id); return self::$maps[$id]; } public static function activeIDs() { return array_keys(self::$maps); } public static function load($path,$flags=0,$_bp=null) { $map=new \Automap\Map($path,$flags,$_bp); $id=self::$load_index++; self::$maps[$id]=$map; return $id; } public static function unload($id) { self::validate($id); unset(self::$maps[$id]); } public static function usingAccelerator() { return false; } private static function symbolIsDefined($type,$name) { switch($type) { case self::T_CONSTANT: return (self::$supportConstantAutoload ? defined($name,false) : defined($name)); case self::T_FUNCTION: return (self::$supportFunctionAutoload ? function_exists($name,false) : function_exists($name)); case self::T_CLASS: return class_exists($name,false) || interface_exists($name,false) || (function_exists('trait_exists') && trait_exists($name,false)); case self::T_EXTENSION: return extension_loaded($name); } } public static function autoloadHook($name,$type=self::T_CLASS) { self::resolve($type,$name,true,false); } private static function resolve($type,$name,$autoloading=false ,$exception=false) { if ((!$autoloading)&&(self::symbolIsDefined($type,$name))) return true; foreach(array_reverse(self::$maps,true) as $id => $map) { if (($entry=$map->resolve($type,$name,$id))===false) continue; self::callSuccessHandlers($entry,$id); return true; } self::callFailureHandlers($type,$name); if ($exception) throw new \Exception('Automap: Unknown ' .self::typeToString($type).': '.$name); return false; } public static function getFunction($name) { return self::resolve(self::T_FUNCTION,$name,false,false); } public static function getConstant($name) { return self::resolve(self::T_CONSTANT,$name,false,false); } public static function getClass($name) { return self::resolve(self::T_CLASS,$name,false,false); } public static function getExtension($name) { return self::resolve(self::T_EXTENSION,$name,false,false); } public static function requireFunction($name) { return self::resolve(self::T_FUNCTION,$name,false,true); } public static function requireConstant($name) { return self::resolve(self::T_CONSTANT,$name,false,true); } public static function requireClass($name) { return self::resolve(self::T_CLASS,$name,false,true); } public static function requireExtension($name) { return self::resolve(self::T_EXTENSION,$name,false,true); } } if (!defined('_AUTOMAP_DISABLE_REGISTER')) { if (!extension_loaded('spl')) throw new \Exception("Automap requires the SPL extension"); spl_autoload_register('\Automap\Mgr::autoloadHook'); } Mgr::init(); } } namespace Automap\Tools { if (!class_exists('\Automap\Tools\Display',false)) { class Display { public static function show(\Automap\Map $map,$format=null ,$subfile_to_url_function=null) { if (is_null($format)||($format='auto')) { \PHK::needPhpRuntime(); $format=(\PHK\Tools\Util::envIsWeb() ? 'html' : 'text'); } switch($format) { case 'text': self::showText($map,$subfile_to_url_function); break; case 'html': self::showHtml($map,$subfile_to_url_function); break; default: throw new \Exception("Unknown display format ($format)"); } } private static function sortMethod($s1,$s2) { return strcmp($s1['symbol'],$s2['symbol']); } private static function showText(\Automap\Map $map,$subfile_to_url_function=null) { echo "\n* Global information :\n\n"; echo '	Map version : '.$map->version()."\n"; echo '	Min reader version : '.$map->minVersion()."\n"; echo '	Symbol count : '.$map->symbolCount()."\n"; echo "\n* Options :\n\n"; $opts=$map->options(); if (count($opts)) { foreach($opts as $name => $value) echo "$name: $value\n"; } else echo "<None>\n"; echo "\n* Symbols :\n\n"; $stype_len=$symbol_len=4; $rpath_len=10; $symbols=$map->symbols(); usort($symbols,array(__CLASS__,'sortMethod')); foreach($symbols as $s) { $stype_len=max($stype_len,strlen(\Automap\Mgr::typeToString($s['stype']))+2); $symbol_len=max($symbol_len,strlen($s['symbol'])+2); $rpath_len=max($rpath_len,strlen($s['rpath'])+2); } echo str_repeat('-',$stype_len+$symbol_len+$rpath_len+8)."\n"; echo '|'.str_pad('Type',$stype_len,' ',STR_PAD_BOTH); echo '|'.str_pad('Name',$symbol_len,' ',STR_PAD_BOTH); echo '| T '; echo '|'.str_pad('Defined in',$rpath_len,' ',STR_PAD_BOTH); echo "|\n"; echo '|'.str_repeat('-',$stype_len); echo '|'.str_repeat('-',$symbol_len); echo '|---'; echo '|'.str_repeat('-',$rpath_len); echo "|\n"; foreach($symbols as $s) { echo '| '.str_pad(ucfirst(\Automap\Mgr::typeToString($s['stype'])),$stype_len-1,' ',STR_PAD_RIGHT) .'| '.str_pad($s['symbol'],$symbol_len-1,' ',STR_PAD_RIGHT) .'| '.$s['ptype'].' ' .'| '.str_pad($s['rpath'],$rpath_len-1,' ',STR_PAD_RIGHT) ."|\n"; } } private static function showHtml(\Automap\Map $map,$subfile_to_url_function=null) { echo "<h2>Global information</h2>"; echo '<table border=0>'; echo '<tr><td>Map version:&nbsp;</td><td>' .htmlspecialchars($map->version()).'</td></tr>'; echo '<tr><td>Min reader version:&nbsp;</td><td>' .htmlspecialchars($map->minVersion()).'</td></tr>'; echo '<tr><td>Symbol count:&nbsp;</td><td>' .$map->symbolCount().'</td></tr>'; echo '</table>'; echo "<h2>Options</h2>"; $opts=$map->options(); if (count($opts)) { echo '<table border=0>'; foreach ($opts as $name => $value) { echo '<tr><td>'.htmlspecialchars($name).':&nbsp;</td><td>' .htmlspecialchars($value).'</td></tr>'; } echo '</table>'; } else echo "\n<p>&lt;None&gt;</p>\n"; echo "<h2>Symbols</h2>"; echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 ' .'cellspacing=0 style="border-collapse: collapse"><tr><th>Type</th>' .'<th>Name</th><th>FT</th><th>Defined in</th></tr>'; $symbols=$map->symbols(); usort($symbols,array(__CLASS__,'sortMethod')); foreach($symbols as $s) { echo '<tr><td>'.ucfirst(\Automap\Mgr::typeToString($s['stype'])).'</td><td>' .htmlspecialchars($s['symbol']) .'</td><td align=center>'.$s['ptype'].'</td><td>'; if (!is_null($subfile_to_url_function)) echo '<a href="'.call_user_func($subfile_to_url_function,$s['rpath']).'">'; echo htmlspecialchars($s['rpath']); if (!is_null($subfile_to_url_function)) echo '</a>'; echo '</td></tr>'; } echo '</table>'; } } } } namespace Automap { if (!class_exists('Automap\Map',false)) { class Map { const VERSION='3.0.0'; const MIN_MAP_VERSION='3.0.0'; const MAGIC="AUTOMAP  M\024\x8\6\3"; private $path; private $symbols; private $slots; private $symcount; private $options; private $version; private $minVersion; private $flags; private $basePath; public function __construct($path,$flags=0,$_bp=null) { $this->path=self::mkAbsolutePath($path); $this->flags=$flags; try { if (($buf=@file_get_contents($this->path))===false) throw new \Exception('Cannot read map file'); $bufsize=strlen($buf); if ($bufsize<70) throw new \Exception("Short file (size=$bufsize)"); if (substr($buf,0,14)!=self::MAGIC) throw new \Exception('Bad Magic'); $this->minVersion=trim(substr($buf,14,12)); if (version_compare($this->minVersion,self::VERSION) > 0) throw new \Exception($this->path.': Cannot understand this map.'. ' Requires at least Automap version '.$this->minVersion); $this->version=trim(substr($buf,26,12)); if (strlen($this->version)==0) throw new \Exception('Invalid empty map version'); if (version_compare($this->version,self::MIN_MAP_VERSION) < 0) throw new \Exception('Cannot understand this map. Format too old.'); $map_major_version=$this->version{0}; if (strlen($buf)!=($sz=(int)substr($buf,38,8))) throw new \Exception('Invalid file size. '.$sz.' should be '.strlen($buf)); if (!($flags & Mgr::CRC_CHECK)) { $crc=substr($buf,46,8); $buf=substr_replace($buf,'00000000',46,8); if ($crc!==hash('adler32',$buf)) throw new \Exception('CRC error'); } $this->symcount=(int)substr($buf,54,8); $dsize=(int)substr($buf,62,8); if (($buf=unserialize(substr($buf,70,$dsize)))===false) throw new \Exception('Cannot unserialize data from map file'); if (!is_array($buf)) throw new \Exception('Map file should contain an array'); if (!array_key_exists('options',$buf)) throw new \Exception('No options array'); if (!is_array($this->options=$buf['options'])) throw new \Exception('Options should be an array'); if (!array_key_exists('map',$buf)) throw new \Exception('No symbol table'); if (!is_array($this->slots=$buf['map'])) throw new \Exception('Slot table should contain an array'); $this->symbols=array(); if (!is_null($_bp)) $this->basePath=$_bp; else $this->basePath=self::combinePath(dirname($this->path) ,$this->option('basePath'),true); } catch (\Exception $e) { $this->symbols=array(); throw new \Exception($path.': Cannot load map - '.$e->getMessage()); } } public function isMapFile($path) { return (substr(file_get_contents($path),0,strlen(self::MAGIC))===self::MAGIC); } public static function key($type,$name) { return $type.trim($name,'\\'); } private function loadSlot($ns) { $this->symbols=array_merge($this->symbols,unserialize($this->slots[$ns])); unset($this->slots[$ns]); } public static function nsKey($name) { $name=trim($name,'\\'); $pos=strrpos($name,'\\'); if ($pos!==false) return substr($name,0,$pos); else return ''; } public function path() { return $this->path; } public function flags() { return $this->flags; } public function options() { return $this->options; } public function version() { return $this->version; } public function minVersion() { return $this->minVersion; } public function basePath() { return $this->basePath; } public function option($opt) { return (isset($this->options[$opt]) ? $this->options[$opt] : null); } public function symbolCount() { return $this->symcount; } private function exportEntry($key) { $entry=$this->symbols[$key]; $a=array( 'stype' => $key{0}, 'symbol' => substr($key,1), 'ptype' => $entry{0}, 'rpath' => substr($entry,1) ); $a['path']=(($a['ptype']===Mgr::F_EXTENSION) ? $a['rpath'] : self::combinePath($this->basePath,$a['rpath'])); return $a; } public function getSymbol($type,$symbol) { $key=self::key($type,$symbol); if (!($found=array_key_exists($key,$this->symbols))) { if (count($this->slots)) { $ns=self::nsKey($symbol); if (array_key_exists($ns,$this->slots)) $this->loadSlot($ns); $found=array_key_exists($key,$this->symbols); } } return ($found ? $this->exportEntry($key) : false); } public function resolve($type,$name,&$id) { if (($this->flags & Mgr::NO_AUTOLOAD) || (($entry=$this->getSymbol($type,$name))===false)) return false; $path=$entry['path']; switch($entry['ptype']) { case Mgr::F_EXTENSION: if (!dl($path)) return false; break; case Mgr::F_SCRIPT: { require($path); } break; case Mgr::F_PACKAGE: error_reporting(($errlevel=error_reporting()) & ~E_NOTICE); $mnt=require($path); error_reporting($errlevel); $pkg=\PHK\_Mgr::instance($mnt); $id=$pkg->automapID(); return Mgr::map($id)->resolve($type,$name,$id); break; default: throw new \Exception('<'.$entry['ptype'].'>: Unknown target type'); } return $entry; } public function symbols() { foreach(array_keys($this->slots) as $ns) $this->loadSlot($ns); $ret=array(); foreach(array_keys($this->symbols) as $key) $ret[]=$this->exportEntry($key); return $ret; } public function show($format=null,$subfile_to_url_function=null) { return Tools\Display::show($this,$format,$subfile_to_url_function); } public function check() { return Tools\Check::check($this); } public function export($path=null) { if (is_null($path)) $path="php://stdout"; $fp=fopen($path,'w'); if (!$fp) throw new \Exception("$path: Cannot open for writing"); foreach($this->symbols() as $s) { fwrite($fp,$s['stype'].'|'.$s['symbol'].'|'.$s['ptype'].'|'.$s['rpath']."\n"); } fclose($fp); } public function _peclGetMap($version) { $st=array(); foreach($this->symbols() as $s) { $st[]=array($s['stype'],$s['symbol'],$s['ptype'],$s['path']); } return $st; } private static function combinePath($base,$path,$separ=false) { if (($base=='.') || ($base=='') || self::isAbsolutePath($path)) $res=$path; elseif (($path=='.') || is_null($path)) $res=$base; else $res=rtrim($base,'/\\').'/'.$path; return self::trailingSepar($res,$separ); } private static function trailingSepar($path, $separ) { $path=rtrim($path,'/\\'); if ($path=='') return '/'; if ($separ) $path=$path.'/'; return $path; } private static function isAbsolutePath($path) { return ((strpos($path,':')!==false) ||(strpos($path,'/')===0) ||(strpos($path,'\\')===0)); } private static function mkAbsolutePath($path,$separ=false) { if (!self::isAbsolutePath($path)) $path=self::combinePath(getcwd(),$path); return self::trailingSepar($path,$separ); } } } } namespace PHK\Tools { if (!defined('PHP_VERSION_ID')) { $v = explode('.',PHP_VERSION); define('PHP_VERSION_ID', ($v[0]*10000+$v[1]*100+$v[2])); } if (!class_exists('PHK\Tools\Util',false)) { class Util { private static $verbose=true; public static function msg($msg) { if (self::$verbose) echo $msg."\n"; } public static function varType($var) { return is_object($var) ? 'object '.get_class($var) : gettype($var); } public static function envIsWeb() { return (php_sapi_name()!='cli'); } public static function envIsWindows() { return (substr(PHP_OS, 0, 3) == 'WIN'); } public static function fileSuffix($filename) { $dotpos=strrpos($filename,'.'); if ($dotpos===false) return ''; return strtolower(substr($filename,$dotpos+1)); } public static function combinePath($dir,$rpath) { if ($dir=='.' || $dir=='') return $rpath; $rpath=trim($rpath,'/'); $rpath=trim($rpath,'\\'); $separ=(strpos($dir,':')!==false) ? '/' : DIRECTORY_SEPARATOR; if (($dir==='/') || ($dir==='\\')) $separ=''; else { $c=substr($dir,-1,1); if (($c==='/') || ($c=='\\')) $dir=rtrim($dir,$c); } return (($rpath==='.') ? $dir : $dir.$separ.$rpath); } public static function trailingSepar($path, $separ) { $path=rtrim($path,'/\\'); if ($path=='') return '/'; if ($separ) $path=$path.'/'; return $path; } public static function isAbsolutePath($path) { return ((strpos($path,':')!==false) ||(strpos($path,'/')===0) ||(strpos($path,'\\')===0)); } public static function mkAbsolutePath($path,$separ=false) { if (!self::isAbsolutePath($path)) $path=self::combinePath(getcwd(),$path); return self::trailingSepar($path,$separ); } public static function loadExtension($ext) { if (extension_loaded($ext)) return; if (PHP_OS == 'AIX') $suffix = 'a'; else $suffix = PHP_SHLIB_SUFFIX; @dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix); if (!extension_loaded($ext)) throw new \Exception("$ext: Cannot load extension"); } public static function loadExtensions($ext_list) { $failed_ext=array(); foreach($ext_list as $ext) { try { self::loadExtension($ext); } catch (\Exception $e) { $failed_ext[]=$ext; } } if (count($failed_ext)) throw new \Exception('Cannot load the following required extension(s): ' .implode(' ',$failed_ext)); } public static function substr($buf,$position,$len=NULL) { $str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len); if ($str===false) $str=''; return $str; } private static $mqr_exists=null; private static $mqr_level=0; private static $mqr_save; public static function disableMQR() { if (is_null(self::$mqr_exists)) self::$mqr_exists=((PHP_VERSION_ID < 50300) && function_exists('set_magic_quotes_runtime')); if (!self::$mqr_exists) return; if (self::$mqr_level==0) { self::$mqr_save=get_magic_quotes_runtime(); set_magic_quotes_runtime(0); } self::$mqr_level++; } public static function restoreMQR() { if (is_null(self::$mqr_exists)) self::$mqr_exists=((PHP_VERSION_ID < 50300) && function_exists('set_magic_quotes_runtime')); if (!self::$mqr_exists) return; self::$mqr_level--; if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save); } public static function timeString($time=null) { if ($time=='unlimited') return $time; if (is_null($time)) $time=time(); return @strftime('%d-%b-%Y %H:%M %z',$time); } public static function httpBaseURL() { if (!self::envIsWeb()) return ''; if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF']; $phpself=$_SERVER['PHP_SELF']; $slen=strlen($phpself); $pathinfo=$_SERVER['PATH_INFO']; $ilen=strlen($pathinfo); if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo)) $phpself=substr($phpself,0,$slen-$ilen); return $phpself; } public static function http301Redirect($path) { header('Location: http://'.$_SERVER['HTTP_HOST'].self::httpBaseURL().$path); header('HTTP/1.1 301 Moved Permanently'); exit(0); } public static function http404Fail() { header("HTTP/1.0 404 Not Found"); exit(1); } public static function http403Fail() { header("HTTP/1.0 403 Forbidden"); exit(1); } public static function bool2str($cond) { return $cond ? 'Yes' : 'No'; } public static function readFile($path) { if (($data=@file_get_contents($path))===false) throw new \Exception($path.': Cannot get file content'); return $data; } public static function scandir($path) { if (($subnames=scandir($path))===false) throw new \Exception($path.': Cannot read directory'); $a=array(); foreach($subnames as $f) if (($f!='.') && ($f!='..')) $a[]=$f; return $a; } public static function trace($msg) { if (($tfile=getenv('PHK_TRACE_FILE')) !== false) { if (($fp=fopen($tfile,'a'))===false) throw new \Exception($tfile.': Cannot open trace file'); fwrite($fp,self::timeString().': '.$msg."\n"); fclose($fp); } } public static function deltaMS($start) { $delta=microtime(true)-$start; return round($delta*1000,2).' ms'; } public static function mkArray($data) { if (is_null($data)) return array(); if (!is_array($data)) $data=array($data); return $data; } public static function displaySlowPath() { if (getenv('PHK_DEBUG_SLOW_PATH')!==false) { $html=self::envIsWeb(); if (isset($GLOBALS['__PHK_SLOW_PATH'])) $data="Slow path entered at:\n".$GLOBALS['__PHK_SLOW_PATH']; else $data="Fast path OK\n"; \PHK::infoSection($html,'Fast path result'); if ($html) echo "<pre>"; echo $data; if ($html) echo "/<pre>"; } } public static function slowPath() { if ((getenv('PHK_DEBUG_SLOW_PATH')!==false) && (!isset($GLOBALS['__PHK_SLOW_PATH']))) { $e=new \Exception(); $GLOBALS['__PHK_SLOW_PATH']=$e->getTraceAsString(); } } public static function formatError($msg) { throw new \Exception('Format error: '.$msg); } public static function getMinVersion($mnt,$caching) { return \PHK\Stream\Wrapper::getFile(false,\PHK\Mgr::commandURI($mnt ,'magicField&name=mv'),$mnt,'magicField',array('name' => 'mv'),'' ,$caching); } public static function getOptions($mnt,$caching) { return unserialize(\PHK\Stream\Wrapper::getFile(false,\PHK\Mgr::sectionURI($mnt ,'OPTIONS'),$mnt,'section',array('name' => 'OPTIONS'),'',$caching)); } public static function getBuildInfo($mnt,$caching) { return unserialize(\PHK\Stream\Wrapper::getFile(false,\PHK\Mgr::sectionURI($mnt ,'BUILD_INFO'),$mnt,'section',array('name' => 'BUILD_INFO'),'',$caching)); } public static function callMethod($object,$method,$args) { return call_user_func_array(array($object,$method),$args); } public static function runWebInfo($phk) { $phk->proxy()->crcCheck(); $phkw=new \PHK\Web\Info($phk); $phkw->run(); } public static function atomicWrite($path,$data) { $tmpf=tempnam(dirname($path),'tmp_'); if (file_put_contents($tmpf,$data)!=strlen($data)) throw new \Exception($tmpf.": Cannot write"); if (self::envIsWindows()) @unlink($path); if (!rename($tmpf,$path)) { unlink($tmpf); throw new \Exception($path.': Cannot replace file'); } } private static $simul_inode_array=array(); private static $simul_inode_index=1; public static function pathUniqueID($prefix,$path,&$mtime) { if (($s=stat($path))===false) throw new \Exception("$path: File not found"); $dev=$s[0]; $inode=$s[1]; $mtime=$s[9]; if ($inode==0) { $rpath=realpath($path); if ($rpath === false) throw new \Exception("$path: Cannot compute realpath"); if (isset(self::$simul_inode_array[$rpath])) $inode=self::$simul_inode_array[$rpath]; else { $inode=self::$simul_inode_index++; self::$simul_inode_array[$rpath]=$inode; } } return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime); } } } } namespace PHK { if (!class_exists('PHK\PkgFile',false)) { class PkgFile { private $fp=null; private $path; private $size; private $open_count=0; private $keep_open_flag; public function __construct($path,$flags) { $this->setParams($path,$flags); if (($this->size=filesize($path))===false) throw new \Exception($path.': Cannot get file size'); } public function setParams($path,$flags) { $this->path=$path; $this->keep_open_flag=\PHK\Mgr::isPhkUri($path); } public function __sleep() { return array('size'); } public function __destruct() { $this->reallyClose(); } private function reallyClose() { if (!is_null($this->fp)) { fclose($this->fp); $this->fp=null; $this->open_count=0; } } public function _open() { if (is_null($this->fp)) { if (!($this->fp=fopen($this->path,'rb',false))) throw new \Exception($this->path.': Cannot open for reading'); $this->open_count=1; } else $this->open_count++; } public function _close() { $this->open_count--; if (($this->open_count <= 0) && (!$this->keep_open_flag)) $this->reallyClose(); } private function read($size) { $data=''; $nb_chunks=intval($size/8192); $rest=$size % 8192; \PHK\Tools\Util::disableMQR(); while ($nb_chunks > 0) { $data .= $this->readChunk(8192); $nb_chunks--; } if ($rest) $data .= $this->readChunk($rest); \PHK\Tools\Util::restoreMQR(); return $data; } private function readChunk($size) { $buf=fread($this->fp,$size); if ($buf===false) throw new \Exception('Cannot read'); if (($bsize=strlen($buf))!=$size) throw new \Exception("Short read ($bsize/$size)"); return $buf; } public function _readBlock($offset,$size) { try { $this->_open(); if (fseek($this->fp,$offset,SEEK_SET) == -1) throw new \Exception('Cannot seek'); $buf=$this->read($size); $this->_close(); } catch (\Exception $e) { $this->_close(); throw new \Exception($e->getMessage()); } return $buf; } public function size() { return $this->size; } public function path() { return $this->path; } } } if (!class_exists('PHK\PkgFileSpace',false)) { class PkgFileSpace { public $file; private $offset; private $size; public function __construct($arg1,$arg2,$size=null) { if (is_string($arg1)) { $this->file=new \PHK\PkgFile($arg1,$arg2); $this->offset=0; $this->size=$this->file->size(); } else { if ((!($arg1 instanceof self)) || (!is_numeric($arg2)) || (!is_numeric($size)) || ($arg2 < 0) || (($arg2+$size) > $arg1->size)) throw new \Exception("PkgFileSpace: cannot create - invalid arguments"); $this->file=$arg1->file; $this->offset=$arg1->offset + $arg2; $this->size=$size; } } public function readBlock($offset=0,$size=null) { if (is_null($size)) $size=$this->size-$offset; if (($offset<0)||($size<0)||($offset+$size>$this->size)) throw new \Exception('PkgFileSpace: Read out of bound'); if ($size==0) return ''; $data=$this->file->_readBlock($this->offset+$offset,$size); return $data; } public function open() { $this->file->_open(); } public function close() { $this->file->_close(); } public function size() { return $this->size; } public function path() { return $this->file->path(); } } } } namespace PHK { if (!class_exists('PHK\Cache',false)) { class Cache { const VERSION='1.1.0'; const TTL=3600; private static $caches=array("apc","xcache","eaccelerator"); private static $cacheName; private static $cache=null; private static $cache_maxsize=524288; public static function cacheID($prefix,$key) { return 'phk.'.$prefix.'.'.$key; } private static function setCacheObject() { if (is_null(self::$cache)) { self::$cache=false; self::$cacheName='none'; foreach(self::$caches as $c) { if (!extension_loaded($c)) continue; $class='Cache_'.$c; $obj=new $class; try { $status=$obj->init(); } catch (\Exception $e) { $status=false; } if ($status) { self::$cache=$obj; self::$cacheName=$c; break; } unset($obj); } \PHK\Tools\Util::trace("Cache system used : ".self::$cacheName); } } public static function setCacheMaxSize($size) { $this->cache_maxsize=$size; } public static function cacheName() { if (is_null(self::$cache)) self::setCacheObject(); return self::$cacheName; } public static function cachePresent() { if (is_null(self::$cache)) self::setCacheObject(); return (self::$cache!==false); } public static function get($id) { if (is_null(self::$cache)) self::setCacheObject(); if (self::$cache===false) return null; $result=self::$cache->get($id); if ($result===false) $result=null; return $result; } public static function set($id,$data) { if (is_null(self::$cache)) self::setCacheObject(); if (is_object(self::$cache)) { if (is_string($data) && (strlen($data) > self::$cache_maxsize)) return; \PHK\Tools\Util::trace("Writing cache: id=$id"); self::$cache->set($id,$data); } } } abstract class CacheBase { abstract public function init(); abstract public function get($id); abstract public function set($id,$data); } class Cache_apc extends CacheBase { public function init() { return \PHK\Tools\Util::envIsWeb() || ini_get('apc.enable_cli'); } public function get($id) { return apc_fetch($id); } public function set($id,$data) { apc_store($id,$data,\PHK\Cache::TTL); } } class Cache_xcache extends CacheBase { public function init() { return \PHK\Tools\Util::envIsWeb(); } public function get($id) { return xcache_get($id); } public function set($id,$data) { xcache_set($id,$data,\PHK\Cache::TTL); } } class Cache_eaccelerator extends CacheBase { public function init() { if (!function_exists('eaccelerator_get')) return false; return \PHK\Tools\Util::envIsWeb(); } public function get($id) { return eaccelerator_get($id); } public function set($id,$data) { eaccelerator_put($id,$data,\PHK\Cache::TTL); } } } } namespace PHK { if (!class_exists('PHK\Proxy',false)) { class Proxy { const VERSION='1.3.0'; const INTERP_LEN=64; const VERSION_SIZE=12; const OFFSET_SIZE=11; const MAGIC_STRING="#PHK M\024\x8\6\3"; const MAGIC_STRING_LEN=10; const MAGIC_STRING_OFFSET=70; const MAGIC_LINE_LEN=177; const AUTOMAP_SECTION='AUTOMAP'; const CRC_OFFSET=200; private $path; protected $stree=null; public $ftree=null; protected $flags; protected $fspace; private $magic=null; public function __construct($path,$flags) { try { Tools\Util::slowPath(); $this->path=$path; $this->flags=$flags; if (!($this->flags & \PHK::IS_CREATOR)) { if (! self::fileIsPackage($path)) throw new \Exception($path.'is not a PHK package'); $this->fspace= new PkgFileSpace($path,$flags); $this->fspace->open(); $this->getMagicValues(); if ($this->fspace->size()!=$this->magic['fs']) Tools\Util::formatError('Invalid file size. Should be '.$this->magic['fs']); $this->stree=Virtual\Tree::createFromEdata( $this->fspace->readBlock($this->magic['sso'] ,$this->magic['sto']-$this->magic['sso']) ,new PkgFileSpace($this->fspace,$this->magic['sto'] ,$this->magic['fto']-$this->magic['sto'])); $this->ftree=Virtual\Tree::createFromEdata($this->section('FTREE') ,new PkgFileSpace($this->fspace,$this->magic['fto'] ,$this->magic['sio']-$this->magic['fto'])); $this->fspace->close(); } else { $this->ftree=Virtual\Tree::createEmpty(); $this->stree=Virtual\Tree::createEmpty(); } } catch (\Exception $e) { throw new \Exception('While initializing PHK proxy - '.$e->getMessage()); } } public function crcCheck() { try { self::checkCrcBuffer($this->fspace->readBlock()); } catch(\Exception $e) { throw new \Exception($this->path.': file is corrupted - '.$e->getMessage()); } } public static function insertCrc($buffer,$crc) { return substr_replace($buffer,$crc,self::CRC_OFFSET,8); } private static function getCrc($buffer) { return substr($buffer,self::CRC_OFFSET,8); } private static function computeCrc($buffer) { return hash('crc32',self::insertCrc($buffer,'00000000')); } public static function checkCrcBuffer($buffer) { if (self::computeCrc($buffer) !== self::getCrc($buffer)) throw new \Exception('CRC check failed'); } public static function fixCrc($buffer) { return self::insertCrc($buffer,self::computeCrc($buffer)); } public static function fileIsPackage($path) { if (filesize($path)< (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false; if (($fp=fopen($path,'rb',false))===false) return false; if (fseek($fp,self::MAGIC_STRING_OFFSET) != 0) return false; if (($m=fread($fp,self::MAGIC_STRING_LEN))===false) return false; fclose($fp); return ($m===self::MAGIC_STRING); } public static function dataIsPackage($data) { if (strlen($data) < (self::INTERP_LEN+self::MAGIC_LINE_LEN)) return false; return (substr($data,self::MAGIC_STRING_OFFSET,self::MAGIC_STRING_LEN) ===self::MAGIC_STRING); } public function getMagicValues() { $buf=$this->fspace->readBlock(self::INTERP_LEN,self::MAGIC_LINE_LEN); $fsize=(int)substr($buf,47,self::OFFSET_SIZE); $sio=(int)substr($buf,121,self::OFFSET_SIZE); $crc=null; sscanf(substr($buf,136,8),'%08x',$crc); $this->magic=array( 'mv' => trim(substr($buf,18,self::VERSION_SIZE)), 'v' => trim(substr($buf,32,self::VERSION_SIZE)), 'fs' => $fsize, 'po' => (int)substr($buf,61,self::OFFSET_SIZE), 'sso' => (int)substr($buf,76,self::OFFSET_SIZE), 'sto' => (int)substr($buf,91,self::OFFSET_SIZE), 'fto' => (int)substr($buf,106,self::OFFSET_SIZE), 'sio' => $sio, 'pco' => (int)substr($buf,148,self::OFFSET_SIZE), 'pcs' => (int)substr($buf,163,self::OFFSET_SIZE), 'crc' => $crc, 'signed' => ($sio != $fsize)); } public function magicField($name) { return $this->magic[$name]; } private function cacheData() { $this->stree->walk('read'); $this->ftree->walk('read'); } private function clearCache() { $this->stree->walk('clear_cache'); $this->ftree->walk('clear_cache'); } public function pathList() { return $this->ftree->pathList(); } public function sectionList() { return $this->stree->pathList(); } public function signed() { return $this->magic['signed']; } public function interp() { $block=$this->fspace->readBlock(0,self::INTERP_LEN); if ((($block{0}!='#')||($block{1}!='!')) && (($block{0}!='<')||($block{1}!='?'))) throw new \Exception('Invalid interpreter block'); return ($block{0}=='#') ? trim(substr($block,2)) : ''; } public static function interpBlock($interp) { if (($interp!=='') && (strlen($interp) > (\PHK\Proxy::INTERP_LEN-3))) throw new \Exception('Length of interpreter string is limited to ' .(\PHK\Proxy::INTERP_LEN-3).' bytes'); if ($interp==='') return str_pad('<?'.'php',\PHK\Proxy::INTERP_LEN-2).'?'.'>'; else return '#!'.str_pad($interp,\PHK\Proxy::INTERP_LEN-3)."\n"; } public static function setBufferInterp($path,$interp='') { return self::fixCrc(substr_replace(Tools\Util::readFile($path) ,self::interpBlock($interp),0,\PHK\Proxy::INTERP_LEN)); } public function version() { return $this->magic['v']; } public function path() { return $this->fspace->path(); } public function section($name) { try { $node=$this->stree->lookupFile($name); } catch (\Exception $e) { throw new \Exception($name.': Unknown section'); } try { return $node->read(); } catch (\Exception $e) { throw new \Exception($name.': Cannot read section - '.$e->getMessage()); } } public function ftree() { return $this->ftree; } public function stree() { return $this->stree; } public function flags() { return $this->flags; } public function displayPackages() { $this->ftree->displayPackages(); } public function showfiles() { $this->ftree->display(true); } } } } namespace PHK { if (!class_exists('PHK\Mgr',false)) { class Mgr { const VERSION='1.4.0'; private static $phk_tab=array(); private static $proxy_tab=array(); private static $tmp_mnt_num=0; private static $caching=null; public static function isMounted($mnt) { return isset(self::$phk_tab[$mnt]); } public static function validate($mnt) { if (!self::isMounted($mnt)) throw new \Exception($mnt.': Invalid mount point'); return $mnt; } public static function instance($mnt) { self::validate($mnt); return self::$phk_tab[$mnt]; } public static function proxy($mnt) { self::validate($mnt); if (is_null(self::$proxy_tab[$mnt])) { $phk=self::instance($mnt); self::$proxy_tab[$mnt]=new \PHK\Proxy($phk->path(),$phk->flags()); } return self::$proxy_tab[$mnt]; } public static function mntList() { return array_keys(self::$phk_tab); } public static function setCache($caching) { self::$caching=$caching; } public static function cacheEnabled($mnt,$command,$params,$path) { if (!is_null(self::$caching)) return self::$caching; if (is_null($mnt)) return false; return self::instance($mnt)->cacheEnabled($command,$params,$path); } public static function pathToMnt($path) { $dummy1=$mnt=$dummy2=null; self::computeMnt($path,$dummy1,$mnt,$dummy2); if (self::isMounted($mnt)) return $mnt; throw new \Exception($path.': path is not mounted'); } public static function topLevelPath($path) { while (self::isPhkUri($path)) { $mnt=self::uriToMnt($path); $map=self::instance($mnt); $path=$map->path(); } return $path; } public static function mount($path,$flags=0) { try { if ($flags & \PHK::IS_CREATOR) { $mnt='_tmp_mnt_'.(self::$tmp_mnt_num++); self::$proxy_tab[$mnt]=null; self::$phk_tab[$mnt]=new \PHK\Build\Creator($mnt,$path,$flags); } else { $parentMnt=$mnt=$mtime=$options=$buildInfo=null; self::computeMnt($path,$parentMnt,$mnt,$mtime); if (self::isMounted($mnt)) return $mnt; self::$proxy_tab[$mnt]=null; self::$phk_tab[$mnt]=$phk=new \PHK($parentMnt,$mnt,$path,$flags,$mtime); self::getStoreData($mnt,$options,$buildInfo); $phk->init($options,$buildInfo); } } catch (\Exception $e) { if (isset($mnt) && self::isMounted($mnt)) unset(self::$phk_tab[$mnt]); throw new \Exception($path.': Cannot mount - '.$e->getMessage()); } return $mnt; } private static function getStoreData($mnt,&$options,&$buildInfo) { $caching=(is_null(self::$caching) ? true : self::$caching); $mv=\PHK\Tools\Util::getMinVersion($mnt,$caching); if (version_compare($mv,\PHK::VERSION) > 0) { \PHK\Tools\Util::formatError('Cannot understand this version. ' .'Requires at least PHK version '.$mv); } $options=\PHK\Tools\Util::getOptions($mnt,$caching); $buildInfo=\PHK\Tools\Util::getBuildInfo($mnt,$caching); } private static function computeMnt($path,&$parentMnt,&$mnt,&$mtime) { if (self::isPhkUri($path)) { $dummy1=$dummy2=$subpath=$parentMnt=null; \PHK\Stream\Wrapper::parseURI($path,$dummy1,$dummy2,$parentMnt,$subpath); self::validate($parentMnt); $mnt=$parentMnt.'#'.str_replace('/','*',$subpath); $mtime=self::instance($parentMnt)->mtime(); } else { $mnt=\PHK\Tools\Util::pathUniqueID('p',$path,$mtime); $parentMnt=null; } } public static function umount($mnt) { if (self::isMounted($mnt)) { foreach (array_keys(self::$phk_tab) as $dmnt) { if (isset(self::$phk_tab[$dmnt]) && self::$phk_tab[$dmnt]->parentMnt()===$mnt) self::umount($dmnt); } self::$phk_tab[$mnt]->umount(); unset(self::$phk_tab[$mnt]); unset(self::$proxy_tab[$mnt]); } } public static function uri($mnt,$path) { return self::baseURI($mnt).ltrim($path,'/'); } public static function isPhkUri($uri) { $u=$uri.'      '; return ($u{0}=='p' && $u{1}=='h' && $u{2}=='k' && $u{3}==':' && $u{4}=='/' && $u{5}=='/'); } public static function baseURI($mnt) { return 'phk://'.$mnt.'/'; } public static function commandURI($mnt,$command) { return self::uri($mnt,'?'.$command); } public static function sectionURI($mnt,$section) { return self::commandURI($mnt,'section&name='.$section); } public static function automapURI($mnt) { if ((!self::isMounted($mnt))||(!self::instance($mnt)->mapDefined())) return null; return self::sectionURI($mnt,'AUTOMAP'); } public static function normalizeURI($uri) { return str_replace('\\','/',$uri); } public static function uriToMnt($uri) { if (! self::isPhkUri($uri)) throw new \Exception($uri.': Not a PHK URI'); $buf=substr(self::normalizeURI($uri),6); $buf=substr($buf,0,strcspn($buf,'/')); return trim($buf); } public static function checkPhpVersion() { if (version_compare(PHP_VERSION,'5.3.0') < 0) { echo PHP_VERSION.': Unsupported PHP version ' .'- PHK needs at least version 5.3.0'; exit(1); } } } } } namespace PHK { if (!class_exists('PHK\Base',false)) { abstract class Base { const VERSION='3.0.0'; const CRC_CHECK=16; const NO_MOUNT_SCRIPT=32; const IS_CREATOR=64; protected $mnt; protected $parentMnt; protected $options=null; protected $buildInfo=null; protected $flags; protected $automapID; protected $path; protected $plugin=null; protected $caching=null; protected $mtime; protected $backend=null; protected static $mimeTable=array( '' => 'text/plain', 'gif' => 'image/gif', 'jpeg' => 'image/jpeg', 'jpg' => 'image/jpeg', 'png' => 'image/png', 'psd' => 'image/psd', 'bmp' => 'image/bmp', 'tif' => 'image/tiff', 'tiff' => 'image/tiff', 'iff' => 'image/iff', 'wbmp' => 'image/vnd.wap.wbmp', 'ico' => 'image/x-icon', 'xbm' => 'image/xbm', 'txt' => 'text/plain', 'htm' => 'text/html', 'html' => 'text/html', 'css' => 'text/css', 'php' => 'application/x-httpd-php', 'phk' => 'application/x-httpd-php', 'inc' => 'application/x-httpd-php', 'hh' => 'application/x-httpd-php', 'pdf' => 'application/pdf', 'js' => 'application/x-javascript', 'swf' => 'application/x-shockwave-flash', 'xml' => 'application/xml', 'xsl' => 'application/xml', 'xslt' => 'application/xslt+xml', 'mp3' => 'audio/mpeg', 'ram' => 'audio/x-pn-realaudio', 'svg' => 'image/svg+xml' ); public function mnt() { return $this->mnt; } public function flags() { return $this->flags; } public function path() { return $this->path; } public function mtime() { return $this->mtime; } public function automapID() { return $this->automapID; } public function options() { return $this->options; } public function parentMnt() { return $this->parentMnt; } public function plugin() { return $this->plugin; } public function __construct($parentMnt,$mnt,$path,$flags,$mtime) { $this->parentMnt=$parentMnt; $this->mnt=$mnt; $this->path=$path; $this->flags=$flags; $this->mtime=$mtime; } public function init($options,$buildInfo) { try { $this->options=$options; $this->buildInfo=$buildInfo; $this->supportsPhpVersion(); if ($this->option('crc_check') || ($this->flags & self::CRC_CHECK)) $this->crcCheck(); if (is_null($this->parentMnt)) { if (!is_null($extensions=$this->option('required_extensions'))) \PHK\Tools\Util::loadExtensions($extensions); } if ($this->mapDefined()) { $this->automapID=\Automap\Mgr::load($this->automapURI() ,$this->flags,$this->baseURI()); } else $this->automapID=0; if (!($this->flags & \PHK::NO_MOUNT_SCRIPT) && (!is_null($mpath=$this->option('mount_script')))) { require $this->uri($mpath); } if (!is_null($c=$this->option('plugin_class'))) $this->plugin=new $c($this->mnt); } catch (\Exception $e) { throw new \Exception('While initializing PHK instance - '.$e->getMessage()); } } public function mapDefined() { if ($this->flags & \PHK::IS_CREATOR) return false; return $this->buildInfo('map_defined'); } public function setCache($toggle) { $this->caching=$toggle; } public static function fileIsPackage($path) { return \PHK\Proxy::fileIsPackage($path); } public static function dataIsPackage($data) { return \PHK\Proxy::dataIsPackage($data); } public function cacheEnabled($command,$params,$path) { if ($this->flags & \PHK::IS_CREATOR) return false; if ($this->option('no_cache')===true) return false; if (!\PHK\Cache::cachePresent()) return false; if (!is_null($this->caching)) return $this->caching; return true; } public function umount() { if (!is_null($this->plugin)) unset($this->plugin); if (!($this->flags & \PHK::NO_MOUNT_SCRIPT)) { if (!is_null($upath=$this->option('umount_script'))) { require($this->uri($upath)); } } if ($this->automapID) \Automap\Mgr::unload($this->automapID); } public function uri($path) { return \PHK\Mgr::uri($this->mnt,$path); } public function sectionURI($section) { return \PHK\Mgr::sectionURI($this->mnt,$section); } public function commandURI($command) { return \PHK\Mgr::commandURI($this->mnt,$command); } public function baseURI() { return \PHK\Mgr::baseURI($this->mnt); } public function automapURI() { return \PHK\Mgr::automapURI($this->mnt); } public function option($key) { return (isset($this->options[$key]) ? $this->options[$key] : null); } public function webAccessAllowed($path) { $plen=strlen($path); foreach(\PHK\Tools\Util::mkArray($this->option('web_access')) as $apath) { if ($apath=='/') return true; $alen=strlen($apath); if (($plen >= $alen) && (substr($path,0,$alen)==$apath) && (($alen==$plen)||($path{$alen}=='/'))) return true; } return false; } private function gotoMain($web_run_script) { if ($this->option('web_main_redirect')) { \PHK\Tools\Util::http301Redirect($web_run_script); } else return 'require(\''.$this->uri($web_run_script).'\');'; } public function webTunnel($path=null,$webinfo=false) { if (is_null($path)) $path=\PHK::setSubpath(); $last_slash=(substr($path,-1)=='/'); if ($path!='/') $path=rtrim($path,'/'); $web_run_script=$this->option('web_run_script'); $mnt=$this->mnt(); if ($path=='') { if (!is_null($web_run_script)) return $this->gotoMain($web_run_script); else \PHK\Tools\Util::http301Redirect('/'); } if ((!$webinfo) && (!$this->webAccessAllowed($path)) && ($path!==$web_run_script)) { if (!is_null($web_run_script)) return $this->gotoMain($web_run_script); else \PHK\Tools\Util::http403Fail(); } $uri=$this->uri($path); if (($a=@stat($uri))===false) \PHK\Tools\Util::http404Fail(); if (($a['mode'] & 0170000) == 040000) { $file_path=null; if ($last_slash) { foreach(array('index.htm', 'index.html', 'index.php') as $fname) { if (is_file($this->uri($path.'/'.$fname))) { $file_path=$path.'/'.$fname; break; } } if (is_null($file_path)) \PHK\Tools\Util::http404Fail(); } else \PHK\Tools\Util::http301Redirect($path.'/'); } else $file_path=$path; if ((!$webinfo) && ($this->isPHPSourcePath($file_path))) { return "require('".$this->uri($file_path)."');"; } else { return "\PHK\Mgr::instance('".$this->mnt."')->mimeHeader('$file_path');\n" ."readfile('".$this->uri($file_path)."');"; } } public function mimeHeader($path) { if (!is_null($type=$this->mimeType($path))) header('Content-type: '.$type); } public function mimeType($path) { $ext=\PHK\Tools\Util::fileSuffix($path); if ((!is_null($mtab=$this->option('mime_types'))) && isset($mtab[$ext])) return $mtab[$ext]; if (isset(self::$mimeTable[$ext])) return self::$mimeTable[$ext]; if (strpos($ext,'php')!==false) return 'application/x-httpd-php'; return null; } public function isPHPSourcePath($path) { return ($this->mimeType($path)==='application/x-httpd-php'); } public function proxy() { return \PHK\Mgr::proxy($this->mnt); } public function crcCheck() { $this->proxy()->crcCheck(); } public function supportsPhpVersion() { if ((!is_null($minv=$this->option('min_php_version'))) && (version_compare(PHP_VERSION,$minv) < 0)) throw new \Exception("PHP minimum supported version: $minv (current is ".PHP_VERSION.")"); if ((!is_null($maxv=$this->option('max_php_version'))) && (version_compare(PHP_VERSION,$maxv) > 0)) throw new \Exception("PHP maximum supported version: $maxv (current is ".PHP_VERSION.")"); } public static function acceleratorIsPresent() { return false; } public function buildInfo($name=null) { if (is_null($name)) return $this->buildInfo; if (!isset($this->buildInfo[$name])) throw new \Exception($name.': unknown build info'); return $this->buildInfo[$name]; } public static function subpathURL($path) { return \PHK\Backend::subpathURL($path); } public static function setSubpath() { $path=''; if (isset($_REQUEST['_phk_path'])) $path=urldecode($_REQUEST['_phk_path']); else { $path=isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : ''; if ($path=='' && isset($_SERVER['ORIG_PATH_INFO'])) $path=$_SERVER['ORIG_PATH_INFO']; } if (($path!='') && ($path{0}!='/')) $path='/'.$path; return $path; } private function backend() { if (is_null($this->backend)) $this->backend=new \PHK\Backend($this); return $this->backend; } public function __call($method,$args) { return \PHK\Tools\Util::callMethod($this->backend(),$method,$args); } public static function prolog($file,&$cmd,&$ret) { if ($cli=(!\PHK\Tools\Util::envIsWeb())) { ini_set('display_errors',true); ini_set('memory_limit','1024M'); } \PHK\Mgr::checkPhpVersion(); $mnt=\PHK\Mgr::mount($file); $phk=\PHK\Mgr::instance($mnt); $tmp=get_included_files(); $main=(($tmp[0]===$file) || (realpath($tmp[0]) === $file)); if (!$main) { if (!is_null($script=$phk->option('lib_run_script'))) { require($phk->uri($script)); } if ($phk->option('auto_umount')) { \PHK\Mgr::umount($mnt); $ret=''; } else $ret=$mnt; return; } if ($cli) { if (($_SERVER['argc']>1) && ($_SERVER['argv'][1]!='') && ($_SERVER['argv'][1]{0}=='@')) { $ret=$phk->builtinProlog($file); return; } if (!is_null($run_path=$phk->option('cli_run_script'))) { $cmd="\$_phk_ret=require('".$phk->uri($run_path)."');"; } return; } else { if (file_exists($file.'.webinfo')) { \PHK\Tools\Util::runWebInfo($phk); } else { $cmd=$phk->webTunnel(); } } } } } } namespace { if (!class_exists('PHK',false)) { class PHK extends \PHK\Base { public static function needPhpRuntime() { } } } } namespace PHK { if (!class_exists('PHK\Backend',false)) { class Backend { private $front; public function __construct($front) { $this->front=$front; } public function __get($name) { return $this->front->$name(); } public function __call($method,$args) { if (!method_exists($this->front,$method)) throw new \Exception("$method: calling non existing method"); return call_user_func_array(array($this->front,$method),$args); } public function test() { error_reporting(($errlevel=error_reporting()) & ~E_NOTICE); if (!is_null($test_script=$this->option('test_script'))) { $test_uri=$this->uri($test_script); require($test_uri); } elseif (!is_null($phpunit_test_package=$this->option('phpunit_test_package'))) { if (!is_null($phpunit_package=$this->option('phpunit_package'))) { $phpunit_package_mnt=require $this->uri($phpunit_package); } else $phpunit_package_mnt=null; $phpunit_test_package_mnt=require $this->uri($phpunit_test_package); \PHK\UnitTest\_phk_load_phpunit_interface(); define('PHPUnit_MAIN_METHOD', 'PHPUnit_TextUI_\PHK::main'); PHPUnit_TextUI_\PHK::main(); if (!is_null($phpunit_package_mnt)) \PHK\Mgr::umount($phpunit_package_mnt); if (!is_null($phpunit_test_package_mnt)) \PHK\Mgr::umount($phpunit_test_package_mnt); } else echo "No unit tests\n"; error_reporting($errlevel); } public function envinfo() { $html=\PHK\Tools\Util::envIsWeb(); self::infoSection($html,'PHK Accelerator'); self::startInfoTable($html); if (\PHK::acceleratorIsPresent()) \PHK::accelTechInfo(); else self::showInfoLine($html,'PHK Accelerator','No'); self::infoSection($html,'Cache'); self::showInfoLine($html,'Cache system used',\PHK\Cache::cacheName()); self::endInfoTable($html); self::infoSection($html,'Environment'); self::startInfoTable($html); self::showInfoLine($html,'PHP SAPI',php_sapi_name()); self::showInfoLine($html,'Mount point',$this->mnt); $string=''; $class=new ReflectionClass('\PHK'); foreach($class->getConstants() as $name => $value) { if ((strlen($name)>1) && (substr($name,0,2)=='F_') && ($this->flags & $value)) $string .= ','.strtolower(substr($name,2)); } unset($class); $string=trim($string,','); self::showInfoLine($html,'Current mount options' ,$string=='' ? '<none>' : $string); self::endInfoTable($html); } public function showfiles() { $this->proxy()->showfiles(); } public function showmap($subfile_to_url_function=null) { if ($this->mapDefined()) \Automap\Mgr::map($this->automapID)->show(null,$subfile_to_url_function); else echo "This package does not contain a map\n"; } private function pluginInfo($html) { self::infoSection($html,'Plugin'); if (is_null($class=$this->option('plugin_class'))) { echo ($html ? '<p>' : '')."Not defined\n"; return; } if ($this->isCallablePluginMethod('_webinfo')) { $this->callPluginMethod('_webinfo',$html); echo $html ? '<p>' : "\n"; } self::startInfoTable($html); self::showInfoLine($html,'Class',$class); $rc=new ReflectionClass($class); foreach ($rc->getMethods() as $method) { if ((!$method->isPublic())||($method->isStatic()) ||($method->isConstructor())||($method->isDestructor()) ||($method->getName()==='_webinfo')) continue; $name=$method->getName(); $a=array(); foreach($method->getParameters() as $param) { $s='$'.$param->getName(); if ($param->isPassedByReference()) $s='&'.$s; if ($param->isArray()) $s = 'Array '.$s; if ($param->isOptional()) { if ($param->isDefaultValueAvailable()) $s .= ' = '.var_export($param->getDefaultValue(),true); $s = '['.$s.']'; } $a[]=$s; } self::showInfoLine($html,'Method',$name.' ( '.implode(', ',$a).' )'); } self::endInfoTable($html); } private function showOption($html,$opt,$default=null) { $str1=ucfirst(str_replace('_',' ',$opt)); $url=null; $newwin=true; if (is_null($val=$this->option($opt))) $val=$default; if ($html && preg_match('/^(.*)\s<(\S+)>.*$/',$val,$regs)) { $str2=trim($regs[1]); $url=$regs[2]; if ($str2=='') $str2=$url; } else { $str2=$val; $vlen=strlen($val); if (($vlen>=7)&&(substr($val,0,7)=='http://')) $url=$val; elseif (($vlen>=1) && ($val{0}=='/') && file_exists($this->uri($val))) { $url=\PHK::subpathURL('/view/'.trim($val,'/')); $newwin=false; } } self::showInfoLine($html,$str1,$str2,$url,$newwin); } public static function infoSection($html,$title) { echo $html ? '<h2>'.htmlspecialchars($title).'</h2>' : "\n==== ".str_pad($title.' ',70,'='). "\n\n"; } public static function showInfoLine($html,$string,$value,$url=null ,$newwin=true) { if (is_null($value)) $value='<>'; if (is_bool($value)) $value=\PHK\Tools\Util::bool2str($value); if ($html) { echo '<tr><td>'.htmlspecialchars($string).':&nbsp;</td><td>'; if ($url) { echo '<a href="'.$url.'"'; if ($newwin) echo ' target="_blank"'; echo '>'; } echo htmlspecialchars($value); if ($url) echo '</a>'; echo '</td></tr>'; } else { echo "$string: $value"; if ((!is_null($url)) && ($url{0}!='/')) echo " <$url>"; echo "\n"; } } public static function startInfoTable($html) { echo $html ? '<table border=0>' : ''; } public static function endInfoTable($html) { echo $html ? '</table>' : ''; } public function info() { $html=\PHK\Tools\Util::envIsWeb(); if ($html && (!is_null($info_script=$this->option('info_script')))) { require($this->uri($info_script)); } else { self::startInfoTable($html); $this->showOption($html,'name'); $this->showOption($html,'summary'); $this->showOption($html,'version'); $this->showOption($html,'release'); $this->showOption($html,'distribution'); $this->showOption($html,'license'); $this->showOption($html,'copyright'); $this->showOption($html,'url'); $this->showOption($html,'author'); $this->showOption($html,'packager'); $this->showOption($html,'requires'); $req=implode(' ',\PHK\Tools\Util::mkArray($this->option('required_extensions'))); if ($req=='') $req='<none>'; self::showInfoLine($html,'Required extensions',$req); self::endInfoTable($html); } } public function techinfo() { $html=\PHK\Tools\Util::envIsWeb(); self::infoSection($html,'Package'); self::startInfoTable($html); $this->showOption($html,'name'); $this->showOption($html,'summary'); $this->showOption($html,'version'); $this->showOption($html,'release'); $this->showOption($html,'distribution'); $this->showOption($html,'license'); $this->showOption($html,'copyright'); $this->showOption($html,'url'); $this->showOption($html,'author'); $this->showOption($html,'packager'); $this->showOption($html,'requires'); self::showInfoLine($html,'Signed',$this->proxy()->signed()); self::showInfoLine($html,'Automap defined',$this->mapDefined()); self::showInfoLine($html,'File path',$this->path); self::showInfoLine($html,'File size',filesize($this->path)); $req=implode(', ',\PHK\Tools\Util::mkArray($this->option('required_extensions'))); if ($req=='') $req='<none>'; self::showInfoLine($html,'Required extensions',$req); self::showInfoLine($html,'Build date' ,\PHK\Tools\Util::timeString($this->buildInfo('build_timestamp'))); $this->showOption($html,'icon'); $this->showOption($html,'crc_check',false); $this->showOption($html,'help_prefix'); $this->showOption($html,'license_prefix'); $this->showOption($html,'auto_umount',false); $this->showOption($html,'no_cache',false); $this->showOption($html,'no_opcode_cache',false); $this->showOption($html,'prolog_code_creator',false); $this->showOption($html,'plain_prolog',false); self::showInfoLine($html,'File count',count($this->pathList())); self::endInfoTable($html); $this->pluginInfo($html); self::infoSection($html,'Package scripts'); self::startInfoTable($html); $this->showOption($html,'cli_run_script'); $this->showOption($html,'web_run_script'); $this->showOption($html,'lib_run_script'); $this->showOption($html,'info_script'); $this->showOption($html,'mount_script'); $this->showOption($html,'umount_script'); $this->showOption($html,'test_script'); $this->showOption($html,'phpunit_package'); $this->showOption($html,'phpunit_test_package'); self::endInfoTable($html); self::infoSection($html,'Module versions'); self::startInfoTable($html); self::showInfoLine($html,'PHK Manager',$this->buildInfo('phkmgr_version')); self::showInfoLine($html,'Automap Creator',$this->buildInfo('automap_creator_version')); self::showInfoLine($html,'Automap min version',$this->buildInfo('automap_minVersion')); self::endInfoTable($html); self::infoSection($html,'Sub-packages'); ob_start(); $this->proxy()->displayPackages(); $data=ob_get_clean(); if ($data==='') echo ($html ? '<p>' : '')."None\n"; else echo $data; self::infoSection($html,'Web direct access'); self::startInfoTable($html); $list=\PHK\Tools\Util::mkArray($this->option('web_access')); self::showInfoLine($html,'State',count($list) ? 'Enabled' : 'Disabled'); $this->showOption($html,'web_main_redirect',false); foreach($list as $path) self::showInfoLine($html,'Path',$path); self::endInfoTable($html); self::infoSection($html,'Package options'); $a=$this->options(); $data=(is_null($a) ? '<>' : print_r($a,true)); echo ($html ? ('<pre>'.htmlspecialchars($data).'</pre>') : $data); self::infoSection($html,'Sections'); $this->proxy()->stree()->display(false); } public function autoFile($prefix) { $html=\PHK\Tools\Util::envIsWeb(); $txt_suffixes=array('.txt',''); $suffixes=($html ? array('.htm','.html') : $txt_suffixes); $base_path=$this->uri($prefix); foreach($suffixes as $suffix) { if (is_readable($base_path.$suffix)) { return \PHK\Tools\Util::readFile($base_path.$suffix); break; } } if ($html) { foreach ($txt_suffixes as $suffix) if (is_readable($base_path.$suffix)) return '<pre>'.htmlspecialchars(\PHK\Tools\Util::readFile($base_path.$suffix)) .'</pre>'; } return null; } public function autoOption($name) { $data=null; $prefix=$this->option($name.'_prefix'); if (!is_null($prefix)) $data=$this->autoFile($prefix); if (is_null($data)) { $data='<No '.$name.' file>'."\n"; if (\PHK\Tools\Util::envIsWeb()) $data=htmlspecialchars($data); } return $data; } public function isCallablePluginMethod($method) { return (is_null($this->plugin)) ? false : is_callable(array($this->plugin,$method)); } public function callPluginMethod($method) { if (!$this->isCallablePluginMethod($method)) throw new \Exception($method.': Undefined plugin method'); $args=func_get_args(); array_shift($args); return call_user_func_array(array($this->plugin,$method),$args); } public function pathList() { return unserialize(file_get_contents($this->commandURI(__FUNCTION__))); } public function sectionList() { return unserialize(file_get_contents($this->commandURI(__FUNCTION))); } public static function subpathURL($path) { if ($path{0}!='/') $path=\PHK::setSubpath().'/'.$path; $path=preg_replace(',//+,','/',$path); return \PHK\Tools\Util::httpBaseURL().((php_sapi_name()=='cgi') ? ('?_phk_path='.urlencode($path)) : $path); } private static function cmdUsage($msg=null) { if (!is_null($msg)) echo "** ERROR: $msg\n"; echo "\nAvailable commands:\n\n"; echo "	- @help             Display package help\n"; echo "	- @license          Display license\n"; echo "	- @get <path>       Display a subfile content\n"; echo "	- @showmap          Display symbol map, if present\n"; echo "	- @showfiles        List subfiles\n"; echo "	- @option <name>    Display a package option\n"; echo "	- @set_interp <string>  Set the first line of the PHK to '#!<string>'\n"; echo "	- @info             Display information about the PHK file\n"; echo "	- @techinfo         Display technical information\n"; echo "	- @dump <directory> Extracts the files\n"; echo "	- @test [switches] [UnitTest]  Run the package's unit tests\n"; if (!is_null($msg)) exit(1); } public function builtinProlog($file) { $retcode=0; $args=$_SERVER['argv']; try { $this->proxy()->crcCheck(); $command=\PHK\Tools\Util::substr($args[1],1); array_shift($args); $param=isset($args[1]) ? $args[1] : null; switch($command) { case 'get': if (is_null($param)) self::cmdUsage($command.": needs argument"); $uri=$this->uri($param); if (is_file($uri)) readfile($uri); else throw new \Exception("$param: file not found"); break; case 'test': case 'showmap': case 'info': case 'techinfo': case 'showfiles': $this->$command(); break; case 'option': $res=$this->$command($param); if (is_null($res)) throw new \Exception('Option not set'); echo "$res\n"; break; case 'set_interp': if (is_null($param)) self::cmdUsage($command.": needs argument"); if (file_put_contents($file ,\PHK\Proxy::setBufferInterp($file,$param))===false) throw new \Exception('Cannot write file'); break; case 'license': case 'licence': echo $this->autoOption('license'); break; case 'help': echo $this->autoOption($command); break; case 'dump': if (is_null($param)) self::cmdUsage($command.": needs argument"); $this->proxy()->ftree()->dump($param); break; case '': self::cmdUsage(); break; default: self::cmdUsage($command.': Unknown command'); } \PHK\Tools\Util::displaySlowPath(); } catch (\Exception $e) { if (getenv('SHOW_EXCEPTION')!==false) throw $e; echo "** ERROR: Command failed ($command) - ".$e->getMessage()."\n"; $retcode=1; } return $retcode; } } } } namespace PHK\Stream { if (!class_exists('PHK\Stream\Wrapper',false)) { class Wrapper { private $uri; private $mnt; private $path; private $command; private $params; private $data; private $size; private $position; private $raiseErrors=true; private function raiseWarning($msg) { if ($this->raiseErrors) trigger_error("PHK: $msg",E_USER_WARNING); } public static function getFile($dir,$uri,$mnt,$command,$params,$path,$cache=null) { $cacheID=\PHK\Cache::cacheID('node',$uri); \PHK\Tools\Util::trace("get_file: Cache ID=<$cacheID>"); if (is_null($data=\PHK\Cache::get($cacheID))) { $can_cache=true; if (is_null($data=($dir ? Backend::getDirData($mnt,$command,$params,$path) : Backend::getFileData($mnt,$command,$params,$path ,$can_cache)))) throw new \Exception("$uri: File not found"); if ($can_cache && (($cache===true) || (is_null($cache) && \PHK\Mgr::cacheEnabled($mnt,$command,$params,$path)))) \PHK\Cache::set($cacheID,$data); } if ($dir && (!is_array($data))) throw new \Exception('Not a directory'); if ((!$dir) && (!is_string($data))) throw new \Exception('Not a regular file'); return $data; } public function stream_open($uri,$mode,$options,&$opened_path) { \PHK\Tools\Util::trace("Starting stream_open: uri=$uri"); try { $this->uri=$uri; $this->raiseErrors=($options & STREAM_REPORT_ERRORS); if ($options & STREAM_USE_PATH) $opened_path=$uri; if (($mode!='r')&&($mode!='rb')) throw new \Exception($mode.': unsupported mode (Read only)'); self::parseURI($uri,$this->command,$this->params,$this->mnt,$this->path); if (!is_null($this->mnt)) \PHK\Mgr::validate($this->mnt); $this->data=self::getFile(false,$uri,$this->mnt,$this->command ,$this->params,$this->path); $this->size=strlen($this->data); $this->position=0; } catch (\Exception $e) { $msg=$uri.': Open error - '.$e->getMessage(); $this->raiseWarning($msg); return false; } \PHK\Tools\Util::trace("Exiting stream_open: uri=$uri");return true; } public function stream_read($nb) { \PHK\Tools\Util::trace("Starting stream_read: uri=".$this->uri." - nb=$nb - position=".$this->position." size=".$this->size); if ($this->position==$this->size) return false; $max=$this->size-($pos=$this->position); if ($nb > $max) $nb=$max; $this->position+=$nb; return substr($this->data,$pos,$nb); } public function stream_eof() { return ($this->position==$this->size); } public function stream_tell() { return $this->position; } public function stream_seek($offset,$whence) { \PHK\Tools\Util::trace("Starting stream_seek: uri=".$this->uri." - offset=$offset - whence=$whence"); switch($whence) { case SEEK_CUR: $this->position+=$offset; break; case SEEK_END: $this->position=$this->size+$offset; break; default: $this->position=$offset; break; } if ($this->position > $this->size) $this->position=$this->size; if ($this->position < 0) $this->position=0; return true; } public function dir_opendir($uri,$options) { try { $this->uri=$uri; $this->raiseErrors=($options & STREAM_REPORT_ERRORS); self::parseURI($uri,$this->command,$this->params,$this->mnt ,$this->path); if (!is_null($this->mnt)) \PHK\Mgr::validate($this->mnt); $this->data=self::getFile(true,$uri,$this->mnt,$this->command ,$this->params,$this->path); $this->size=count($this->data); $this->position=0; } catch (\Exception $e) { $msg=$uri.': PHK opendir error - '.$e->getMessage(); $this->raiseWarning($msg); return false; } return true; } public function dir_readdir() { if ($this->position==$this->size) return false; return $this->data[$this->position++]; } public function dir_rewinddir() { $this->position=0; } private static function statArray($mode,$size,$mtime) { return array( 'dev' => 0, 'ino' => 0, 'mode' => $mode, 'nlink' => 1, 'uid' => 0, 'gid' => 0, 'rdev' => -1, 'size' => $size, 'atime' => $mtime, 'mtime' => $mtime, 'ctime' => $mtime, 'blksize' => 8192, 'blocks' => 1); } public function stream_stat() { \PHK\Tools\Util::trace("Entering stream_stat"); return $this->url_stat($this->uri,0,true); } public function url_stat($uri,$flags,$fstat=false) { \PHK\Tools\Util::trace("Entering url_stat($uri,$flags,$fstat)"); try { $this->raiseErrors=!($flags & STREAM_URL_STAT_QUIET); if (!$fstat) { self::parseURI($uri,$this->command,$this->params,$this->mnt ,$this->path); if (!is_null($this->mnt)) \PHK\Mgr::validate($this->mnt); } $cacheID=\PHK\Cache::cacheID('stat',$uri); if (is_null($data=\PHK\Cache::get($cacheID))) { \PHK\Tools\Util::trace("url_stat($uri): not found in cache"); try { $cache=true; $mode=$size=$mtime=null; Backend::getStatData($this->mnt,$this->command ,$this->params,$this->path,$cache,$mode,$size,$mtime); $data=array($mode,$size,$mtime); } catch (\Exception $e) { \PHK\Tools\Util::trace("url_stat($uri): lookup failed"); $data=''; } if ($cache && (!is_null($this->mnt)) && \PHK\Mgr::cacheEnabled($this->mnt ,$this->command,$this->params,$this->path)) { \PHK\Cache::set($cacheID,$data); } } if (is_array($data)) { list($mode,$size,$mtime)=$data; return self::statArray($mode,$size,$mtime); } else throw new \Exception('File not found'); } catch (\Exception $e) { $msg=$uri.': PHK Stat error - '.$e->getMessage(); $this->raiseWarning($msg); return false; } } public static function parseURI($uri,&$command,&$params,&$mnt,&$path) { \PHK\Tools\Util::trace("Entering parseURI($uri)"); if (! \PHK\Mgr::isPhkUri($uri=str_replace('\\','/',$orig_uri=$uri))) throw new \Exception('Not a PHK URI'); $uri=substr($uri,6); if (($pos=strpos($uri,'?'))!==false) { $cmd=\PHK\Tools\Util::substr($uri,$pos+1); $uri=substr($uri,0,$pos); if (($pos=strpos($cmd,'&'))!==false) { $command=substr($cmd,0,$pos); parse_str(\PHK\Tools\Util::substr($cmd,$pos+1),$params); } else $command=$cmd; if ($command=='') throw new \Exception('Empty command'); } $uri=trim($uri,'/'); if ($uri!='') { $a=explode('/',$uri,2); $mnt=$a[0]; $path=isset($a[1]) ? $a[1] : ''; } if (is_null($command) && is_null($mnt)) throw new \Exception('Empty URI'); } } stream_wrapper_register('phk','PHK\Stream\Wrapper'); } } namespace PHK\Stream { if (!class_exists('PHK\Stream\Backend',false)) { class Backend { private static $tmp_data=null; const TMP_URI='phk://?tmp'; private static function commandOpenOrStat($stat_flag,$mnt,$command,$params ,$path,&$cache) { $cache=true; try { if (is_null($mnt)) { switch($command) { case 'test': return "Test line 1/3\nTest line2/3\nTest line 3/3\n"; break; case 'tmp': $cache=false; return self::$tmp_data; break; default: throw new \Exception($command.': Unknown global command'); } } else { $proxy=\PHK\Mgr::proxy($mnt); switch ($command) { case 'section': case 'magicField': if (!isset($params['name'])) throw new \Exception($command .': command needs this argument: name'); return $proxy->$command($params['name']); case 'pathList': case 'sectionList': return serialize($proxy->$command()); default: throw new \Exception($command.': Unknown command'); } } } catch (\Exception $e) { throw new \Exception($command.': Error during command execution - ' .$e->getMessage()); } } public static function getFileData($mnt,$command,$params,$path,&$cache) { $cache=true; try { if (is_null($command)) { $node=\PHK\Mgr::proxy($mnt)->ftree()->lookupFile($path,false); if (is_null($node)) return null; return $node->read(); } else { return self::commandOpenOrStat(false,$mnt,$command,$params,$path,$cache); } } catch (\Exception $e) { return null; } } public static function getDirData($mnt,$command,$params,$path) { try { if (!is_null($command)) return null; $node=\PHK\Mgr::proxy($mnt)->ftree()->lookup($path,false); if (is_null($node)) return null; return $node->getDir(); } catch (\Exception $e) { return null; } } public static function getStatData($mnt,$command,$params,$path,$cache ,&$mode,&$size,&$mtime) { if (!is_null($command)) { $mode=0100444; $size=strlen(self::commandOpenOrStat(true,$mnt,$command,$params ,$path,$cache)); } else { $node=\PHK\Mgr::proxy($mnt)->ftree()->lookup($path); $mode=$node->mode(); $size=$node->size(); } $mtime=(is_null($mnt) ? time() : \PHK\Mgr::instance($mnt)->mtime()); } public static function setTmpData($str) { $prev=self::$tmp_data; self::$tmp_data=$str; return $prev; } public static function _stripString($str) { if (getenv('PHK_NO_STRIP')!==false) return $str; $save=self::setTmpData($str); $res=php_strip_whitespace(self::TMP_URI); self::setTmpData($save); return $res; } public static function _includeString($str) { $save=self::setTmpData($str); $res=require(self::TMP_URI); self::setTmpData($save); return $res; } } } } namespace PHK\Virtual { if (!class_exists('PHK\Virtual\DC',false)) { class DC { private $csz; private $rsz; private $flags; private $off; private $data=null; private $fspace=null; const COMPRESS_TYPE=7; const COMPRESS_NONE=0; const COMPRESS_GZIP=1; const COMPRESS_BZIP2=2; private static $compression_method_names=array('none','gzip','bzip2'); private static $compression_needed_extensions=array(null,'zlib','bz2'); public function clearCache() { $data=null; } public function setFspace($fspace) { $this->fspace=$fspace; } private function compressionType() { return $this->flags & self::COMPRESS_TYPE; } private function expand($buf) { $ctype=$this->compressionType(); if ($buf==='' || $ctype==self::COMPRESS_NONE) return $buf; switch($ctype) { case self::COMPRESS_BZIP2: if(is_int($rbuf=bzdecompress($buf))) throw new \Exception("Cannot bzdecompress data - Error code $buf"); break; case self::COMPRESS_GZIP: if(($rbuf=gzuncompress($buf))===false) throw new \Exception("Cannot gzuncompress data"); break; default: throw new \Exception("Unknown compression method : $ctype"); } return $rbuf; } public function read() { if (is_null($this->data)) { if ($this->rsz==0) $this->data=''; else { $rbuf=$this->expand($this->fspace->readBlock($this->off,$this->csz)); if (strlen($rbuf)!=$this->rsz) throw new \Exception('Wrong expanded size'); $this->data=$rbuf; } } return $this->data; } private static function compressionRatio($rsz,$csz) { return ($rsz==0) ? '-' : (round(($csz/$rsz)*100)); } public function flagString() { if ($ctype=$this->flags & self::COMPRESS_TYPE) return 'compress/'.self::$compression_method_names[$ctype] .' ('.self::compressionRatio($this->rsz,$this->csz).'%)'; return ''; } public function size() { return $this->rsz; } public function import($edata) { list($this->flags,$this->csz,$this->rsz,$this->off) =array_values(unpack('va/V3b',$edata)); $this->data=null; } public function __construct() { $this->setFlags(0); $this->setData(''); $this->csz=$this->off=null; } public function setFlags($flags) { $this->flags=($flags & \PHK\Virtual\Node::TN_DC_FLAG_MASK); } public function setData($data) { $this->rsz=strlen($this->data=$data); } } } } namespace PHK\Virtual { if (!class_exists('PHK\Virtual\Tree',false)) { class Tree { public $fspace; private $edata; private $nodes; private static $char_to_class=array( 'D' => 'Dir', 'F' => 'File'); public static function createFromEdata($serial_edata,\PHK\PkgFileSpace $fspace) { $tree=new self($fspace); $tree->edata=unserialize($serial_edata); return $tree; } public function pathList() { return array_keys($this->edata); } public function pathExists($rpath) { return array_key_exists($rpath,$this->edata); } public function count() { return count($this->edata); } public function walk($method) { $args=func_get_args(); array_shift($args); foreach($this->pathList() as $path) { $node=$this->rlookup($path); call_user_func_array(array($node,$method),$args); } } private function realpath($path) { $a=explode('/',trim($path,'/')); $ra=array(); foreach($a as $comp) { switch($comp) { case '': case '.': break; case '..': if (count($ra)) array_pop($ra); break; default: $ra[]=$comp; } } if (!count($ra)) return ''; return '/'.implode('/',$ra); } public function lookup($path,$exception_flag=true) { return $this->rlookup(self::realpath($path),$exception_flag); } private function rlookup($path,$exception_flag=true) { if (array_key_exists($path,$this->edata)) { if (!array_key_exists($path,$this->nodes)) { $edata=$this->edata[$path]; $class=__NAMESPACE__.'\\'.self::$char_to_class[$edata{0}]; $node=$this->nodes[$path]=new $class($path,$this); $node->import(substr($edata,1)); } return $this->nodes[$path]; } if ($exception_flag) throw new \Exception($path.': path not found'); else return null; } public function lookupFile($path,$exception_flag=true) { $f=$this->lookup($path,$exception_flag); if ((!is_null($f)) && (!($f instanceof File))) { if ($exception_flag) throw new \Exception($path.': No such file'); else return null; } return $f; } public function displayHeader($html) { if ($html) echo '<table border=1 bordercolor="#BBBBBB" cellpadding=3 ' .'cellspacing=0 style="border-collapse: collapse"><tr><th>T</th>' .'<th>Name</th><th>Size</th><th>Flags</th></tr>'; } public function displayFooter($html) { if ($html) echo '</table>'; } public function display($link) { $html=\PHK\Tools\Util::envIsWeb(); $this->displayHeader($html); $this->walk('display',$html,$link); $this->displayFooter($html); } public function displayPackages() { $html=\PHK\Tools\Util::envIsWeb(); ob_start(); $this->walk('displayPackage',$html); $data=ob_get_clean(); if ($data!=='') { $this->displayHeader($html); $this->walk('displayPackage',$html); $this->displayFooter($html); } } public function dump($base) { $this->walk('dump',$base); } public static function dirBaseName($path) { $dir=preg_replace(',/[^/]*$,','',$path); $base=preg_replace(',^.*/,','',$path); return array($dir,$base); } private function __construct($fspace) { $this->fspace=$fspace; $this->nodes=array(); } } } } namespace PHK\Virtual { if (!class_exists('PHK\Virtual\Node',false)) { abstract class Node { protected $flags; protected $path; protected $tree=null; const TN_DC_FLAG_MASK=DC::COMPRESS_TYPE; const TN_STRIP_SOURCE=8; const TN_NO_AUTOLOAD=16; const TN_PKG=32; abstract public function type(); public function displayPackage($html) {} public function isPackage() { return ($this->flags & self::TN_PKG); } public function getDir() { throw new \Exception($this->path.': Cannot getDir() on a '.$this->type()); } public function read() { throw new \Exception($this->path.': Cannot read() a '.$this->type()); } protected function flagString() { $flagString=''; if ($this->flags & self::TN_PKG) $flagString .=',package'; else { if ($this->flags & self::TN_STRIP_SOURCE) $flagString .=',strip'; if ($this->flags & self::TN_NO_AUTOLOAD) $flagString .=',no_autoload'; } return $flagString; } protected function __construct($path,$tree) { $this->path=$path; $this->tree=$tree; $this->flags=0; } protected function import($edata) { list($this->flags)=array_values(unpack('va',$edata)); return substr($edata,2); } } } } namespace PHK\Virtual { if (!class_exists('PHK\Virtual\Dir',false)) { class Dir extends Node { private $children; public function type() { return 'dir'; } public function mode() { return 040555; } public function size() { return count($this->children); } public function getNeededExtensions() {} public function display($html,$link) { $path=$this->path; if ($path=='') $path='/'; if ($html) echo '<tr><td nowrap colspan=4>&nbsp;<b><i>'.$path .'</i></b></td></tr>'; else echo "D      $path\n"; } public function getDir() { return $this->children; } public function dump($base) { $path=$base.$this->path; if (mkdir($path)===false) throw new \Exception($path.': cannot create directory'); } public function import($edata) { $this->children=explode(';',parent::import($edata)); } public function __construct($path,$tree) { parent::__construct($path,$tree); $this->children=array(); } public function subpath($name) { return $this->path.'/'.$name; } } } } namespace PHK\Virtual { if (!class_exists('PHK\Virtual\File',false)) { class File extends Node { private $dc; public function type() { return 'file'; } public function mode() { return 0100444; } public function __call($method,$args) { try { return call_user_func_array(array($this->dc,$method),$args); } catch (\Exception $e) { throw new \Exception($this->path.': '.$e->getMessage()); } } public function read() { return $this->dc->read(); } public function flagString() { $string=parent::flagString().','.$this->dc->flagString(); $string=trim($string,','); return $string; } public function displayPackage($html) { if ($this->flags & self::TN_PKG) $this->display($html); } public function display($html,$link=false) { $flagString=$this->flagString(); $path=$this->path; if ($html) { if ($this->flags & self::TN_PKG) $link=false; $field= ($link ? '<a href="'.\PHK::subpathURL('/view/' .trim($path,'/')).'">'.$path.'</a>' : $path); echo '<tr><td nowrap>F</td><td nowrap>'.$field.'</td><td nowrap>' .$this->size().'</td><td nowrap>'.$flagString.'</td></tr>'; } else { if ($flagString!='') $flagString = ' ('.$flagString.')'; echo 'F '.str_pad($this->size(),11).' '.$path.$flagString."\n"; } } public function dump($base) { $path=$base.$this->path; if (file_put_contents($path,$this->read())===false) throw new \Exception($path.': cannot dump file'); } public function __construct($path,$tree) { parent::__construct($path,$tree); $this->dc=new DC(); $this->dc->setFspace($tree->fspace); } public function import($edata) { $this->dc->import(parent::import($edata)); } public function setFlags($flags) { parent::setFlags($flags); $this->dc->setFlags($flags); } } } } namespace PHK\Web { if (!class_exists('PHK\Web\Info',false)) { class Info { const VERSION='0.2.5'; private $PHK; private $cmd_titles=array( 'info' => 'Home', 'techinfo' => 'Technical information', 'showmap' => 'Symbol map', 'showfiles' => 'Files', 'test' => 'Unit tests'); public function __construct($phk) { $this->PHK=$phk; \PHK\Mgr::setCache(false); } private static function displayTab($url,$name) { echo '<li id="'.$name.'"><a href="'.\PHK::subpathURL($url) .'"><span>'.$name.'</span></a></li>'; } private function header($title=null) { if (is_null($name=$this->PHK->option('name'))) $name=basename($this->PHK->path()); $win_title=(is_null($title) ? $name : "$name - $title"); echo '<head>' ."<title>$win_title</title>" .'<link href="'.\PHK::subpathURL('/php_section/STATIC/tabs/tabs.css.php') .'" rel="stylesheet" type="text/css">' ."<style type=text/css><!--\n" ."a,a:active,a:link { color: blue; text-decoration: none; }\n" ."a:hover { color: blue; text-decoration: underline; }\n" .'--></style>' ."</head>\n"; echo '<table width=100% border=0 cellpadding=0 cellspacing=0>'; echo '<tr><td><div class="tabs"><ul>'; self::displayTab('/info','Home'); if (!is_null($this->PHK->option('help_prefix'))) self::displayTab('/autoOption/help','Help'); if (!is_null($this->PHK->option('license_prefix'))) self::displayTab('/autoOption/license','License'); self::displayTab('/techinfo','Info'); self::displayTab('/showfiles','Files'); if ($this->PHK->mapDefined()) self::displayTab('/showmap','Symbol map'); if ((!is_null($this->PHK->option('test_script'))) ||(!is_null($this->PHK->option('phpunit_test_package')))) self::displayTab('/test','Tests'); if (!is_null($tabs=$this->PHK->option('tabs'))) foreach($tabs as $n => $url) self::displayTab($url,$n); echo '</ul></div></td></tr>'; $bg_string=(is_null($opt=$this->PHK->option('icon_bgcolor')) ? '' : 'bgcolor="'.$opt.'"'); if (is_null($icon_width=$this->PHK->option('icon_width'))) $icon_width='150'; echo '<tr><td width=100%><table width=100% border=1 bordercolor="#aaaaaa"' .' cellpadding=3 cellspacing=0>'; echo "<tr><td width=$icon_width $bg_string align=center>"; $url=$this->PHK->option('url'); if (!is_null($url)) echo '<a href="'.$url.'" target=_blank>'; if (!is_null($icon_path=$this->PHK->option('icon'))) echo '<img border=0 src="'.\PHK::subpathURL('/file/'.trim($icon_path,'/')) .'" alt="Package Home">'; elseif (!is_null($url)) echo '&lt;Website&gt;'; if (!is_null($url)) echo '</a>'; echo "</td>\n"; echo '<td bgcolor="#D7E2FF" align=center><h1>'.$name.'</h1></td>'; echo '<td width=151 align=center><a href="http://phk.tekwire.net"' .' target=_blank><img width=151 height=88 border=0 src="' .\PHK::subpathURL('/section/STATIC/phk_logo.png') .'" alt="PHK Home"></a></td>'; echo '</tr>'; echo '</table></td></tr></table>'; if (!is_null($title)) echo "<p><h1>$title</h1>"; @flush(); } public function run() { if (isset($_REQUEST['debug'])) { echo "<hr>"; echo "<h2>Environment:</h2>"; echo "<h3>_REQUEST :</h3>"; echo "<pre>"; var_dump($_REQUEST); echo "</pre>"; echo "<h3>_SERVER :</h3>"; echo "<pre>"; print_r($_SERVER); echo "</pre>"; } $command=trim(\PHK::setSubpath(),'/'); if (($pos=strpos($command,'/'))!==false) { $arg=substr($command,$pos+1); $command=substr($command,0,$pos); } else $arg=''; if ($command=='') $command='info'; self::sendCacheHeader(); switch($command) { case 'view': $arg='/'.$arg; $this->header("File: $arg"); $path=$this->PHK->uri($arg); if (!is_file($path)) { echo '* ERROR: '.$arg.': File not found<p>'; break; } echo "<table border=0>\n"; echo '<tr><td>Size:</td><td>'.filesize($path).'</td></tr>'; echo '<tr><td>Storage flags:</td><td>' .$this->PHK->proxy()->ftree()->lookup($arg)->flagString().'</td></tr>'; echo "</table><hr/>"; switch($mime_type=$this->PHK->mimeType($arg)) { case 'application/x-httpd-php': highlight_file($path); break; case 'text/html': echo \PHK\Tools\Util::readFile($path); break; default: if (strpos($mime_type,'image/')===0) echo 'Image: <img src="'.\PHK::subpathURL('/file'.$arg).'">'; else echo '<pre>'.htmlspecialchars(\PHK\Tools\Util::readFile($path)) .'</pre>'; } break; case 'run': $this->header(); eval($this->PHK->webTunnel($arg,true)); break; case 'file': eval($this->PHK->webTunnel($arg,true)); return; case 'info': case 'techinfo': case 'envinfo': case 'showmap': case 'showfiles': case 'test': if (isset($this->cmd_titles[$command])) $t=$this->cmd_titles[$command]; else $t=ucfirst($command); $this->header($t); $this->PHK->$command(array(__CLASS__,'viewSubfileURL')); break; case 'autoFile': $this->header(); echo $this->PHK->autoFile('/'.$arg); break; case 'autoOption': $this->header(ucfirst($arg)); echo $this->PHK->autoOption($arg); break; case 'php_section': require($this->PHK->sectionURI($arg)); return; case 'section': eval($this->PHK->webTunnel('/?section&name='.$arg,true)); return; default: echo '<b>'.$command.': Unknown subcommand</b><p>'; } self::footer(); } public static function viewSubfileURL($fname) { return \PHK::subpathURL('/view/'.trim($fname,'/')); } private static function sendCacheHeader() { header('Expires: '.gmdate('D, d M Y H:i:s \G\M\T',time()+600)); header('Cache-Control: public, max-age=600'); header('Last-Modified: '.gmdate('D, d M Y H:i:s \G\M\T',time())); } private static function footer() { echo '<hr>'; echo '<font size="-1"><i>For more information about the PHK package format:' .' <a href="http://phk.tekwire.net" target="_blank">' .'http://phk.tekwire.net</i></font>'; } } } } namespace PHK\UnitTest { if (!function_exists('PHK\UnitTest\_phk_load_phpunit_interface')) { function _phk_load_phpunit_interface() { if (!class_exists('PHK\UnitTest\PHPUnit_Runner_PHKTestSuiteLoader',false)) { class PHPUnit_Runner_PHKTestSuiteLoader implements \PHPUnit_Runner_TestSuiteLoader { public function load($suiteClassName, $suiteClassFile = '') { if (class_exists($suiteClassName, true)) { return new \ReflectionClass($suiteClassName); } else throw new \RuntimeException("Class $suiteClassName could not be found"); } public function reload(\ReflectionClass $aClass) { return $aClass; } } } if (!class_exists('PHK\UnitTest\PHPUnit_TextUI_PHK',false)) { class PHPUnit_TextUI_PHK { public static function main() { PHPUnit_Util_Filter::addFileToFilter(__FILE__, 'PHPUNIT'); self::handleLoader('PHK\UnitTest\PHPUnit_Runner_PHKTestSuiteLoader'); $arguments=self::handleArguments(); $runner= new \PHPUnit_TextUI_TestRunner; $suite = $runner->getTest($arguments['test'],'',$arguments['syntaxCheck']); try { if (\PHK\Tools\Util::envIsWeb()) echo "<pre>\n"; $result = $runner->doRun($suite,$arguments); if (\PHK\Tools\Util::envIsWeb()) echo "</pre>\n"; } catch (\Exception $e) { throw new \RuntimeException('Could not create and run test suite: ' . $e->getMessage()); } if (!\PHK\Tools\Util::envIsWeb()) { if ($result->wasSuccessful()) exit(\PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); else if($result->errorCount() > 0) exit(\PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); else exit(\PHPUnit_TextUI_TestRunner::FAILURE_EXIT); } } protected static function handleArguments() { $arguments = array('syntaxCheck' => TRUE); $longOptions = array( 'configuration=', 'exclude-group=', 'filter=', 'group=', 'help', 'loader=', 'log-json=', 'log-tap=', 'log-xml=', 'repeat=', 'skeleton', 'stop-on-failure', 'tap', 'testdox', 'testdox-html=', 'testdox-text=', 'no-syntax-check', 'verbose', 'version', 'wait'); if (class_exists('Image_GraphViz', FALSE)) $longOptions[] = 'log-graphviz='; if (extension_loaded('pdo')) { $longOptions[] = 'test-db-dsn='; $longOptions[] = 'test-db-log-rev='; $longOptions[] = 'test-db-log-prefix='; $longOptions[] = 'test-db-log-info='; } if (extension_loaded('xdebug')) { $longOptions[] = 'coverage-html='; $longOptions[] = 'coverage-xml='; $longOptions[] = 'log-metrics='; $longOptions[] = 'log-pmd='; $longOptions[] = 'report='; } try { $options = \PHPUnit_Util_Getopt::getopt( isset($_SERVER['argv']) ? $_SERVER['argv'] : array(),'d:',$longOptions); } catch (\RuntimeException $e) { \PHPUnit_TextUI_TestRunner::showError($e->getMessage()); } $arguments['test']=(isset($options[1][0]) ? $options[1][0] : 'AllTests'); $arguments['testFile'] = ''; foreach ($options[0] as $option) { switch ($option[0]) { case '--configuration': $arguments['configuration'] = $option[1]; break; case '--coverage-xml': $arguments['coverageXML'] = $option[1]; break; case 'd': $ini = explode('=', $option[1]); if (isset($ini[0])) { if (isset($ini[1])) { ini_set($ini[0], $ini[1]); } else ini_set($ini[0], TRUE); } break; case '--help': self::showHelp(); exit(\PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); break; case '--filter': if (preg_match('/^[a-zA-Z0-9_]/', $option[1])) $arguments['filter'] = '/^' . $option[1] . '$/'; else $arguments['filter'] = $option[1]; break; case '--group': $arguments['groups'] = explode(',', $option[1]); break; case '--exclude-group': $arguments['excludeGroups'] = explode(',', $option[1]); break; case '--loader': self::handleLoader($option[1]); break; case '--log-json': $arguments['jsonLogfile'] = $option[1]; break; case '--log-graphviz': $arguments['graphvizLogfile'] = $option[1]; break; case '--log-tap': $arguments['tapLogfile'] = $option[1]; break; case '--log-xml': $arguments['xmlLogfile'] = $option[1]; break; case '--log-pmd': $arguments['pmdXML'] = $option[1]; break; case '--log-metrics': $arguments['metricsXML'] = $option[1]; break; case '--repeat': $arguments['repeat'] = (int)$option[1]; break; case '--stop-on-failure': $arguments['stopOnFailure'] = TRUE; break; case '--test-db-dsn': $arguments['testDatabaseDSN'] = $option[1]; break; case '--test-db-log-rev': $arguments['testDatabaseLogRevision'] = $option[1]; break; case '--test-db-prefix': $arguments['testDatabasePrefix'] = $option[1]; break; case '--test-db-log-info': $arguments['testDatabaseLogInfo'] = $option[1]; break; case '--coverage-html': case '--report': $arguments['reportDirectory'] = $option[1]; break; case '--skeleton': if (isset($arguments['test'])) self::doSkeleton($arguments['test'],''); else { self::showHelp(); exit(\PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); } break; case '--tap': $arguments['printer'] = new \PHPUnit_Util_Log_TAP; break; case '--testdox': $arguments['printer'] = new \PHPUnit_Util_TestDox_ResultPrinter_Text; break; case '--testdox-html': $arguments['testdoxHTMLFile'] = $option[1]; break; case '--testdox-text': $arguments['testdoxTextFile'] = $option[1]; break; case '--no-syntax-check': $arguments['syntaxCheck'] = FALSE; break; case '--verbose': $arguments['verbose'] = TRUE; break; case '--version': \PHPUnit_TextUI_TestRunner::printVersionString(); exit(\PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); break; case '--wait': $arguments['wait'] = TRUE; break; } } if (!isset($arguments['test']) && isset($arguments['configuration'])) { $configuration= new \PHPUnit_Util_Configuration($arguments['configuration']); $testSuite = $configuration->getTestSuiteConfiguration(); if ($testSuite !== NULL) $arguments['test'] = $testSuite; } if ((isset($arguments['testDatabaseLogRevision']) && !isset($arguments['testDatabaseDSN']))) { self::showHelp(); exit(\PHPUnit_TextUI_TestRunner::EXCEPTION_EXIT); } return $arguments; } protected static function doSkeleton($test, $testFile) { if ($test !== FALSE) { \PHPUnit_TextUI_TestRunner::printVersionString(); try { $skeleton = new \PHPUnit_Util_Skeleton($test, $testFile); $skeleton->write(); } catch (\Exception $e) { print $e->getMessage() . "\n"; printf('Could not write test class skeleton for "%s" to "%s".' . "\n", $test,$testFile); exit(\PHPUnit_TextUI_TestRunner::FAILURE_EXIT); } printf('Wrote test class skeleton for "%s" to "%s".' . "\n", $test,$skeleton->getTestSourceFile()); exit(\PHPUnit_TextUI_TestRunner::SUCCESS_EXIT); } } protected static function handleLoader($loaderName) { if (!class_exists($loaderName, FALSE)) { \PHPUnit_Util_Fileloader::checkAndLoad(str_replace('_', '/', $loaderName) . '.php'); } if (class_exists($loaderName, FALSE)) { $class = new \ReflectionClass($loaderName); if ($class->implementsInterface('PHPUnit_Runner_TestSuiteLoader') && $class->isInstantiable()) { $loader = $class->newInstance(); } } if (!isset($loader)) { \PHPUnit_TextUI_TestRunner::showError( sprintf('Could not use "%s" as loader.',$loaderName)); } \PHPUnit_TextUI_TestRunner::setLoader($loader); } public static function showHelp() { \PHPUnit_TextUI_TestRunner::printVersionString(); print "Usage: php <package> [switches] [UnitTest]\n\n"; if (class_exists('Image_GraphViz', FALSE)) { print "  --log-graphviz <file>  Log test execution in GraphViz markup.\n"; } print "  --log-json <file>      Log test execution in JSON format.\n" . "  --log-tap <file>       Log test execution in TAP format to file.\n" . "  --log-xml <file>       Log test execution in XML format to file.\n"; if (extension_loaded('xdebug')) { print "  --log-metrics <file>   Write metrics report in XML format.\n" . "  --log-pmd <file>       Write violations report in PMD XML format.\n\n" . "  --coverage-html <dir>  Generate code coverage report in HTML format.\n" . "  --coverage-xml <file>  Write code coverage information in XML format.\n\n"; } if (extension_loaded('pdo')) { print "  --test-db-dsn <dsn>    DSN for the test database.\n" . "  --test-db-log-rev <r>  Revision information for database logging.\n" . "  --test-db-prefix ...   Prefix that should be stripped from filenames.\n" . "  --test-db-log-info ... Additional information for database logging.\n\n"; } print "  --testdox-html <file>  Write agile documentation in HTML format to file.\n" . "  --testdox-text <file>  Write agile documentation in Text format to file.\n\n" . "  --filter <pattern>     Filter which tests to run.\n" . "  --group ...            Only runs tests from the specified group(s).\n" . "  --exclude-group ...    Exclude tests from the specified group(s).\n\n" . "  --loader <loader>      TestSuiteLoader implementation to use.\n" . "  --repeat <times>       Runs the test(s) repeatedly.\n\n" . "  --tap                  Report test execution progress in TAP format.\n" . "  --testdox              Report test execution progress in TestDox format.\n\n" . "  --no-syntax-check      Disable syntax check of test source files.\n" . "  --stop-on-failure      Stop execution upon first error or failure.\n" . "  --verbose              Output more verbose information.\n" . "  --wait                 Waits for a keystroke after each test.\n\n" . "  --skeleton             Generate skeleton UnitTest class for Unit in Unit.php.\n\n" . "  --help                 Prints this usage information.\n" . "  --version              Prints the version and exits.\n\n" . "  --configuration <file> Read configuration from XML file.\n" . "  -d key[=value]         Sets a php.ini value.\n"; } } } } } } 
a:12:{s:0:"";s:42:"D  FTREE;AUTOMAP;STATIC;OPTIONS;BUILD_INFO";s:8:"/AUTOMAP";s:17:"F    î  î  ª  ";s:11:"/BUILD_INFO";s:17:"F    ´   ´   Áb  ";s:6:"/FTREE";s:17:"F    ª  ª      ";s:8:"/OPTIONS";s:17:"F    
  
  ·`  ";s:7:"/STATIC";s:20:"D  tabs;phk_logo.png";s:20:"/STATIC/phk_logo.png";s:17:"F    i<  i<  N$  ";s:12:"/STATIC/tabs";s:45:"D  left.gif;right.gif;bottom.gif;tabs.css.php";s:23:"/STATIC/tabs/bottom.gif";s:17:"F    #   #   s  ";s:21:"/STATIC/tabs/left.gif";s:17:"F    Â  Â    ";s:22:"/STATIC/tabs/right.gif";s:17:"F    
  
  Z  ";s:25:"/STATIC/tabs/tabs.css.php";s:17:"F    ¸  ¸    ";}a:26:{s:0:"";s:10:"D  src;etc";s:4:"/etc";s:26:"D  license.htm;license.txt";s:16:"/etc/license.htm";s:17:"F   )  )  SP ";s:16:"/etc/license.txt";s:17:"F   ^,  ^,  ðy ";s:4:"/src";s:8:"D  Phool";s:10:"/src/Phool";s:118:"D  Debug;Display.php;File.php;Modifiable.php;Network;Options;Persistent.php;Time.php;Util.php;VarContainer.php;Web;XML";s:16:"/src/Phool/Debug";s:14:"D  Counter.php";s:28:"/src/Phool/Debug/Counter.php";s:17:"F    !  !      ";s:22:"/src/Phool/Display.php";s:17:"F    r  r  !  ";s:19:"/src/Phool/File.php";s:17:"F          ";s:25:"/src/Phool/Modifiable.php";s:17:"F    Ë  Ë  6  ";s:18:"/src/Phool/Network";s:9:"D  IP.php";s:25:"/src/Phool/Network/IP.php";s:17:"F        iB  ";s:18:"/src/Phool/Options";s:32:"D  Base.php;Dummy.php;Getopt.php";s:27:"/src/Phool/Options/Base.php";s:17:"F    ¹  ¹  ôI  ";s:28:"/src/Phool/Options/Dummy.php";s:17:"F        ­U  ";s:29:"/src/Phool/Options/Getopt.php";s:17:"F    ÷%  ÷%  3]  ";s:25:"/src/Phool/Persistent.php";s:17:"F    	  	  *  ";s:19:"/src/Phool/Time.php";s:17:"F    c  c  3  ";s:19:"/src/Phool/Util.php";s:17:"F    I  I    ";s:27:"/src/Phool/VarContainer.php";s:17:"F    %  %  ß¨  ";s:14:"/src/Phool/Web";s:20:"D  HTTP.php;JSON.php";s:23:"/src/Phool/Web/HTTP.php";s:17:"F        ±  ";s:23:"/src/Phool/Web/JSON.php";s:17:"F    ¨|  ¨|  ¼  ";s:14:"/src/Phool/XML";s:12:"D  XPage.php";s:24:"/src/Phool/XML/XPage.php";s:17:"F        79 ";}AUTOMAP  M3.0.0       3.0.0       1518    37dbdde720      1448    a:2:{s:3:"map";a:6:{s:11:"Phool\Debug";s:70:"a:1:{s:20:"LPhool\Debug\Counter";s:28:"Ssrc/Phool/Debug/Counter.php";}";s:5:"Phool";s:374:"a:7:{s:14:"LPhool\Display";s:22:"Ssrc/Phool/Display.php";s:11:"LPhool\File";s:19:"Ssrc/Phool/File.php";s:17:"LPhool\Modifiable";s:25:"Ssrc/Phool/Modifiable.php";s:17:"LPhool\Persistent";s:25:"Ssrc/Phool/Persistent.php";s:11:"LPhool\Time";s:19:"Ssrc/Phool/Time.php";s:11:"LPhool\Util";s:19:"Ssrc/Phool/Util.php";s:19:"LPhool\VarContainer";s:27:"Ssrc/Phool/VarContainer.php";}";s:13:"Phool\Network";s:64:"a:1:{s:17:"LPhool\Network\IP";s:25:"Ssrc/Phool/Network/IP.php";}";s:13:"Phool\Options";s:134:"a:2:{s:19:"LPhool\Options\Base";s:27:"Ssrc/Phool/Options/Base.php";s:21:"LPhool\Options\Getopt";s:29:"Ssrc/Phool/Options/Getopt.php";}";s:9:"Phool\Web";s:546:"a:8:{s:15:"LPhool\Web\HTTP";s:23:"Ssrc/Phool/Web/HTTP.php";s:30:"CPhool\Web\SERVICES_JSON_SLICE";s:23:"Ssrc/Phool/Web/JSON.php";s:31:"CPhool\Web\SERVICES_JSON_IN_STR";s:23:"Ssrc/Phool/Web/JSON.php";s:31:"CPhool\Web\SERVICES_JSON_IN_ARR";s:23:"Ssrc/Phool/Web/JSON.php";s:31:"CPhool\Web\SERVICES_JSON_IN_OBJ";s:23:"Ssrc/Phool/Web/JSON.php";s:31:"CPhool\Web\SERVICES_JSON_IN_CMT";s:23:"Ssrc/Phool/Web/JSON.php";s:35:"CPhool\Web\SERVICES_JSON_LOOSE_TYPE";s:23:"Ssrc/Phool/Web/JSON.php";s:24:"LPhool\Web\Services_JSON";s:23:"Ssrc/Phool/Web/JSON.php";}";s:9:"Phool\XML";s:62:"a:1:{s:16:"LPhool\XML\XPage";s:24:"Ssrc/Phool/XML/XPage.php";}";}s:7:"options";a:0:{}}GIF89a	 ,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    	 , ÿ@P±É`H$!%Cq Ve2X­ÌJ(Ä +32$ÀÆ ¼kvä-Ëçõu*"}ã|}|~q("$f'l(&&$r&! )¢¤{¨£¥r­ª°©¯±¯¬´¦·»º³®«§¾¶ÃÂÀ¿²¹ÇÄËÆ²ÌÉÎµÒ½Í¼ÔÈÓ×Ð¸ÙÝÕÏÙÊâÜßãçæê¾äÛÅëÇíáîÖìéïøñ÷õüÑðåùü¤Pß?ÇÛBmåAÎáÀ%VÜî!Çk÷Ø/áÄ;^¤¨²$Æ#Mf)fÍ(WÎLæKçÒ° I)L:eD¡Cµ´x*4U¨h 
%A«£^ÁNKb¬Ùe§X± ´k»x!ÁÖí2tÝÖ	 !¯5tÛæéÀ]$¬´%Xíâ.i[¬]Y­ÊfEëõkg`µ:zëçÒ;£}ºµj×aaM¶é×¸cç½»vïÛºóî8ðáÈ'?®¼9óç©G_>Ýyuè¬_ß]zwêß­Ç¾º¼mîæµG~½ûôÞá/>ùööÙ«Ïÿ¿ÿýÿÅà|ÖWà} v ;GIF89a,Õ  ö÷ùñô÷öøúüýþúûüùúûøùúêïóïóöÆÕßÒÞæØâéÞçíÝæìåìñèîòô÷ùóöø³ÈÕÁÒÝËÙâÏÜäÖáè´Å¹É¯ÂÍ»ÎÙÃÔÞÂÓÝÈ×àÌÚâÕáèÙäê×âèåìðëðó°ÇÑÞåÜæëãëïëñôîóõ÷úûûüüÿÿÿþþþ                                                      ,    , ÿ@pH,È¤rÉl:Ð¨tJ­Z¯Ø¬vh<¬pkL.Ïè´zÍn»ßð¸|N¯Ûïø¼~ÏwVa+ *)^,*ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃ¶)'ÆÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæÚ¥("ðñòóôõö÷øùúûüýþÿ 
H° ÁòK"RHH±¢Å3jÜÈ±£Ç CI²¤É(Sª\éÅu&@ Á²¦Í8sêÜÉ³§Oÿ(Â±DÐ£H*]Ê´©Ó§P£JJµªÕ«X³jÝÊµ«×¯S84± hÓª]Ë¶­Û·pãÊK·®Ý»xóêÝË·¯ß¿Ó} âDÌf(^Ì¸±ãÇ#KL¹²åË3kÞÌ¹³çÏ Cm¹ðCÄHXÍºµë×°cËM»¶íÛ¸sëÞÍ»·ïßÀN÷ÃJ Á®¹óçÐ£KN½ºõëØ³kßÎ½»÷ïàÃO¾<v1+_.³½û÷ðãËO¿¾ýûøóëßÏ¿¿ÿÿ (à_YÉ@Ár5èàF(áVháf¨ávèÿá (â$¨a¤H,¶èâ0Æ(ã4Öhâ	*¨"<öèã@)äDiäH&©äL6éäPF)åT&©\;V©å\véå`)æZ^%	d¦©æl¶éæpþhfqÖiçxæ©çsRæ*è ÂÙç&ªè¢6:ä¡F*é¤Æ	i¥fªé¦O^Êé§ Ê©§¢jê©êª¬¶Ê¦ª®Æ*ë¬SÂJë­¸æ*¤­ºöêë¬¼þ*ì°¥Kì±ÈVjl²Ì6è²ÎF+-ÐNkíµkVí¶Üv©m·àÛ©tkî¹Q~ÿîºìò¨n»ðûn¼ôr;o½øN{o¾ü2»o¿ ûoÀë:pÁK®	7íÁGl*ÄWü)Åg)Æw)Ç¬(È",(É&§'Ê*·léÂº,3¥,Ïl35ß¬30ïìó³=ÿ,t 9m´E­´A/ítI?-5QOm5U_=uÖZ?Íu×KöÑb=tÙfÿvÚ;¯ÍöÍn¿=sÜr»LwÝ*ß·Ézï-rß~{xàN¸Å.qâ;Ìxã	?yÁOpå÷yæùnÎy½oè¢·Kzéëú¹ª¯.në®{ìö6Mÿ»Ö³ß~mîºëk{ïRó¼³ÂïïïÆ+]|òÇ.Ï¼ÀÈ?/´óÒûJ}õG½Î×ok÷Þ+%Ãá«­}ùv~Þê¯ÏwûîÿüÏOáößxþú/Îÿû #'ÀR®¼¨¹2°s| è"(ÁÑQ°¦» S§Á²®|C(»°vãÙ		ÂF|.dc82ÒPZ3¼aªl¨Ãfå°Dã!õÃ!ê©F¤(,$2±NN|¢¡(Åìµ°L!¶ÈÅ.zñ`£ÇHÆ.zaH£×ÈÆ6ºñp£çHÇ:ÚÿñxÌ£÷ÈÇ>úñdÇ@ L¤"ÉÈF:ò¤$9  (8&ÉÉNzò ¥(G©FB^²!Ë¨ )WÉÊVºò°l¤)1wÄò¸Ì¥.wÊYºäà¥0IÌbó¾|ÉHpÌf:óÐìepJ±}È¦6·ÉÍnzóà§8û0 Â%"¸æ8×ÉÎvºóð§<ÉPÎQ`ò%×$>÷ÉÏ~úó ¨@JÐô M¨BÊÐ:ô¡¨D'ZPKF Ö¼&16ÊÑzô£ ©HGJRb ÷Lç5ÏÁÒºô¥ÿ0©LgJÓ#(e>¯Óúô§@ªPJÔ¢õ¨HMªRÊÔ¦:õ©PªT§JÕª&5;%U·ÊÕ®zõ«`«XÇJV«ÂC§ÑjY×ÊÖ¶ºõ­p«\U´À¦xÍ«^÷Ê×¾úõ¯ÐÀi)$ô°M¬bËØÆ:v,à²Í¬f7ËÙÎzö³ ­hGKÚÒö´¨M­jWËÚÖºöµ°­*$ÛSPô¶¸Í­nwËÛÞúö·ÀÅm + â¸ÈM®rËÜæ:÷¹ÐE®?±9ÏêZ÷ºØÍ®v¿9î"ºÛ¯xÇKÞòbÑLÿ¯z×Ë^A¢·½ð¯|ç÷Ò÷¾øÍ¯0í«ßþú÷¿¡ä/Là»×ÀN°ï(à;øÁ	n0'LaýJ¸ÂÎ0{/¬á{Øþ°G|ËøÄ(¥SÌâCrÅ.±	ãÛøÆv¬1wÌc6ê¸Ç@ÞñLd¹ÈHNñÌd/¹ÉPÎð£LeO¹ÊXp·|â+sùËýõ2ÇL_1ùÌí53×M5³ùÍÇt3ç¼_:ÛÙÂwÎsõÌgøÊ¹Ïp ýÌ?úÐ/F´¢ë¼èFãÒÐt!-éJãÒÎô1­éN»ÓuÿA-êPºÔ>5ª3­êUWºÕ®4¬cÝèYÓZÑ¶¾õ¡s­ëAóº×þ5°ù,ìaç¹ØÆ¶3²=çe3ûÍÎ~ö£-í3S»Úc¾6¶¿¬ímo¹ÛÞÆ2¸ÃMåqÊæ>7Ó­n$³»ÝD~7¼,ïyó¸ÞöÆ1¾ómã}óÛÈÿvµ¿Þâ\É/µÁNâ3ÜÉ÷´Ã#ÞáS\ÊguÆ-mñO¸ã0ÈC¾à\Ë'_´ÉS^à³|À.ùc.ó0×Ð4¿9~s®ó=÷¼Ï<ÿy|.ô4]ÏD?ºz®ô67]ÙO§3Ó£ÞÌ©SÄWvÖÙl>õ­3Úëdî:Øu)ö±?ÚìÙF;Ë®öW²½í­|;ÜW)÷¹²îvtÞË½w¾÷Ý|à×=xÂÞÝA  ;GIF89a    °Ç   ,       D ;<?php
//=============================================================================
//
// Copyright Francois Laupretre <phk@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================

//-- We must change the returned mime type (default is text/html)
//-- And we must do it before any output

header('Content-type: text/css');

//=============================================================================
?>

/* tabs styles, based on http://www.alistapart.com/articles/slidingdoors */

DIV.tabs
{
   float            : left;
   width            : 100%;
   background       : url('<?php echo \PHK::subpathURL('/section/STATIC/tabs/bottom.gif'); ?>') repeat-x bottom;
   margin-bottom    : 0px
}

DIV.tabs UL
{
   margin           : 0px;
   padding-left     : 10px;
   list-style       : none;
}

DIV.tabs LI, DIV.tabs FORM
{
   display          : inline;
   margin           : 0px;
   padding          : 0px;
}

DIV.tabs FORM
{
   float            : right;
}

DIV.tabs A
{
   float            : left;
   background       : url('<?php echo \PHK::subpathURL('/section/STATIC/tabs/right.gif'); ?>') no-repeat right top;
   border-bottom    : 1px solid #84B0C7;
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none
}

DIV.tabs A:hover
{
   background-position: 100% -150px;
}

DIV.tabs A:link, DIV.tabs A:visited,
DIV.tabs A:active, DIV.tabs A:hover
{
       color: #1A419D;
}

DIV.tabs SPAN
{
   float            : left;
   display          : block;
   background       : url('<?php echo \PHK::subpathURL('/section/STATIC/tabs/left.gif'); ?>') no-repeat left top;
   white-space      : nowrap; padding-left:9px; padding-right:9px; padding-top:5px; padding-bottom:5px
}

DIV.tabs INPUT
{
   float            : right;
   display          : inline;
   font-size        : 1em;
}

DIV.tabs TD
{
/*   font-size        : x-small;*/
   font-weight      : bold;
   text-decoration  : none;
}



/* Commented Backslash Hack hides rule from IE5-Mac \*/
DIV.tabs SPAN {float : none;}
/* End IE5-Mac hack */

DIV.tabs A:hover SPAN
{
   background-position: 0% -150px;
}

DIV.tabs LI#current A
{
   background-position: 100% -150px;
   border-width     : 0px;
}

DIV.tabs LI#current SPAN
{
   background-position: 0% -150px;
   padding-bottom   : 6px;
}

DIV.nav
{
   background       : none;
   border           : none;
   border-bottom    : 1px solid #84B0C7;
}
PNG

   IHDR      X   ø!e   bKGD ÿ ÿ ÿ ½§   	pHYs        tIME×00Eÿ?    IDATxÚí½i¬$Ùu&ö{o,¹¿ýÕÚUÕÕì}å*îwÔÆI3Ð,6 Àðÿ¶X2,Ã²Ûð Éc${ÆÚ(5)J×^ØÝd5»ØK-¯¶·çÛ½÷øÇÌÈå½Wìn5î,^FfDd,_{Îw¾s.áu¾F³ØºÉÞk/jP¥JµF­ZÎz> Âqò3ñ¯zØÜÍ2$iÌYkìê1Á+Ä*Y!aX <üODxëõ·ëõºîÖ,·oØÖËôDôwo\µhïñ==ö.Óþ# / -Ââ
ayM ¹HªºÙ\¤íFºÂnàRãz<à­hnq\©RºzôñÓd×ñ|02  óÿ3SgÏ.óËÙFã=û5ý3OýnílYÙü&ÆïË/ åAH¨T	µ&ñÒ*aqEp£(E=?Äz6-lVkÔz:Ã$æ«ñ ÛYÂ©¶)^?IÉÚI¡d=,"b ú-kø#.fö/¾ xéyý/|Kÿ'_}2[èí3ña@óÝÔAÌ %åH$ÂèVÖ×°BìTª´QmàZ¥F{¾(¬Õ¯Æ¾¤3Úq²°DÙÒÅÕ:ö)«7`Ã
Yé!&B@[CûHàbæð{Ïeïú+úW?óûñ;¯]²y>¨ælúýËDÎ@­AXX!n-­ÖA´a+uÚ²/y>úA¸Ö$-$6=¼jÚaÑÂ2e*öÃzÍe$+UëÐJ¡ äÃ²%"~N? ¸9üîÓÙÇþúÏÒ_ùÜÄìm³ipøxäu_È³ãÿnH®7	õqµVZ¸± á:[Üò|t+uTkd	_µ»~@ZQXÅ@*t-ê¯GiÒj± èè­áÿ¬ X×^N>þ¹ßOÿÏÿ?É£{Û¬õ«^ÈÂÃÛÉuæ®?sxDî½n(+@P!àzÃÐX])±ïhÐ¡íûØ	ªØH¸ZGoõ8v×O¡»´FI"%BÀ~ÿAÇt`}çöO]xÚüøÛæ±WØc;ÿÑë¸Ù·³|ØºG>x¤eÒ
ÀHI

ðp­A¶Ú !A
dB¢ëyØÚR"?Ä~µJ?@V`[Ë´·¼k'Ði."Q>p9¡þQé0`=ûìþO=õÔî/_øïíßýªïõ»ãÍ@µÁh.[! 3,ÈR@g££	:ÙïíZ³Ûgìµs:¶4#ÖkØ°VØó åQWl	²°»°HJºÖ0èæ"Ìò::\n.`¯Ö@T m!pÀ ·Ù¿!ÖOÞüå×¾?¶ùâ¢¿ùZ,s¡ïýÀ¢²²ÔoBSÂ³ð$y¤àIJäØXVÉL"¥² SBL0nc¸}~Þmìß¾uÇÉ®Q¡R!¬ ðDli¾ò`-Zm?Äï#©Ô­GZoa#¬âF­¨µA½Dy¸E× ´HÿPÀÅÌásÏµ?ñä7ÿ«¿þ«ÍÇªåí½²rÃªg@Í°i~×Â I¡2@jÐÊBJ$CÎýá@P
_yð½ ¾ Á
d=°ñÁÚÉ$²T KiB¹u$Xíh·×3ü¾jÍ°Þû ò°,Aù@+% <pX¡g-zB@Uèæ"t¥Îâ
¶NÇKçïÇ×Æ3Já*ì°r4XÁºýâoþÊ¾pãkW7'°ùý&Ãi ì"m¾S'[íó¸yY9ÿ,,KÃÏ42XÊ ÊÀ"DÈ,R@dÒ¤	·	@I)$P¤à{BßGàð½ ô bdñÀh4&¤±¢ÓX KØÐ¡nîgX§d·;ìÎ'ÿ
:(öCØ0Ä ±í3wáÖ}áÅÞ³´' ä3Ë»ïýÊ_oÿÆüÉÆÛ··êÜ¹
Ò'píÅ´>ÄÉºr¼t÷;ìæI\}YÌ¹<zë(Xó÷ 0ãð=È8 "#)°L`E#z iABB@B
"/aø ¡À÷<H@Ø Â Öw1È"4vï&°%0S~Ír÷CàQë7dsA@. 	BØJÉwáÖÇ~ùÀ;ð«õ]þAÁ¥·nÆ§¾ýìÞ/}þó×ß±½=ZgP*DÊ10ÀÃâ®jiÙB(ÒË`víáçünàoKãÍcK0Âå1Ñð-¹­aò0zG*ö±'¾®æ/;jA¡¨È^
ç)T0@¥å@XU<QDÁ­Ö
:ñ c,QÐ5kr0ZfBñ0ã¢x­G>ã»Ñ6ùös·9hÌÎ Az¨ìïàÌåøûü4µ]ú×.k­úÌ¿»þà÷¾×þÙë×{RëÆ¤°ÖäÁ.;0äà2¶F'0¬ÝQYÕ¬m ø² <Z.r|BUûÝñåCùz;ÐÕ*!Î¯>sënd	ÁR	J0@>bhJò.bÜ	 " ¾ï9 O91PøTä
È +°ñaÒ &ñaR£Ø
X-a áx¤ÂyS"£3+r&È&Ày0C è´³à~ÜÜÀ?oïrXoâÿêö²*±¿®üóßúÖvEëZ§06óÐM<iS `[¬ã,Oþ «7s¿ó¬ÞÄ2Àâ Ëà© «§plmÛ»UØDBñÄpÅ2#Æ.®Ø?Ff9ÅTxõ£Ñ]B "!¹FÎ¯d´|À÷à/áU	ò¨*|Qd}­³Vû°Z5*¯ÀV(rf}Èü®?Ý6È  KA_kA_ûÿmkùO s»¾óÂþÒÆÆà}ÛÛXl­;X\ÆfXÜXÈü*3>b ÅýÎJ óÅç~ÏS'zMÈg6ØA7³ 8Ó|v÷NèTÉYÃ Ñ)¬N`	4b¸®½¯ÓQRÁ£:¤PÁSR
HEð=¿âÃWÆ x!ldB°ñÀVº¿Æk·£s! 0)é}'WñÏ>ò3¸ÁÌß8j$©  M­×d]¸°{Në$ÉáÿxÁ[2ÛÃmÆ¾ÒÁ KÁ´:¶ð¸ +`dyPÀ`hDPÊÃbãUGôéHðHgúD¤ ¬ß@«qÍV½¶eoDß¨¢ÁÈÿjîÃ²Alw`ÙBÀÊò*Zñ{`LÂ"F}ÑAÄ¼.¤$(%¡J)g½A5¢D¾ómÓ©Y6©I¿ñåÏà®Õuügøi|7Ï\×¯êYf>ùÂw¶H1°ò+Øiÿiêùv¹µ³9<VaÎvea(hÚûQÇÛÀ0ê@M=tüPkÔ¨:¤¥Õ ÁSC~yx.IË5ZU¢â7Ð¨­ Á:ª¥èx1 çÃUÃ[=±^ ,ÀÈ#9EÆlê§°¥C¦5d3EBÅ¯¢Nw­SÐ(^¤Z!Ï ë,ÃdÞÖÞAø/áÇú1<ÎÌ;õR ðüóÛáÆFïvT»b«iÿißUÂÀ_gÜÀ¹ ;êP
@°AAÁo"LáÕ»`#IúH³B
X6ÇVrò8HR¹5ç2°ÕHR£L+È}È A
	
êÕeÃÊ×`R÷\¤K`Î¹'}_9Uó^¤&g°Á$)l¢ÛZËø- Ù[5%"iº±SÆÇÂs¹ÑÁàbfüöo¿èu:ÉYc&5¶^#ÿi%Åýq¾¦,Ýhf·ß!Ä³ûã$áÝdiÙ\rÂç*¬04¡ÀCwÅ;:3¾1¨õziu¨Eò¤(:A¹§Z&AFDP¢.#+`Ëèö:¨ùÉ(¢&J4 ËÙÔÍõdfuÕ°
ºëç¥2>©áõÔ@ûjÇ¯B!l¿ûdc v÷P{þxìÑÇ= ?j´(±Þ$° Ä(EneÈãgÍc|ÒÃRÍÕÕBÀº\£Õ
lÌ'²:Ï3¦ñ ÈR	d:cD)Å°aöès|®«kýÔÏÝÿY¯qâ/úý´föÎë×âüÆ×;ç¯_K$hCåDvØÎ¹ÄU1!PMØ`ûH¾KUåâø/b ª£JP2@£ºÐo"bf4Ô)nMØnï`¥ºêSYAtýîúþwðAf~á0¤¸×%`1ça,/ri8+ú&<¦£<Jòèûû¸ã}Öèñ5ÌkPB@)¯ +ÁLRB	|4Tvÿ®~ß+È£ã1`iGA3Ã²-û\sXnbF½%Ì»ÞµöwÜuüáÊE½[1º4uÀ²Öíßpf¼Ï©k5~($`$YZ§È2	i>¬Òõp¹¨q<DÁ2òBÕÉR03tU:rDAàf;÷e5èwiùÒEÜÿ" 
.¥°§5¼]ybf>­0sáÂQîÐ@A£Ú;=ìíßÈ@9Rý@
Ïð=ãk«8·²zÙeãñuçÈ°Ö@H;óiôMÆ`çÜd[[ÉúõëýO>õÔ­»66veC`YGD¾tNó0Q0ûØ ÖmShÙÂùÁÐ\lÕ±~ò2`sknpjé,äÞÃ°©f²@´L¬$HW`)ÊÓnå Ä}V{[8ÆLÇ \:\äyBãLTXî	'ÁtDîcäÆÎú9ÛòTJÁa0ÛâRDÂC-ÌÀu;Ö³ÅÒZ.kÖZHòÁ´G2iS Ðí¦rs³W¿reG¤iX CP¸Î}âþÆÃó/]"$·zÆÂÈ1³Ì¡ÕÀ=÷,î?øÄýZí½NÛü/iï´M*Û!´©¸u £BÂm®G¨AÛ¤Ð`ø4ºmú=Ðî6V­ÁéÃÀ% À÷¥§µ»q4r®CÇÐJqas²u8þz×Øv<¤ÎPò%)(¢hi>>0çù½å²ÈE[ RP>ÖÂr² 1&âëÌº¬áuÐÆÅYûãáÅ ±XæÇÆÐÚºD<ñìcÊßV×BýwþÖã?þ¶7u¯k§}Ìwk}Î9gò%jH³ä¥åÛo&À úÞ6äÐÒÔLÅ$3ÒÜòÇçÜ2,×ATUðô:â*¡:W@¸¿$ )<@QµKäÒf²yZhhí,3µ eKÔÂ<²7MI& ªVº¾O%`¯Ö¤L1ÒÜDµ³b
Dªä§ÖÂYÃ£6½mnnß´ÿäÙowåþlïäKKêJ»ßfº­D¹â*$CÃK`Ø:*ªèÏ2ÃZZÞxÕYðCÅ $1SÀrï©W<(ÏçþÛ)3IEL
xz-'rÑ'hø íä^æ¦Äå¶WRkÄÑ¥â,µ$í81&Aß Q«)ãy3eD G&|&Í1âÒ»î|H³§ç*"Ö _°þÞ6î¢ímÝ)ZúÄÙØâ`*CÊÓ`ØL­¢*º±\gÿ¶tÆ+7®â3Äø\8ÖSÀÂ]kxêÉ}yä"wè#ÇÎ=å¹/1JQYæß|;ûÝò~æàòvXÌcpÛÓTIÂ´}×ÁT)!)§`Ê£C¡ôNGs½³Ì3Ì?ÁÂNølÅ` ê1®¾BP +x¨"@M7.©EApT¿@ä!ÛO0è·Á^ßiëJ c"DÈÝMÔ %dÖ°èy¢>d!¥µ13ò3@ç¼ZæQ´x¨å,æT	¾JÇF)K0Í§° Îz;Úv®â@4 }æ_'ï_©5dºwim¥wÅ eáÔ´SXÒye_pÖ¾s_ÇeÅèÚGqv÷ÖeË±"ÍçÆ&>³°¹µ[×¿&OÜ}ÝQ²	V¯ßíïb	 e Z.¥Dc0È&cW&K0ºìN_	G:?{d÷AËGæLg[ ç4 cí(Ï6Ò«ÍúÙ0ÿF¦.>¯Ï+%
ir
õRÔûªûÀNGÀ18í[8§c+Å)DCO¤wMè@²¨ä>8§u`qD\P·ïîzû¸#ËpæPp	A#Ë5òI¡¤SQÍû\CU¬;ÜrÍå9Â¢~DýWY½À("mhñPpèÇtÄPJÍ#AG±ïÅ¤åµ0èsi.I¸9Î`ìøx
j	ìaºÙÂËf§
²)
!¼TÁÌðl@5`ç×Ç]8 ô2°ö¦×,¢jÛ×Ñ8Ô¡^/£"°rru®C}®¿1ÌÆÛdÎs#Y	î 8}¿bQmh(È S[Ö0Äì>J¡úíªg'"Óy¾ß¼hMÀwjaºJ[@FÃlíÑ¬Òë0H%WXèt µ±bdý8B=H¡£êÁÌÐ+¾Ïk[úC-WXTùMÑGð¹Fªq8D$¢çzæP
@ÖöQ¹ã:üÎk$L¡ýÊ¸gÖ`¶°ÈE9õíçsnêÑ]HåCãØr±s"Umè"hËë$YËÏ#hÔC(
ÐOÍº ,w'ýj!J£	a}ó:Î%v.¸PF#0 ¥ [Å~PIAÀcUE(FrG.ÏÒtæwgk§ïw¿#;8¶^Ç}÷Ã1ÚqVJo¹Ü"ÙäjÔùRk¾É¸íxy=¦YÖ,³°®è¬0SQ;¦$C¬«éw>vZ_ßÃgÙåIÁ03`0· dÐÚßA@®½À4C¯/­-¡ó1´á)fy¡/0íy&hL¢À2O2ê}Ð¾¸@·Y,.VÌãï;÷ê?þï|õôÉ¥lxãÆ¼ç¨íw:#qÔãÃAÇ>Ú³\Ãã²ÖÂØÔ3¶ºNîß-{ÊÃÝçN>ýwøÊ/ý§ïùw¼ãäv%TSÀiªÁª;É3ºûLqO0cu®Ïeµ,ÜÁ/¼Î¶º¬?$¸5â¹R 1ø)B£4Z4ÒsYXèü¯Ñ.;ÏLãÀa¢þX`}­©ßñcõ§?úá»÷ÇÞ}záOþèµ_&¢¥2°ÜM´lreÄmAÏ9V{ÖoH«o¤)¼À xLÁÐáû¼åVÓ³O¼ÿÎù4ÿ«+õNà«Fk!üx¯å*4õrmÞ´¢³Ï4Ð$Æê¼£Ê2­YpQ"!Ïå*µáZøÉ^.ãÀ!èL^lÀ)!û õm\éR(ÿ»²1kóúC®,Ë°Ð)A«@~àÌSïy|á·Îß¹üÙzÝ¿WJú%Ç	ú¡Û°	ÈÐÇxïæK~¦%7¥ýÐðÜhtýqf8féçÉ¦½s@Ø³g[WßvúJ§T´±ßk6ü_ a,#ÉzNÕÝ¥¨æÍ®Ïµ\I¢IkëUã¡CIg«'ÒóV:ô\ÐÐãð¨Nkukï.%ßÎë%¤PRBI	)Ü2å¡ Êõâúé¾ïÞµ§îyàßzàáæçî½gµ ­õÆéqTlØ¤Ît¨OGUÀ4Æh÷¿,Ki&7MYúáðÝÄXuþÐ9ÀzitÛÌD°A £J·µNkxÿ{qA,Sþµkøôµ×øÄ¼Qij¼I`Bº¡Íg89Î·§<a'Ùé¨Ë$ÑèèGk¸2lÖ+¡z8çrvê®æS¼=ø­ZøüùsËm"bfÃP%ÿLC`qÎs9M×E²ÍmëÛPÒck:®t*Zbýönz°<1LN.=Ì23QÕç|çÒG,ÛËRÐÞ6B ÏíÕêÍ » /­Ûëc5LµË@4Àòæ5^vYÊi¿ê÷3J]KóÉmÅÜâ¬/3
¥®Òl^Nqfúèö^C/´ªæñÿèÜÆ»Þ~ês'N´þÍù;¿uþÜr· ÃMj5/¡¡æ±à[kAÎ°\3@ÆÖbko¯ô	äU×ã<"WÌ*,´ê8½þ´·WaSÌTDPÊ¥7cp¥©ô'*×oæà"ù)öwìZã? ¯¯¬Ôº¾/{ÌX*Ëá ßá-E`4G:²¢Ýk³ì¶© 1ª~?CJX¹ÊsUg;u ËmËý`¹fêÔyX1|4pËUóáÞõÝ}äß8{féÏÏ]Üm5+éNjU/ñ[#ËæQ(Ò8¨|.MûÑ`¦¸@F8½$Ã
¢@¤<ÙÃìÃ@DLèÎ¯ýþ§ç_ç¤ùxkÈ½¦/3ÀÌÍ²ìï01óÝÌ8à)põºÅ®Bi.D|Ã=#R	²!ûM<Ö©$ÓE¹nÓxµ¡ýØGï¹øÓ|ð¿¿ëüò¿;sfi0-N+UÊÀ*ªQ±¶`@°yO í&#©mFÌðKDj:HÌo§ÝhàòEÛøßL?Þ\¤&±6oÜå¯Ëã¸e¿¶y­¤éË2#»%Azdû» ^+IN½êRc]SÚéëp¶rMö6òb(W"öjÔ}þä'îõïÿÂc¿ræôâ?ÞL(ÔÔPéÜÿc!ýã¤Î"?Õü. ìÊ®¦Õ²®¸ ¦s¬³öë¢á±2Â±ôÑ8ÿhI2:I@×¯ppó*wkjP¨æ~£8Z¤¦!-¥VOWTÅ·®]¶µÙàêeÇºÎ¹?Q&mæuRú<NyìsEþQ«	<úñÉÍ~eý~Z1Æ
$AE)Àû¿óµþôCÿõý÷­èÐæ&¬(ãîO¡Ükd¹rMÍï"+Gë<`	R° e aÁ,ÉSÂ\Î/8NóÁùÙÃr·EßCåøU"átLÀZF?êÁ2Ì>n&Ä1Î\ºÈ«³"F52Ý,Z,.£RÅ¥I4JÛý2çæÉæSgBûóÿàØ?ô©G¥R{ | Jk[ãÌïtãj§7ÒÔgÏ,=Õj8¹ià°ÖÕ°ÍzÌoHRXB!ôhÊ`©aÇÀ &dÚµìÊi¿Å¨sx¢4RqhþUxÒ3.NÕ ¨ËÉ0êqò~Ç+IÏòaQ×·oòÊ¬QÅq45QÉ~A®[.ÎÀÁ£a±P¥=ÏrÍ jM>òy"ñÆ¾l*+5­yvÌ'ÀúzÍ>øÐùvn{{«_»|y¡ÓÎ<K¸Ë¤:ôxJÍ9;¸ñÜÇé~°j0h«³ llÂ[¹
ée vÛ{  êIDAT (´Âã¸úíS(:³ûÐgR§èõ#xk1ÕQ~g)M°çKJTZÊ2SãÒ=ªÛ«7±ZEv,Á)$¼áÉtÆ:K¹O7á%¥ØÒé½÷a´X´jóZ¾"¼÷î?ù§þÒ7_øÆ7®¼ûþäÅ_ú«/_=Äv,çÏ9-¼ôl¢çt;`zyQuûZU{xêÍÍ6®]{)öFn>øcïT' ³å±æ-IfX¤ÜÃnòE æÅ"ÑMKlÅÖ`a\BZs0	,fÎå·Tªú,5*dÙBn±Ðæ¥[ÅuxoÿF½rG~CJ2E`9*Âéè]yO¸<,&4Z²südíOl=ùÀýÇ?w÷]ë/·°gfgËÛ$´«!P(fKzýAÅÎï@tç¤]X§×_ÑGHlÄ
=×f*D6S`ÙM	ûöSðé^Sªßd­V±£àh!/É',(r&ý TÄí¼@ö<Ö-Ùq¿k]Ø0GíP| ¬eúØR=ñFxÀr»qàS·9U»9&Ré(Ê =EÀ:§Ü	
º½AÍQ1ù@	ÀH¹ç¾*­¨«¯pu*Z¬V´v°f<OgTçN\èëU %Ms$}
rsü¦MñP©x=ß\ÖH,h5Ì¨t^ÖaÖ¡×f$±0Ôk¾{ ªbf¡SÃ\1¿¼DÍ@ø1+%ùPæIH;Ýî<#êaýÃt&a´`)Å5DIÊ7H#1}ZF4à;¯½f&#FU«ùÊ;Xy)O·ù×Ì¶$,w³ø­2½ñ¦ ¬ZU}Ï<©éÏ3,`Ç¹ °èuúì»ýz&Ub
XÌ8N¡LAÒ2_¹à(?»"Y¦A*REÌRcò!ázªº{ ±½¿íõÔ}	G:øÉ	´o4szZ Ð@°P#¨)5 ô»¼ÜÞãÅÉQÕëef
X<êjCÖ43¸®È¥2FÃpåc÷¿¥Tòr]½u¥MV»ß¸ãNeWT2O2ûúÁåE7$QËÅ¿®ßôa)M¨ÏbÐ³Ugm4S©xSÀrõ¤§gZÅi+ä×ÄÈ±NSVñT¦Ùl½Bîû!á~g/>ã
o@$°¶´3­ B6`ôÁz+XkdÀN03ZÝÝ²`Ç&#F*H3]¸0â&î^Ly0hãêBZ(/¼q¾ÐÍ²áÇ*á»J*<±hxâì;îTÏÌÊ®¿A+ñ`ðtU¹±.A\o9ÛiztT¤,?'p52õ<±ëû"bæJX+= ³¼OÐÁÂC©EÞ©B2]Û1'eHî!çlíÎ p&<¬WúÊBg4¿TÕÑRÈÕúÌhuóºBâ>cÐ KúùX4ä¹ì
óï[hh°µc¯Ý½Ñ!Ïl! ¤ÀéSö|ûK¾ÓÿÍµãêoÖ«ÐË<Oò°ÌXºqØÀüI#òùáâfZ5ä'>Të4èåüÔc7¥] "°iÂ¯%X=­a2rí¬ëj3Á' QÚGFk¨?"&f¶æAR·¦4+7¡I |$£)T¥ÈÁ\"¸³ÇH"^ïìqXrè}_Ö¢(°X¡sëØçCèç,»;)×õÅ$öPEÃúz?ò¡·½òè£'~uy%ü¬ÈþåÐûÔ~0öe[,Û»1¾úÌóð=5TM(û0±Ñ¨àïýÇî>öã§þzS|}Z
Uß÷EJ<Wó\¬ÑR¼ðê·VPR9k-¼\ä¨ IèàÊÆ6øF6<êB½¹·;ºx ÁVVÀ	6NkóI´ftw3°6SªZ,Ä:3È8B½¦÷eO*8½ãÜdØx0ÔÄìZý¸ò)EÊóD­?p5EqÓÏ»Lú¬Hq
d=Ï1e÷³V$>ýG_üïþÆw,|×ó9@aÊÃÈÛ±rR
ö}9¶k:«-öÛÙÛ¡ýäùîû?pÇ¯-­Êé4|lµê§¾/u±Ûæ}çu¦ñâÅËÒuk&P>=f¤$|T Ít¡½yç.¼«· É)qeA+!ÀØÅ.4Gsâ4Æ^¼¥!CGÞb<Ñ8SJè´3¤WuÊ³Èb1£é÷ñàÍ+åQI)ý^:ÁïäÅ èÉâ@XA8wæ$ñ®^¨Ã§!½ÌaçÂbð7åyéX÷½iÌßñx>iÏF)2R÷Á$xÁó	~@ö¥âMñËRÑÀóiày½ßçö<ÒÊ:ûÙ§²AH[B`$Í.0>ã*l0Gø©ßüïþÍ3w,þkkõ¢´<OH¥6%ËÂiflF·e¸:å¥=´w3WÀ[ A 1ÒR 6ì¶HBx ÂBjhm§e é/_¾K×6FzV.ä 6O`¡FûSbEf`gËí=ª#F%%5zýt¢fÑ´³\<­þ2!ô8sâN4Í:n\00C¾Ê¶Èöo~QÓS_¾U#Â9f¥b!ÏÔl\ïÂP ¬û!qöÁ~@ð°ç	( ±¹& ³g¼_»S-Îä´
»É¤F3¢1x¸·4`BàlýLwåñ«/µ«/EøÆyê+1ío,<Ú¾|r­¡%4§ù¼A\ËîïØ2y	áôÉ~ê÷ag+ÅþìUô{	ònÐ á¬mCïîÉÛ	[oà~î1|à'îq¢1d¸ðâüÎï=ÍÈeÁR
6®AÝ¼`8R½¨fÅ ¿?¯Û¹e©RSgªT%5»¤¬|ØM<Wb\1<Â«,ÃÚõÅgïqý³¬sZmî¼Z¶ÈÛu»Úa{¯±"6ïfS¨"ÒÑíZt;Å¦ll/)[H¡
yeÿçÌÅ= >ó{Àþ`óBàÃo¥ ¤ç\8ZAÓ®L¨KiÖ°pWàÅ?÷4£óXÃ©ÿÌÜEPZ¸©^,»ÉPß¶ÒÂ}ÇÏáX«éj/stKÃÓÇë¸°»cu>ãF»èàS`#dÜõ²wÀòGòczQµ³¤±Ht"ÆjÔýÚ%KaÞm4þß¸¨Ñïg%`+b4,¨c/\Çþ v îocñ!7á|óîIæÆxè\n2|O¹xÏ1Êl	Öº÷Cº¨køFßèÑ÷zXIù:ÃâÝ³cNnä0
ÓÓPé;×Ò= ~
j2}á&
ø£Î¤ÀÍ«'RúîLÉÛw^%üîÿ¬ñûáp³Åp5û;ç±&Ï»ÔVð¾¹kâKX]mà¸÷.¶°§/â¦þ»ï¦ ) kÈîwÚØ6ÀÂG¥ PØ»²ä®!:û=[ßÙ´£ù]j(-yã7!Î3i¡í }=Âë£§ÓMK£D9GîxÝ¡+rÎ]0÷W
Ç	) û+NäßÖRõ!H@H§oW$Ü>IHæ£ÌÇ=ÃÿýOÈÄC½Tþ©Ëp|®ÅhÃ9-MüÅHÞd-) !SÏäªJ9Û¡bÅýM4
Ëî½_¥By{o¦YÃêR+ Û8©¢5!2£¹#eXHR¡Dý^VøÕBY#ÝuÐïðÛ®¼l«C§^ð³Ìe­EÔjuÂsFO¶(R\nAþ£úxñ¡pg.sFÛ¿wß1zàä÷Þ}FBÖ³è÷¹ewpÄð	ý 0å}äÝþ(bàc{ÿêUÚéh`Qí=^Çb»w	]s=÷-?Àjã{i?D°´fÍj4óÈ0ÿÚíðÛ·lkHÀ)c¬(VþXk¡Mý¶}´VrÖÚÅ5(Û)ãGXÁ´Ã7å(ZþñßÂ{ÁïNDÐlVÐ¨- ßUØì@éË)õ,4×QÙxÄ^ôi5¤ô°º|{7¾sýÍ¼Ë Ý ilÊ)À[×N¡ÚAim%&eL~ß¢3hc¥"¢ÁáKBsZìç ûÛ¬7©oÚ0Þ=ËK5__EÜ÷°³{RðÈÃ'ð¾w=½-\¿èDå
|	 x "Ö!¼Â'DZ#1"Uo]3ÔZôïbÆ× $®ÚÚòX]ê`g¯åõÕzÑàð|²`av
1"ï´èÄoë=ÔKUÜw÷di«× 1À#Àû >ï]që5	¶@U¬!ðjN6-=È®ÄÖ%À¤;Mxµa0h{£éõ+¤Ò ±cí[¶psZ [Û]Ü{*Bs±Í£²uÔ²·Aq±¼	#»yÃýbEöXS,à)MXA¸3.,­;?~=J{µùo)°UÜ÷¶óÙ®¿¶Ð¬ã¾{Oá½ï:Á^×/ÅèµCd±ç3¼ÐRJÐåAÉFäµ¨DÐq¤ÐE}9Æò)4ò0h{èî½6ß¼î"F²ÐÌ 3cow öúh.2Äm?ä´ mì|½ÄPRÑr!E2ê¬ë¿JÕÐ(ÎèaÇ\±kÔFÀxêPíß{\Ò?ùì¸zSø;^ÓbZð=½néÍµÉïË¶gÏö("¡×BU.ãäÒÞ)ìÜ$Ô¢¨]l_à¹¿èw	8yUö±r±w£`q°u¥R­37î­Â>*U+-D]/¯lê£º %MÄ=í]{ÿÆ+&`f¨8É<=X c¥ØnoãôSXxEawëèjbÅM¤	¡g<axÎdæ*M8êþ]Þó:Ëâq^)Ë7¦×uÑ?,Cñ·ÆMïF ¡qJ¬0³{ÉfO§7µ>÷ïùg«øX²Èv{[ÈVÂºE¿áúeFw«$u¼C	Äq`ùDN£½®F£µ½Î>D²#|¤± Ap¶¿-¡³oîjïSu¨ÈÂ@ KÀZ.\Á=<{9g¾bÄ·gú#?mÝZ¦YQÏy^i\oDÇÜ_Õù(ëôCDÍÛ_qtË@sÎ³ìo8ü H­&Ì^CÁÄHObw½}ÏÊf,A÷¢ßëÁÈ.+È-¨ëØJ7±´XéUA-@ìì¡Ûî!hÞDmÀÞ`åxs	Àkby¹òôù»§TÃ©Qnmuð_{w¾½ó÷{ÞtaJÁ<£¤¸Àó+fm7¯eæaë~ó)í(e ÃzÍÂgCruD¬r°"ÏûIWghóî¬\oxv@!xÿâ Ä>£ÿÒ\Ï
Gé³\Je$[h_¯c÷j44+K¡j](³ýÝã»yb;hµªèmWAõkh,e¥ëì·Ð»~ýkhï2­¬Ëw2CªLÛ¿~äáãüüs×ó4¡Ï¹Wzuá¥ëXY~ïýàû°¿#qãþ¡ù®GQcuetôí&ÄÖeÎCç ÎóöõLúPDÓÜ6ì³*²=j¡Z0pt)7å³Í¬Cô®ØµûÃSf÷4º=,%¤ý*$«Q$×ËYÁ$
©6.G0ïÎRboopé±Ç¿:ê£P ÖP¢µÁß|ýûxuë|èï*¬S ÂõutKvHÜêÐÚÊYÍm Ã!%tGh{Øòäï©Y±E^¨0ÅÒù+8ûÞpö±Ô®	I}Ø £÷\¯fu4òÀFÁDÕ«,ôqìMydõ¥F=M»zsÃZ\¨$ëkg=OOR3¬á%LRûGOãÓÔøÿâ=øË?Txñ¹YjßÔzÃ×mÉ°8Y²ÉÏf­{Ød¥u&­¦{èµnÉbÎ³Â24òÑ E´1ÀÎ~¥Z½¶Åc)Ë©k'eÏc1aO;Ú>zqý+ë/²	A×>±·ùêî»WM÷Ý·gÛ	¬ÑÆÿýoÁw.\Ç?úùÇqîÞ5|ýÉ»[:ã*ÍózAvà¼! Ãº*b¢[àïõlªÏ*¦;èC#jí+¬­® ¨'HS¡4 k»Ñë=#¢rª© -/¶pÇ·cÐ9ÔQmÔ @z;7-ºýìÔÊqÈ_ûµf~fc7Òøì·¯zÙÀ*¾¶¶zøê7/âÜýïûÀ*`ö\)*Gv?D°ÑIÊ¼ ì(ÑááQãÁëeÛYÇL|?+"¥#3	¯±F­4Õê	°ÐÆ ð%t&0ÈÚØno¢ßË0èQôA1è2ú]N´ mU$±¨6`$â4ÁÝyxðÑÚ¿V øÑGO\øÏüÒK~åµ-¬!fúÿê÷¿ów¾<qÎ<º¨bçÄÞ-d IdÏ¢²nä7K1Okóæ[ªÉÍfçQ#Bk©wv4¯pñÆpbÞÝ¸tÅDõÄ\±:¢| åÉ®Ê¿a¡½,Þµ©¡3F5ÑTNîaõ®>jBðÚûFjâJù6¥%LWbáØ6Ä 6dý*L³ÖÉ=	6^«RX?A²Þw/Üü?þÓ~ãÿ_yøÆ¬É[,!NoáÜU[]D=XMªº
qÆ5wù­a.ªT¼á<lLí0®«äï0¯´NÉ²RÖð&>ãmJ`¥Ù­ÂGú*.§ÈºÀ×éNÏ'9>iËpB!{Ø'Ïa#¡sÉ¸÷=ö¯×ÐÝõ&|	+vot¬]¥±Ê#,/øßþxõ+eùÊµkûÿÝG?|ï¯ýég¾sÿînÿHÀràdDQW^ÝÆ+¯nCæ`«×,¶ª|T±BÊÇL<M4oX¡â\f'IÏ©ácúÇg34(Uzv ý9ÃQ¹ÛÑÍ²æåRW	Ñà%,âEU¤}:UH²èì Û¨Å)¤Ë­$¤®¢×÷%"o%KÆ5°»ÜºfVÔð <OÆÛÛ½'Ûødÿöþ½Õí>ñDRù(É[cAÁ Åæfo½þý¿<O¢Ù¨`uy`¡± Táêh:Ò¦1zÔókj"i+6@µ!¨M?õºÀ¤./×:O<~þ=OÔ@ýìÓÏ\}ô{/Ýq¢¬·^?¯,3ØÙíag·"@
åI4U,/5ÐÐ¨¯IàfL)ùQ
	â¬ÃW\S;U¶õF'>þÀÍõSôÇj2ÇÌW?ò¡{ÿ×Åê·ï8½ø÷¾úõ×>öíç6Nlm÷h8³Ù[ÀúÛýr%¶¢66·:â:ÊSÞK`´EêÑLÀÃW£àÓ?þðÞmÃ«&U$:ÌüçË+õï>½ø­<ñóß½pãÏ¿p­¾»;@jö°þV¬ ÃØÛüÀûk4B|ì£÷]ÿèïùÎYúãÇ½C8ZÆ×¿yé®W^Ý~ßÞÞà±4Õ_¿Ñy`ãÚ¾wáÅrãêEq­ÚÀÎ\]©¼>!èÜ?ÕsZÇõ'¼czCò6Vç`½¯F#ÄÏ|úáøÉ~ýáNü«ûî=¶GDGëäûêÆØËWö~æêÒ­­nãäñÖ§vw£:IðÝlsuÑDÚ8ò÷7lð[Jû¹e.¶PMÒÉ)eæûÕ*%"+¥)ÄRúÂimcÎ2¦q$qÅX-Ñ*I¢j&c¬-,ÇmÀác­-ÑC½X©å
¢fm+õ³zµÑ|D)r>39by²RærGfÆµëmºtivv®¡Ý½)ÀúÔÃ7>ññ~ý¡Oü_÷ßwlwØÃnõ£íµXéõ2¹µÝm¢¸j]ôK¥;.èÁ:¼v.3¡)Ïãz­i|?°DÊóY
ÅÕ¨ò½p1­µEÊtFYR¿ßA$ÑyDÌd-bÝ9ø¾äìÕÏ¥°=ïÂE<ÁÆÚáÔîÐÜ£a·Lã{#GyþÐqãÍF¤3Ê__o¾;MõÇ®\Ý}dk«Wù/¾$:.í"N+#¥«ÿ¾W½à§?õÈÍOòÁ_àþã¿7´XoØ°ð#VÙCøÑ~ÑµfPðÆÍvýû/oVÁh®­5~ÎZn\¼xë'¯ßìÿìç¿.nÒövq¬â¨×9òÕ:>þ±ûo}è÷ü÷Ý»þ/ßv×j{²ëÐúÍxëõ>ìÌLÌð±ôÌ³WÕ@¾owgðÓívTç±U¤I½>hÔþ;n¸bàiü)OÏÙï§~ÿ}ÇâYó.ýØìdSì    IEND®B`a:10:{s:4:"name";s:5:"phool";s:7:"summary";s:29:"A PHP Object-Oriented Library";s:7:"version";s:5:"2.0.1";s:7:"release";s:1:"1";s:6:"author";s:48:"Francois Laupretre <mailto:francois@tekwire.net>";s:8:"packager";s:48:"Francois Laupretre <mailto:francois@tekwire.net>";s:9:"copyright";s:52:"(C) Francois Laupretre <mailto:francois@tekwire.net>";s:3:"url";s:24:"http://phool.tekwire.net";s:7:"license";s:71:"GNU Lesser General Public License (LGPL) <http://www.gnu.org/licenses/>";s:14:"license_prefix";s:12:"/etc/license";}a:5:{s:15:"build_timestamp";i:1432842855;s:11:"map_defined";b:1;s:14:"phkmgr_version";s:5:"3.0.0";s:23:"automap_creator_version";s:5:"3.0.0";s:18:"automap_minVersion";s:5:"3.0.0";}<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool\Debug;

class Counter
{

//---------

public static $nb=0;
public static $time=0.0;
private static $t;

public static function start()
{
self::$t=microtime(true);
}

public static function end()
{
self::$time+=(microtime(true)-self::$t);
self::$nb++;
}

public static function display()
{
echo '>>> Count: '.self::$nb.' ; Time: '.self::$time."\n";
}

//----------
} // End of class
//=============================================================================
?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

//============================================================================
/**
* Static functions used to display messages (normal, trace, debug...)
*/

class Display
{
const MAX_VERBOSE_LEVEL=2;	// Highest message level
const MIN_VERBOSE_LEVEL=-3; // Lowest message level -1

// Note: the minimal verbose level allows to hide every messages

private static $prefix=array(
	 2 => '>> ',			// Debug
	 1 => '> ',				// Trace
	 0 => '',				// Info
	-1 => '*Warning* ', 	// Warning
	-2 => "\n***Error*** "	// Error
	);

/** @var integer Verbose level, default=0 */

private static $verbose_level=0;

/** @var integer Array containing the error msgs since the beginning */

private static $errors=array();

//----------------------------------------------------------------------------
/**
* Increment verbose level
*
* @return void
*/

public static function incVerbose()
{
if (self::$verbose_level < self::MAX_VERBOSE_LEVEL) self::$verbose_level++;
}

//----------------------------------------------------------------------------
/**
* Decrement verbose level
*
* @return void
*/

public static function decVerbose()
{
if (self::$verbose_level > self::MIN_VERBOSE_LEVEL) self::$verbose_level--;
}

//----------------------------------------------------------------------------
/**
* Set verbose level
*
* @param integer $level integer
* @return void
*/

public static function setVerbose($level)
{
self::$verbose_level=$level;
}

//----------------------------------------------------------------------------
/**
* Conditionnally display a string to stderr
*
* Display the string if the message level is less or equal to the verbose level
*
* @param string $msg The message
* @param integer $level The message level
* @return void
*/

private static function _display($msg,$level)
{
if ($level <= self::$verbose_level)
	{
	$msg=self::$prefix[$level].$msg."\n";
	if (defined('STDERR')) fprintf(STDERR,"%s",$msg);
	else echo $msg;
	}
}

//----------------------------------------------------------------------------
/**
* Display an error message
*
* @param string $msg The message
* @return void
*/

public static function error($msg)
{
self::_display($msg,-2);
self::$errors[]=$msg;
}

//----------------------------------------------------------------------------
/**
* Display a warning message
*
* @param string $msg The message
* @return void
*/

public static function warning($msg)
{
self::_display($msg,-1);
}

//----------------------------------------------------------------------------
/**
* Return the current error count
*
* @return int
*/

public static function errorCount()
{
return count(self::$errors);

}

//----------------------------------------------------------------------------
/**
* Return the error array
*
* @return array
*/

public static function getErrors()
{
return self::$errors;
}

//----------------------------------------------------------------------------
/**
* Display a level 0 message
*
* @param string $msg The message
* @return void
*/

public static function msg($msg)
{
self::_display($msg,0);
}

//----------------------------------------------------------------------------
/**
* Display an info message
*
* @param string $msg The message
* @return void
*/

public static function info($msg)
{
self::_display($msg,0);
}

//----------------------------------------------------------------------------
/**
* Display a trace message
*
* @param string $msg The message
* @return void
*/

public static function trace($msg)
{
self::_display($msg,1);
}

//----------------------------------------------------------------------------
/**
* Display a debug message
*
* @param string $msg The message
* @return void
*/

public static function debug($msg)
{
self::_display($msg,2);
}

//----------------------------------------------------------------------------
/**
* Convert a boolean to a displayable string
*
* @param bool $val The boolean value to convert
* @return string The string to display
*/

public static function boolStr($val)
{
return ($val ? 'yes' : 'no');
}

//----------------------------------------------------------------------------
/**
* Converts a variable through var_dump()
*
* @param any $var The value to convert
* @return string The dumped value
*/

public static function vdump($var)
{
ob_start();
var_dump($var);
return ob_get_clean();
}

//----------------------------------------------------------------------------
/**
* Display current stack trace
*
* @return void
*/

public static function showTrace()
{
$e=new \Exception();
print_r($e->getTrace());
}

//----------------------------------------------------------------------------
/**
* Return displayable type of a variable
*
* @param any $var
* @return string
*/

public static function varType($var)
{
return is_object($var) ? 'object '.get_class($var) : gettype($var);
}

//----------------------------------------------------------------------------
/**
* Convert a boolean to a displayable string
*
* @param any $var
* @return string
*/

public static function bool2str($var)
{
return $var ? 'Yes' : 'No';
}

//----------------------------------------------------------------------------
} // End of class Display
?><?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

class File
{

//----

public static function suffix($filename)
{
return self::suffix($filename);
}

//----

public static function fileSuffix($filename)
{
$dotpos=strrpos($filename,'.');
if ($dotpos===false) return '';

return strtolower(substr($filename,$dotpos+1));
}

//----
/**
* Combines a base path with another path
*
* The base path can be relative or absolute.
*
* The 2nd path can also be relative or absolute. If absolute, it is returned
* as-is. If it is a relative path, it is combined to the base path.
*
* Uses '/' as separator (to be compatible with stream-wrapper URIs).
*
* @param string $base The base path
* @param string|null $path The path to combine
* @param bool $separ true: add trailing sep, false: remove it
* @return string The resulting path
*/

public static function combinePath($base,$path,$separ=false)
{
if (($base=='.') || ($base=='') || self::isAbsolutePath($path))
	$res=$path;
elseif (($path=='.') || is_null($path))
	$res=$base;
else	//-- Relative path : combine it to base
	$res=rtrim($base,'/\\').'/'.$path;

return self::trailingSepar($res,$separ);
}

//---------------------------------
/**
* Adds or removes a trailing separator in a path
*
* @param string $path Input
* @param bool $flag true: add trailing sep, false: remove it
* @return bool The result path
*/

public static function trailingSepar($path, $separ)
{
$path=rtrim($path,'/\\');
if ($path=='') return '/';
if ($separ) $path=$path.'/';
return $path;
}

//---------------------------------
/**
* Determines if a given path is absolute or relative
*
* @param string $path The path to check
* @return bool True if the path is absolute, false if relative
*/

public static function isAbsolutePath($path)
{
return ((strpos($path,':')!==false)
	||(strpos($path,'/')===0)
	||(strpos($path,'\\')===0));
}

//---------------------------------
/**
* Build an absolute path from a given (absolute or relative) path
*
* If the input path is relative, it is combined with the current working
* directory.
*
* @param string $path The path to make absolute
* @param bool $separ True if the resulting path must contain a trailing separator
* @return string The resulting absolute path
*/

public static function mkAbsolutePath($path,$separ=false)
{
if (!self::isAbsolutePath($path)) $path=self::combinePath(getcwd(),$path);
return self::trailingSepar($path,$separ);
}

//---------

public static function readFile($path)
{
if (($data=@file_get_contents($path))===false)
	throw new \Exception($path.': Cannot get file content');
return $data;
}

//---------
// Throws exceptions and removes '.' and '..'

public static function scandir($path)
{
if (($subnames=scandir($path))===false)
	throw new \Exception($path.': Cannot read directory');

$a=array();
foreach($subnames as $f)
	if (($f!='.') && ($f!='..')) $a[]=$f;

return $a;
}

//---------------------------------

public static function atomicWrite($path,$data)
{
$tmpf=tempnam(dirname($path),'tmp_');

if (file_put_contents($tmpf,$data)!=strlen($data))
	throw new \Exception($tmpf.": Cannot write");

// Windows does not support renaming to an existing file (looses atomicity)

if (Util::envIsWindows()) @unlink($path);

if (!rename($tmpf,$path))
	{
	unlink($tmpf);
	throw new \Exception($path,'Cannot replace file');
	}
}

//---------------------------------
/**
* Computes a string uniquely identifying a given path on this host.
*
* Mount point unicity is based on a combination of device+inode+mtime.
*
* On systems which don't supply a valid inode number (eg Windows), we
* maintain a fake inode table, whose unicity is based on the path filtered
* through realpath(). It is not perfect because I am not sure that realpath
* really returns a unique 'canonical' path, but this is best solution I
* have found so far.
*
* @param string $path The path to be mounted
* @return string the computed mount point
* @throws Exception
*/

private static $simul_inode_array=array();
private static $simul_inode_index=1;

public static function pathUniqueID($prefix,$path,&$mtime)
{
if (($s=stat($path))===false) throw new \Exception("$path: File not found");

$dev=$s[0];
$inode=$s[1];
$mtime=$s[9];

if ($inode==0) // This system does not support inodes
	{
	$rpath=realpath($path);
	if ($rpath === false) throw new \Exception("$path: Cannot compute realpath");

	if (isset(self::$simul_inode_array[$rpath]))
		$inode=self::$simul_inode_array[$rpath];
	else
		{ // Create a new slot
		$inode=self::$simul_inode_index++;	
		self::$simul_inode_array[$rpath]=$inode;
		}
	}

return sprintf('%s_%X_%X_%X',$prefix,$dev,$inode,$mtime);
}

//---------------------------------

public static function recursiveCopy($src,$dst)
{
if (is_dir($src))
	{
    $dir = opendir($src);
    @mkdir($dst);
    while(($entry=readdir($dir))!==false)
		{
		if (($entry==='.')||($entry==='..')) continue;
		self::recursiveCopy($src.'/'.$entry,$dst.'/'.$entry);
		}
	closedir($dir);
	}
else
	{
	copy($src,$dst);
	}
}

//----------
} // End of class
//=============================================================================
?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

//============================================================================
/**
* This abstract class allows to know whether an object has been modified or not
* since it was created or read from persistent storage
*
* Each time a property is modified, the descendant class must call the
* {@link setModified()} method.
*
* When it is saved, {@link clearModified()} must be called
* 
* The current state can be retrieved via the {@link modified()} method.
*
* When the instance is created, the state is set to 'not-modified'
*/

abstract class Modifiable
{
/** @var boolean True if the object was modified since creation/load/save */

private $modified_flag=false;

//----------------------------------------------------------------------------
/**
* Class constructor
*
* Ensures that the instance is in 'non-modified' state at creation time
*
* @return void
*/

protected function __construct()
{
$this->clearModified();
}

//----------------------------------------------------------------------------
/**
* Set the 'modified' state depending on an input toggle
*
* The input toggle allows to pass a boolean return code as argument
*
* @param boolean $toggle If true, set the state, if false, do nothing
* @return void
*/

protected function setModified($toggle=true)
{
if ($toggle) $this->modified_flag=true;
}

//----------------------------------------------------------------------------
/**
* Set the 'not-modified' state
* Should be called only when the instance is transferred to persistent storage
* @return void
*/

protected function clearModified()
{
$this->modified_flag=false;
}

//----------------------------------------------------------------------------
/**
* Returns the modified state
*
* @return boolean the current state
*/

public function modified()
{
return $this->modified_flag;
}

//----------------------------------------------------------------------------
} // End of class
?><?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool\Network;

class IP
{

public function network($ip,$mask)
{
self::validate($ip);
self::validate($mask);

$a_ip=self::stringToArray($ip);
$a_mask=self::stringToArray($mask);

$a_res=array();
for ($i=0;$i<4;$i++) $a_res[]=intval($a_ip[$i]) & intval($a_mask[$i]);

return self::arrayToString($a_res);
}

//-----------

public function validate($string)
{
$a=self::stringToArray($string);
for ($i=0;$i<4;$i++)
	{
	$val=$a[$i];
	if ((!is_numeric($val))||($val < 0) || ($val > 255))
		throw new \Exception("$val/$string: Invalid IP address");
	}
return $string;
}

//-----------

public function stringToArray($string)
{
$res=explode('.',$string);
if (count($res)!==4) throw new \Exception("$string: Invalid IP address");
return $res;
}

//-----------

public function arrayToString($a)
{
return implode('.',$a);
}

//-----------
}
?><?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool\Options;

//=============================================================================
/**
* This class manages command line options. It is a wrapper above Getopt
*/

abstract class Base
{
// These properties must be declared in the child class (see 'Dummy' class)

// protected $opt_modifiers; /* Modifier args */
// protected $options;	/* Option values */

abstract protected function processOption($opt,$arg);

//-----------------------

public function options()
{
return $this->options;
}

//-----------------------

public function option($opt)
{
if (!array_key_exists($opt,$this->options))
	throw new \Exception("$opt: Unknown option");
return $this->options[$opt];
}

//-----------------------

public function set($opt,$value)
{
if (!array_key_exists($opt,$this->options))
	throw new \Exception("$opt: Unknown option");
$this->options=$value;
}

//-----------------------

public function parse(&$args)
{
$short_opts='';
$long_opts=array();
foreach($this->opt_modifiers as $mod)
	{
	$short_opts .= $mod['short'];
	$long=$mod['long'];
	if ($mod['value'])
		{
		$short_opts .= ':';
		$long .= '=';
		}
	$long_opts[]=$long;
	}

list($opts,$args2)=Getopt::getopt2($args,$short_opts,$long_opts);
foreach($opts as $opt_val)
	{
	list($opt,$arg)=$opt_val;
	if (strlen($opt)>1) // Convert long option to short
		{
		$opt=substr($opt,2);
		foreach($this->opt_modifiers as $mod)
			{
			if ($mod['long']==$opt)
				{
				$opt=$mod['short'];
				break;
				}
			}
		}
	if (strlen($opt)>1) throw new \Exception("--$opt: Unrecognized option");
	$this->processOption($opt,$arg);
	}

$args=$args2;
}

//-----------------------

public function parseAll(&$args)
{
$res=array();

while(true)
	{
	$this->parse($args);
	if (!count($args)) break;
	$res[]=array_shift($args);
	}
$args=$res;
}

//---------

//============================================================================
} // End of class
?>
<?php
//=============================================================================
//
// Copyright Francois Laupretre <automap@tekwire.net>
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//=============================================================================
/**
* This class is an example of an options parser
*
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
// <Automap>:ignore-file
//============================================================================

class Dummy_Options extends \Phool\Options\Base
{

// Short/long modifier args

protected $opt_modifiers=array(
	array('short' => 'v', 'long' => 'verbose', 'value' => false),
	array('short' => 'q', 'long' => 'quiet'  , 'value' => false),
	array('short' => 'd', 'long' => 'dummy'  , 'value' => true)
	);

// Option values

protected $options=array(
	'dummy_opt' => 'default_value'
	);

//-----------------------
// Option is always provided in short form

protected function processOption($opt,$arg)
{
switch($opt)
	{
	case 'v':
		\Phool\Display::incVerbose();
		break;

	case 'q':
		\Phool\Display::decVerbose();
		break;

	case 'm':
		$this->$options['dummy_opt']=$arg;
		break;
	}
}

//---------

//============================================================================
} // End of class
?>
<?php
/* vim: set expandtab tabstop=4 shiftwidth=4: */
// +----------------------------------------------------------------------+
// | PHP Version 5                                                        |
// +----------------------------------------------------------------------+
// | Copyright (c) 1997-2003 The PHP Group                                |
// +----------------------------------------------------------------------+
// | This source file is subject to version 3.0 of the PHP license,       |
// | that is bundled with this package in the file LICENSE, and is        |
// | available through the world-wide-web at the following url:           |
// | http://www.php.net/license/3_0.txt.                                  |
// | If you did not receive a copy of the PHP license and are unable to   |
// | obtain it through the world-wide-web, please send a note to          |
// | license@php.net so we can mail you a copy immediately.               |
// +----------------------------------------------------------------------+
// | Author: Andrei Zmievski <andrei@php.net>                             |
// | Modified by Francois Laupretre <francois@tekwire.net>                |
// +----------------------------------------------------------------------+
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

//-------------------------------------------------------------------------
// Changes from original version: see class description
//-------------------------------------------------------------------------

namespace Phool\Options;

/**
 * Command-line options parsing class.
 *
 * @author Andrei Zmievski <andrei@php.net>
 *
 */
class Getopt {
    /**
     * Parses the command-line options.
     *
     * The first parameter to this function should be the list of command-line
     * arguments without the leading reference to the running program.
     *
     * The second parameter is a string of allowed short options. Each of the
     * option letters can be followed by a colon ':' to specify that the option
     * requires an argument, or a double colon '::' to specify that the option
     * takes an optional argument.
     *
     * The third argument is an optional array of allowed long options. The
     * leading '--' should not be included in the option name. Options that
     * require an argument should be followed by '=', and options that take an
     * option argument should be followed by '=='.
     *
     * The return value is an array of two elements: the list of parsed
     * options and the list of non-option command-line arguments. Each entry in
     * the list of parsed options is a pair of elements - the first one
     * specifies the option, and the second one specifies the option argument,
     * if there was one.
     *
     * Long and short options can be mixed.
     *
     * Most of the semantics of this function are based on GNU getopt_long().
     *
     * Changes from original version:
	 *		- switch to PHP 5 object syntax
	 *		- make independant from PEAR error handling using exceptions
	 *
	 * @param array  $args           an array of command-line arguments
     * @param string $short_options  specifies the list of allowed short options
     * @param array  $long_options   specifies the list of allowed long options
     *
     * @return array two-element array containing the list of parsed options and
     * the non-option arguments
     *
     * @throws Exception
     *
     */
    public static function getopt2($args, $short_options, $long_options = null)
    {
        return self::doGetopt(2, $args, $short_options, $long_options);
    }

    /**
     * This function expects $args to start with the script name (POSIX-style).
     * Preserved for backwards compatibility.
     * @see getopt2()
     */    
    public static function getopt($args, $short_options, $long_options = null)
    {
        return self::doGetopt(1, $args, $short_options, $long_options);
    }

    /**
     * The actual implementation of the argument parsing code.
     */
    private static function doGetopt($version, $args, $short_options, $long_options = null)
    {
        if (empty($args)) {
            return array(array(), array());
        }
        $opts     = array();
        $non_opts = array();

        settype($args, 'array');

        if ($long_options) {
            sort($long_options);
        }

        /*
         * Preserve backwards compatibility with callers that relied on
         * erroneous POSIX fix.
         */
        if ($version < 2) {
            if (isset($args[0]{0}) && $args[0]{0} != '-') {
                array_shift($args);
            }
        }

        reset($args);
        while (list($i, $arg) = each($args)) {

            /* The special element '--' means explicit end of
               options. Treat the rest of the arguments as non-options
               and end the loop. */
            if ($arg == '--') {
                $non_opts = array_merge($non_opts, array_slice($args, $i + 1));
                break;
            }

            if ($arg{0} != '-' || (strlen($arg) > 1 && $arg{1} == '-' && !$long_options)) {
                $non_opts = array_merge($non_opts, array_slice($args, $i));
                break;
            } elseif (strlen($arg) > 1 && $arg{1} == '-') {
                self::_parseLongOption(substr($arg, 2), $long_options, $opts, $args);
            } else {
                self::_parseShortOption(substr($arg, 1), $short_options, $opts, $args);
            }
        }

        return array($opts, $non_opts);
    }

    private static function _parseShortOption($arg, $short_options, &$opts, &$args)
    {
        for ($i = 0; $i < strlen($arg); $i++) {
            $opt = $arg{$i};
            $opt_arg = null;

            /* Try to find the short option in the specifier string. */
            if (($spec = strstr($short_options, $opt)) === false || $arg{$i} == ':')
            {
                throw new \Exception(__CLASS__.": unrecognized option -- $opt");
            }

            if (strlen($spec) > 1 && $spec{1} == ':') {
                if (strlen($spec) > 2 && $spec{2} == ':') {
                    if ($i + 1 < strlen($arg)) {
                        /* Option takes an optional argument. Use the remainder of
                           the arg string if there is anything left. */
                        $opts[] = array($opt, substr($arg, $i + 1));
                        break;
                    }
                } else {
                    /* Option requires an argument. Use the remainder of the arg
                       string if there is anything left. */
                    if ($i + 1 < strlen($arg)) {
                        $opts[] = array($opt,  substr($arg, $i + 1));
                        break;
                    } else if (list(, $opt_arg) = each($args))
                        /* Else use the next argument. */;
                    else
                        throw new \Exception(__CLASS__.": option requires an argument -- $opt");
                }
            }

            $opts[] = array($opt, $opt_arg);
        }
    }

    private static function _parseLongOption($arg, $long_options, &$opts, &$args)
    {
        @list($opt, $opt_arg) = explode('=', $arg);
        $opt_len = strlen($opt);

        for ($i = 0; $i < count($long_options); $i++) {
            $long_opt  = $long_options[$i];
            $opt_start = substr($long_opt, 0, $opt_len);

            /* Option doesn't match. Go on to the next one. */
            if ($opt_start != $opt)
                continue;

            $opt_rest  = substr($long_opt, $opt_len);

            /* Check that the options uniquely matches one of the allowed
               options. */
            if ($opt_rest != '' && $opt{0} != '=' &&
                $i + 1 < count($long_options) &&
                $opt == substr($long_options[$i+1], 0, $opt_len)) {
                throw new \Exception(__CLASS__.": option --$opt is ambiguous");
            }

            if (substr($long_opt, -1) == '=') {
                if (substr($long_opt, -2) != '==') {
                    /* Long option requires an argument.
                       Take the next argument if one wasn't specified. */;
                    if (!strlen($opt_arg) && !(list(, $opt_arg) = each($args))) {
                        throw new \Exception(__CLASS__.": option --$opt requires an argument");
                    }
                }
            } else if ($opt_arg) {
                throw new \Exception(__CLASS__.": option --$opt doesn't allow an argument");
            }

            $opts[] = array('--' . $opt, $opt_arg);
            return;
        }

        throw new \Exception(__CLASS__.": unrecognized option --$opt");
    }

    /**
    * Safely read the $argv PHP array across different PHP configurations.
    * Will take care on register_globals and register_argc_argv ini directives
    *
    * @return array the $argv PHP array
	* @throws Exception if not registered
    */
    public static function readPHPArgv()
    {
        global $argv;
        if (!is_array($argv)) {
            if (!@is_array($_SERVER['argv'])) {
                if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) {
                    throw new \Exception(__CLASS__.": Could not read cmd args (register_argc_argv=Off?)");
                }
                return $GLOBALS['HTTP_SERVER_VARS']['argv'];
            }
            return $_SERVER['argv'];
        }
        return $argv;
    }

}

?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
//=============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

//============================================================================
/**
* This abstract class implements an object which can be saved and retrieved
* to/from a file on  disk.
*
* It exposes the {@link load()} and {@link save()} methods.
*
* It also provides a checksum mechanism transparent to the descendant
* class. Everytime an object is read from storage, its checksum is computed
*  and compared to the value that was stored at save() time.
*
* The descendant class must define two methods named serialize and
* unserialize to transmit/retrieve the data to save.
*
* Note: Late static binding would allow to access the descendant class
* properties and get the magic string from the toplevel class at runtime.
* Unfortunately, it is implemented in versions of PHP >= 5.3, which is too
* restrictive. So, we use another way.
*/

//----------------------------------------------------------------------------

abstract class Persistent extends Modifiable
{
// @var string The magic string to write and check

private $magic;

// @var string The last loaded path. Allows to call save() without argument.

private $path=null;

//----------------------------------------------------------------------------
/**
* Return the properties to save as a string
*
* @return string
*/

abstract protected function serialize();

//----------------------------------------------------------------------------
/**
* Restore data from the result of a previous {@link __serialize()} execution
*
* @param mixed $data The data returned by a previous {@link __serialize()}
* execution
*
* @return void
*/

abstract protected function unserialize($data);

//----------------------------------------------------------------------------
/**
* Class constructor
*
* @param string $magic The magic string to use when writing/reading a file
* @param string|null $path A file to load if not null
* @return void
*/

protected function __construct($magic,$path=null)
{
$this->magic=$magic;
parent::__construct();
if (!is_null($path)) $this->load($path);
}

//----------------------------------------------------------------------------
/**
* Records a path
*
* @param string $path
* @return void
*/

public function setPath($path)
{
$this->path=$path;
}

//----------------------------------------------------------------------------
/**
* Restore data from a save()d file
*
* @param string $path Path of the file to load
* @return void
* @throws Exception if file cannot be loaded
*/

public function load($path)
{
if (!file_exists($path)) throw new \Exception("$path: File does not exist");

try
	{
	$buf=file_get_contents($path);
	if ($buf===false) throw new \Exception("$path: Cannot get file contents");
	//-- Check magic
	if (substr($buf,0,strlen($this->magic))!==$this->magic)
		throw new \Exception("Bad magic string");
	//-- Skip magic string
	$buf=substr($buf,strlen($this->magic));
	//-- Unserialize toplevel array
	$a=unserialize($buf);
	if ((!is_array($a))
		||(!array_key_exists('crc',$a))
		||(!array_key_exists('data',$a)))
		throw new \Exception('Invalid format');

	$data=$a['data'];
	if (crc32($data) !== $a['crc'])
		throw new \Exception('Wrong checksum');

	$this->unserialize($data);
	}
catch (\Exception $e)
	{
	throw new \Exception("$path: Cannot load file: ".$e->getMessage());
	}

$this->setPath($path);
}

//----------------------------------------------------------------------------
/**
* Save data to a file on disk
*
* @param string|null $path Path to save or null if same as load()
* @return void
* @throws Exception if write failed or path cannot be determined
*/

public function save($path=null)
{
if (is_null($path))
	{
	if (is_null($this->path))
		throw new \Exception('Save path cannot be determined');
	$path=$this->path;
	}

$value=$this->serialize(); // Call toplevel method
$data=serialize(array(
	'crc' => crc32($value),
	'data' => $value
	));

if (file_put_contents($path,$this->magic.$data)===false)
	throw new \Exception("$path: Cannot write file");

//-- Write is OK. Now we can clear the 'modified' flag

parent::clearModified();
}

//----------------------------------------------------------------------------
/**
* Save object to a file if it was modified since last load() or save()
*
* @param string|null $path Path to save or null if same as load()
* @return void
* @throws Exception if write failed
*/

public function saveIfModified($path=null)
{
if ($this->modified()) $this->save($path);
}

} // End of class
?><?php
//=============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================
//----------------------------------------------------------------------------

namespace Phool;

class Time
{

//---------
// Converts a timestamp to a string
// @ to suppress warnings about system timezone

public static function timestring($time=null)
{
if ($time=='unlimited') return $time;
if (is_null($time)) $time=time();
return @strftime('%d-%b-%Y %H:%M %z',$time);
}

//---------

public function compoundString($t='now',$tz)
{
$d=new \DateTime($t,new DateTimeZone($tz));
return $d->format('d-M-Y H:i:s (U)');
}

//---------
// $start=microtime() float

public static function deltaMS($start)
{
$delta=microtime(true)-$start;

return round($delta*1000,2).' ms';
}

//----------
} // End of class
//=============================================================================
?>
<?php
//=============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

class Util
{

//---------

public static function envIsWeb()
{
return (php_sapi_name()!='cli');
}

//----

public static function envIsWindows()
{
return (substr(PHP_OS, 0, 3) == 'WIN');
}

//---------
// Adapted from PEAR

public static function loadExtension($ext)
{
if (extension_loaded($ext)) return;

if (PHP_OS == 'AIX') $suffix = 'a';
else $suffix = PHP_SHLIB_SUFFIX;

@dl('php_'.$ext.'.'.$suffix) || @dl($ext.'.'.$suffix);

if (!extension_loaded($ext)) throw new \Exception("$ext: Cannot load extension");
}

//---------
// Require several extensions. Allows to list every extensions that are not
// present.

public static function loadExtensions($ext_list)
{
$failed_ext=array();
foreach($ext_list as $ext)
	{
	try { self::loadExtension($ext); }
	catch (\Exception $e) { $failed_ext[]=$ext; }
	}
if (count($failed_ext))
	throw new \Exception('Cannot load the following required extension(s): '
		.implode(' ',$failed_ext));
}

//---------
// Replacement for substr()
// Difference : returns '' instead of false (when index out of range)

public static function substr($buf,$position,$len=NULL)
{
$str=is_null($len) ? substr($buf,$position) : substr($buf,$position,$len);
if ($str===false) $str='';
return $str;
}

//---------
// This function must be called before every file access
// In PHP 6, magic_quotes_runtime is suppressed and set_magic_quotes_runtime()
// does not exist any more.

private static $mqr_exists=null;
private static $mqr_level=0;
private static $mqr_save;

public static function disableMQR()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

if (self::$mqr_level==0)
	{
	self::$mqr_save=get_magic_quotes_runtime();
	set_magic_quotes_runtime(0);
	}
self::$mqr_level++;
}

//---------
// This function must be called after every file access

public static function restoreMQR()
{
if (is_null(self::$mqr_exists))
	self::$mqr_exists=function_exists('set_magic_quotes_runtime');

if (!self::$mqr_exists) return;

self::$mqr_level--;
if (self::$mqr_level==0) set_magic_quotes_runtime(self::$mqr_save);
}

//---------

public static function mkArray($data)
{
if (is_null($data)) return array();
if (!is_array($data)) $data=array($data);
return $data;
}

//---------------------------------

public static function callMethod($object,$method,$args)
{
return call_user_func_array(array($object,$method),$args);
}

//----------
} // End of class
//=============================================================================
?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool;

abstract class VarContainer
{

protected $vars=array();

//------------------

public static function boolVal($val)
{
return ($val ? 'Y' : '');
}

//------------------

public function valIsSet($vname)
{
return array_key_exists($vname,$this->vars);
}

//------------------

public function valIsTrue($vname)
{
return ($this->valIsSet($vname) ? ($this->val($vname) != '') : false);
}

//------------------

public function __get($vname)
{
return $this->val($vname);
}

//------------------
// Difference with __get() method. This one allows to retrieve any variable name, even containing characters forbidden
// in variable names (like '/').

public function val($vname)
{
if (!$this->valIsSet($vname)) throw new \Exception("$vname: Variable not set");
return $this->vars[$vname];
}

//------------------

public function valArray()
{
return $this->vars;
}

//------------------

public function setVal($name,$value)
{
$this->vars[$name]=trim($value);
}

//------------------
}
?><?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================

namespace Phool\Web;

class HTTP
{

//---------

public static function getArg($name)
{
if (!array_key_exists($name,$_GET))
	throw new \Exception("$name: GET argument missing");
return trim($_GET[$name]);
}

//---------
// Compute the base URL we were called with

public static function baseUrl()
{
if (!\Phool\Util::envIsWeb()) return '';

if (!isset($_SERVER['PATH_INFO'])) return $_SERVER['PHP_SELF'];

$phpself=$_SERVER['PHP_SELF'];
$slen=strlen($phpself);

$pathinfo=$_SERVER['PATH_INFO'];
$ilen=strlen($pathinfo);

// Remove PATH_INFO from PHP_SELF if it is at the end. Don't know
// which config does this, but some servers put it, some don't.

if (($slen > $ilen) && (substr($phpself,$slen-$ilen)==$pathinfo))
	$phpself=substr($phpself,0,$slen-$ilen);

return $phpself;
}

//---------------------------------
// Sends an HTTP 301 redirection

public static function http301Redirect($path)
{
header('Location: http://'.$_SERVER['HTTP_HOST'].self::http_baseUrl().$path);
header('HTTP/1.1 301 Moved Permanently');
exit(0);
}

//---------------------------------
// Sends an HTTP 400 failure

public static function http400Fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 400 Bad Request".$msg);
exit(1);
}

//---------------------------------
// Sends an HTTP 403 failure

public static function http403Fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 403 Forbidden".$msg);
exit(1);
}

//---------------------------------
// Sends an HTTP 404 failure

public static function http404Fail($msg='')
{
if ($msg!='') $msg=' - '.$msg;
header("HTTP/1.0 404 Not Found".$msg);
exit(1);
}

//---------------------------------
// Sends a mime header

public static function mimeHeader($type)
{
header("Content-type: $type");
}

//----------
} // End of class
//=============================================================================
?>
<?php
/**
* @category phool
* @package phool
*/
//============================================================================
/**
* This file is adapted from the PEAR Services_JSON package version 1.0.3,
* available at http://pear.php.net/package/Services_JSON.
*
* Changes from PEAR version:
*		- switch to PHP 5 object syntax
*		- make independant from PEAR error handling using exceptions . Also
*		  remove SERVICES_JSON_SUPPRESS_ERRORS flag (replace with a try/catch
*		  construct)
*/

namespace Phool\Web;

/**
 * Converts to and from JSON format.
 *
 * JSON (JavaScript Object Notation) is a lightweight data-interchange
 * format. It is easy for humans to read and write. It is easy for machines
 * to parse and generate. It is based on a subset of the JavaScript
 * Programming Language, Standard ECMA-262 3rd Edition - December 1999.
 * This feature can also be found in  Python. JSON is a text format that is
 * completely language independent but uses conventions that are familiar
 * to programmers of the C-family of languages, including C, C++, C#, Java,
 * JavaScript, Perl, TCL, and many others. These properties make JSON an
 * ideal data-interchange language.
 *
 * This package provides a simple encoder and decoder for JSON notation. It
 * is intended for use with client-side Javascript applications that make
 * use of HTTPRequest to perform server communication functions - data can
 * be encoded into JSON notation for use in a client-side javascript, or
 * decoded from incoming Javascript requests. JSON format is native to
 * Javascript, and can be directly eval()'ed with no further parsing
 * overhead
 *
 * All strings should be in ASCII or UTF-8 format!
 *
 * LICENSE: Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met: Redistributions of source code must retain the
 * above copyright notice, this list of conditions and the following
 * disclaimer. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * @category
 * @package     Services_JSON
 * @author      Michal Migurski <mike-json@teczno.com>
 * @author      Matt Knapp <mdknapp[at]gmail[dot]com>
 * @author      Brett Stimmerman <brettstimmerman[at]gmail[dot]com>
 * @author      Francois Laupretre <francois@tekwire.net>
 * @copyright   2005 Michal Migurski
 * @version     CVS: $Id: JSON.php,v 1.31 2006/06/28 05:54:17 migurski Exp $
 * @license     http://www.opensource.org/licenses/bsd-license.php
 * @link        http://pear.php.net/pepr/pepr-proposal-show.php?id=198
 */

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
const SERVICES_JSON_SLICE=1;

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
const SERVICES_JSON_IN_STR=2;

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
const SERVICES_JSON_IN_ARR=3;

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
const SERVICES_JSON_IN_OBJ=4;

/**
 * Marker constant for Services_JSON::decode(), used to flag stack state
 */
const SERVICES_JSON_IN_CMT=5;

/**
 * Behavior switch for Services_JSON::decode()
 */
const SERVICES_JSON_LOOSE_TYPE=16;

/**
 * Converts to and from JSON format.
 *
 * Brief example of use:
 *
 * <code>
 * // create a new instance of Services_JSON
 * $json = new \Phool\Web\Services_JSON();
 *
 * // convert a complexe value to JSON notation, and send it to the browser
 * $value = array('foo', 'bar', array(1, 2, 'baz'), array(3, array(4)));
 * $output = $json->encode($value);
 *
 * print($output);
 * // prints: ["foo","bar",[1,2,"baz"],[3,[4]]]
 *
 * // accept incoming POST data, assumed to be in JSON notation
 * $input = file_get_contents('php://input', 1000000);
 * $value = $json->decode($input);
 * </code>
 */
class Services_JSON
{
   /**
    * constructs a new JSON instance
    */

	/** @var int object behavior flags; combine with boolean-OR */

	private $use;

	/**
    * @param    int     $use    object behavior flags; combine with boolean-OR
    *
    *                           possible values:
    *                           - SERVICES_JSON_LOOSE_TYPE:  loose typing.
    *                                   "{...}" syntax creates associative arrays
    *                                   instead of objects in decode().
    */
    public function __construct($use = 0)
    {
        $this->use = $use;
    }

   /**
    * convert a string from one UTF-16 char to one UTF-8 char
    *
    * Normally should be handled by mb_convert_encoding, but
    * provides a slower PHP-only method for installations
    * that lack the multibye string extension.
    *
    * @param    string  $utf16  UTF-16 character
    * @return   string  UTF-8 character
    */
    private function utf162utf8($utf16)
    {
        // oh please oh please oh please oh please oh please
        if(function_exists('mb_convert_encoding')) {
            return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16');
        }

        $bytes = (ord($utf16{0}) << 8) | ord($utf16{1});

        switch(true) {
            case ((0x7F & $bytes) == $bytes):
                // this case should never be reached, because we are in ASCII range
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0x7F & $bytes);

            case (0x07FF & $bytes) == $bytes:
                // return a 2-byte UTF-8 character
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0xC0 | (($bytes >> 6) & 0x1F))
                     . chr(0x80 | ($bytes & 0x3F));

            case (0xFFFF & $bytes) == $bytes:
                // return a 3-byte UTF-8 character
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0xE0 | (($bytes >> 12) & 0x0F))
                     . chr(0x80 | (($bytes >> 6) & 0x3F))
                     . chr(0x80 | ($bytes & 0x3F));
        }

        // ignoring UTF-32 for now, sorry
        return '';
    }

   /**
    * convert a string from one UTF-8 char to one UTF-16 char
    *
    * Normally should be handled by mb_convert_encoding, but
    * provides a slower PHP-only method for installations
    * that lack the multibye string extension.
    *
    * @param    string  $utf8   UTF-8 character
    * @return   string  UTF-16 character
    */
    private function utf82utf16($utf8)
    {
        // oh please oh please oh please oh please oh please
        if(function_exists('mb_convert_encoding')) {
            return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8');
        }

        switch(strlen($utf8)) {
            case 1:
                // this case should never be reached, because we are in ASCII range
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return $utf8;

            case 2:
                // return a UTF-16 character from a 2-byte UTF-8 char
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr(0x07 & (ord($utf8{0}) >> 2))
                     . chr((0xC0 & (ord($utf8{0}) << 6))
                         | (0x3F & ord($utf8{1})));

            case 3:
                // return a UTF-16 character from a 3-byte UTF-8 char
                // see: http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                return chr((0xF0 & (ord($utf8{0}) << 4))
                         | (0x0F & (ord($utf8{1}) >> 2)))
                     . chr((0xC0 & (ord($utf8{1}) << 6))
                         | (0x7F & ord($utf8{2})));
        }

        // ignoring UTF-32 for now, sorry
        return '';
    }

   /**
    * encodes an arbitrary variable into JSON format
    *
    * @param    mixed   $var    any number, boolean, string, array, or object to be encoded.
    *                           see argument 1 to Services_JSON() above for array-parsing behavior.
    *                           if var is a strng, note that encode() always expects it
    *                           to be in ASCII or UTF-8 format!
    *
    * @return   mixed   JSON string representation of input var
    * @throws Exception if a problem occurs
    */
    public function encode($var)
    {
        switch (gettype($var)) {
            case 'boolean':
                return $var ? 'true' : 'false';

            case 'NULL':
                return 'null';

            case 'integer':
                return (int) $var;

            case 'double':
            case 'float':
                return (float) $var;

            case 'string':
                // STRINGS ARE EXPECTED TO BE IN ASCII OR UTF-8 FORMAT
                $ascii = '';
                $strlen_var = strlen($var);

               /*
                * Iterate over every character in the string,
                * escaping with a slash or encoding to UTF-8 where necessary
                */
                for ($c = 0; $c < $strlen_var; ++$c) {

                    $ord_var_c = ord($var{$c});

                    switch (true) {
                        case $ord_var_c == 0x08:
                            $ascii .= '\b';
                            break;
                        case $ord_var_c == 0x09:
                            $ascii .= '\t';
                            break;
                        case $ord_var_c == 0x0A:
                            $ascii .= '\n';
                            break;
                        case $ord_var_c == 0x0C:
                            $ascii .= '\f';
                            break;
                        case $ord_var_c == 0x0D:
                            $ascii .= '\r';
                            break;

                        case $ord_var_c == 0x22:
                        case $ord_var_c == 0x2F:
                        case $ord_var_c == 0x5C:
                            // double quote, slash, slosh
                            $ascii .= '\\'.$var{$c};
                            break;

                        case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)):
                            // characters U-00000000 - U-0000007F (same as ASCII)
                            $ascii .= $var{$c};
                            break;

                        case (($ord_var_c & 0xE0) == 0xC0):
                            // characters U-00000080 - U-000007FF, mask 110XXXXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c, ord($var{$c + 1}));
                            $c += 1;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xF0) == 0xE0):
                            // characters U-00000800 - U-0000FFFF, mask 1110XXXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}));
                            $c += 2;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xF8) == 0xF0):
                            // characters U-00010000 - U-001FFFFF, mask 11110XXX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}));
                            $c += 3;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xFC) == 0xF8):
                            // characters U-00200000 - U-03FFFFFF, mask 111110XX
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}),
                                         ord($var{$c + 4}));
                            $c += 4;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;

                        case (($ord_var_c & 0xFE) == 0xFC):
                            // characters U-04000000 - U-7FFFFFFF, mask 1111110X
                            // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                            $char = pack('C*', $ord_var_c,
                                         ord($var{$c + 1}),
                                         ord($var{$c + 2}),
                                         ord($var{$c + 3}),
                                         ord($var{$c + 4}),
                                         ord($var{$c + 5}));
                            $c += 5;
                            $utf16 = $this->utf82utf16($char);
                            $ascii .= sprintf('\u%04s', bin2hex($utf16));
                            break;
                    }
                }

                return '"'.$ascii.'"';

            case 'array':
               /*
                * As per JSON spec if any array key is not an integer
                * we must treat the the whole array as an object. We
                * also try to catch a sparsely populated associative
                * array with numeric keys here because some JS engines
                * will create an array with empty indexes up to
                * max_index which can cause memory issues and because
                * the keys, which may be relevant, will be remapped
                * otherwise.
                *
                * As per the ECMA and JSON specification an object may
                * have any string as a property. Unfortunately due to
                * a hole in the ECMA specification if the key is a
                * ECMA reserved word or starts with a digit the
                * parameter is only accessible using ECMAScript's
                * bracket notation.
                */

                // treat as a JSON object
                if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) {
                    $properties = array_map(array($this, 'name_value'),
                                            array_keys($var),
                                            array_values($var));
                    return '{' . join(',', $properties) . '}';
                }

                // treat it like a regular array
                $elements = array_map(array($this, 'encode'), $var);
                return '[' . join(',', $elements) . ']';

            case 'object':
                $vars = get_object_vars($var);

                $properties = array_map(array($this, 'name_value'),
                                        array_keys($vars),
                                        array_values($vars));
                return '{' . join(',', $properties) . '}';

            default:
                 throw new \Exception(gettype($var)." can not be encoded as JSON string");
        }
    }

   /**
    * array-walking function for use in generating JSON-formatted name-value pairs
    *
    * @param    string  $name   name of key to use
    * @param    mixed   $value  reference to an array element to be encoded
    *
    * @return   string  JSON-formatted name-value pair, like '"name":value'
    */
    private function name_value($name, $value)
    {
        return $this->encode(strval($name)) . ':' . $this->encode($value);
    }

   /**
    * reduce a string by removing leading and trailing comments and whitespace
    *
    * @param    $str    string      string value to strip of comments and whitespace
    *
    * @return   string  string value stripped of comments and whitespace
    */
    private function reduce_string($str)
    {
        $str = preg_replace(array(

                // eliminate single line comments in '// ...' form
                '#^\s*//(.+)$#m',

                // eliminate multi-line comments in '/* ... */' form, at start of string
                '#^\s*/\*(.+)\*/#Us',

                // eliminate multi-line comments in '/* ... */' form, at end of string
                '#/\*(.+)\*/\s*$#Us'

            ), '', $str);

        // eliminate extraneous space
        return trim($str);
    }

   /**
    * decodes a JSON string into appropriate variable
    *
    * @param    string  $str    JSON-formatted string
    *
    * @return   mixed   number, boolean, string, array, or object
    *                   corresponding to given JSON input string.
    *                   See argument 1 to Services_JSON() above for object-output behavior.
    *                   Note that decode() always returns strings
    *                   in ASCII or UTF-8 format!
    */
    public function decode($str)
    {
        $str = $this->reduce_string($str);

        switch (strtolower($str)) {
            case 'true':
                return true;

            case 'false':
                return false;

            case 'null':
                return null;

            default:
                $m = array();

                if (is_numeric($str)) {
                    // Lookie-loo, it's a number

                    // This would work on its own, but I'm trying to be
                    // good about returning integers where appropriate:
                    // return (float)$str;

                    // Return float or int, as appropriate
                    return ((float)$str == (integer)$str)
                        ? (integer)$str
                        : (float)$str;

                } elseif (preg_match('/^("|\').*(\1)$/s', $str, $m) && $m[1] == $m[2]) {
                    // STRINGS RETURNED IN UTF-8 FORMAT
                    $delim = substr($str, 0, 1);
                    $chrs = substr($str, 1, -1);
                    $utf8 = '';
                    $strlen_chrs = strlen($chrs);

                    for ($c = 0; $c < $strlen_chrs; ++$c) {

                        $substr_chrs_c_2 = substr($chrs, $c, 2);
                        $ord_chrs_c = ord($chrs{$c});

                        switch (true) {
                            case $substr_chrs_c_2 == '\b':
                                $utf8 .= chr(0x08);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\t':
                                $utf8 .= chr(0x09);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\n':
                                $utf8 .= chr(0x0A);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\f':
                                $utf8 .= chr(0x0C);
                                ++$c;
                                break;
                            case $substr_chrs_c_2 == '\r':
                                $utf8 .= chr(0x0D);
                                ++$c;
                                break;

                            case $substr_chrs_c_2 == '\\"':
                            case $substr_chrs_c_2 == '\\\'':
                            case $substr_chrs_c_2 == '\\\\':
                            case $substr_chrs_c_2 == '\\/':
                                if (($delim == '"' && $substr_chrs_c_2 != '\\\'') ||
                                   ($delim == "'" && $substr_chrs_c_2 != '\\"')) {
                                    $utf8 .= $chrs{++$c};
                                }
                                break;

                            case preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6)):
                                // single, escaped unicode character
                                $utf16 = chr(hexdec(substr($chrs, ($c + 2), 2)))
                                       . chr(hexdec(substr($chrs, ($c + 4), 2)));
                                $utf8 .= $this->utf162utf8($utf16);
                                $c += 5;
                                break;

                            case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F):
                                $utf8 .= $chrs{$c};
                                break;

                            case ($ord_chrs_c & 0xE0) == 0xC0:
                                // characters U-00000080 - U-000007FF, mask 110XXXXX
                                //see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 2);
                                ++$c;
                                break;

                            case ($ord_chrs_c & 0xF0) == 0xE0:
                                // characters U-00000800 - U-0000FFFF, mask 1110XXXX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 3);
                                $c += 2;
                                break;

                            case ($ord_chrs_c & 0xF8) == 0xF0:
                                // characters U-00010000 - U-001FFFFF, mask 11110XXX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 4);
                                $c += 3;
                                break;

                            case ($ord_chrs_c & 0xFC) == 0xF8:
                                // characters U-00200000 - U-03FFFFFF, mask 111110XX
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 5);
                                $c += 4;
                                break;

                            case ($ord_chrs_c & 0xFE) == 0xFC:
                                // characters U-04000000 - U-7FFFFFFF, mask 1111110X
                                // see http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
                                $utf8 .= substr($chrs, $c, 6);
                                $c += 5;
                                break;

                        }

                    }

                    return $utf8;

                } elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) {
                    // array, or object notation

                    if ($str{0} == '[') {
                        $stk = array(SERVICES_JSON_IN_ARR);
                        $arr = array();
                    } else {
                        if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                            $stk = array(SERVICES_JSON_IN_OBJ);
                            $obj = array();
                        } else {
                            $stk = array(SERVICES_JSON_IN_OBJ);
                            $obj = new \stdClass();
                        }
                    }

                    array_push($stk, array('what'  => SERVICES_JSON_SLICE,
                                           'where' => 0,
                                           'delim' => false));

                    $chrs = substr($str, 1, -1);
                    $chrs = $this->reduce_string($chrs);

                    if ($chrs == '') {
                        if (reset($stk) == SERVICES_JSON_IN_ARR) {
                            return $arr;

                        } else {
                            return $obj;

                        }
                    }

                    //print("\nparsing {$chrs}\n");

                    $strlen_chrs = strlen($chrs);

                    for ($c = 0; $c <= $strlen_chrs; ++$c) {

                        $top = end($stk);
                        $substr_chrs_c_2 = substr($chrs, $c, 2);

                        if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) {
                            // found a comma that is not inside a string, array, etc.,
                            // OR we've reached the end of the character list
                            $slice = substr($chrs, $top['where'], ($c - $top['where']));
                            array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false));
                            //print("Found split at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                            if (reset($stk) == SERVICES_JSON_IN_ARR) {
                                // we are in an array, so just push an element onto the stack
                                array_push($arr, $this->decode($slice));

                            } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {
                                // we are in an object, so figure
                                // out the property name and set an
                                // element in an associative array,
                                // for now
                                $parts = array();
                                
                                if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {
                                    // "name":value pair
                                    $key = $this->decode($parts[1]);
                                    $val = $this->decode($parts[2]);

                                    if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                                        $obj[$key] = $val;
                                    } else {
                                        $obj->$key = $val;
                                    }
                                } elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) {
                                    // name:value pair, where name is unquoted
                                    $key = $parts[1];
                                    $val = $this->decode($parts[2]);

                                    if ($this->use & SERVICES_JSON_LOOSE_TYPE) {
                                        $obj[$key] = $val;
                                    } else {
                                        $obj->$key = $val;
                                    }
                                }

                            }

                        } elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) && ($top['what'] != SERVICES_JSON_IN_STR)) {
                            // found a quote, and we are not inside a string
                            array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c}));
                            //print("Found start of string at {$c}\n");

                        } elseif (($chrs{$c} == $top['delim']) &&
                                 ($top['what'] == SERVICES_JSON_IN_STR) &&
                                 ((strlen(substr($chrs, 0, $c)) - strlen(rtrim(substr($chrs, 0, $c), '\\'))) % 2 != 1)) {
                            // found a quote, we're in a string, and it's not escaped
                            // we know that it's not escaped becase there is _not_ an
                            // odd number of backslashes at the end of the string so far
                            array_pop($stk);
                            //print("Found end of string at {$c}: ".substr($chrs, $top['where'], (1 + 1 + $c - $top['where']))."\n");

                        } elseif (($chrs{$c} == '[') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a left-bracket, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false));
                            //print("Found start of array at {$c}\n");

                        } elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) {
                            // found a right-bracket, and we're in an array
                            array_pop($stk);
                            //print("Found end of array at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        } elseif (($chrs{$c} == '{') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a left-brace, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false));
                            //print("Found start of object at {$c}\n");

                        } elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) {
                            // found a right-brace, and we're in an object
                            array_pop($stk);
                            //print("Found end of object at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        } elseif (($substr_chrs_c_2 == '/*') &&
                                 in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) {
                            // found a comment start, and we are in an array, object, or slice
                            array_push($stk, array('what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false));
                            $c++;
                            //print("Found start of comment at {$c}\n");

                        } elseif (($substr_chrs_c_2 == '*/') && ($top['what'] == SERVICES_JSON_IN_CMT)) {
                            // found a comment end, and we're in one now
                            array_pop($stk);
                            $c++;

                            for ($i = $top['where']; $i <= $c; ++$i)
                                $chrs = substr_replace($chrs, ' ', $i, 1);

                            //print("Found end of comment at {$c}: ".substr($chrs, $top['where'], (1 + $c - $top['where']))."\n");

                        }

                    }

                    if (reset($stk) == SERVICES_JSON_IN_ARR) {
                        return $arr;

                    } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) {
                        return $obj;

                    }

                }
        }
    }
}    
?>
<?php
//============================================================================
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License (LGPL) as
// published by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//============================================================================
/**
* @copyright Francois Laupretre <phool@tekwire.net>
* @license http://www.apache.org/licenses/LICENSE-2.0 Apache License, V 2.0
* @category phool
* @package phool
*/
//============================================================================
//----------------------------------------------------------------------------
/**
* This class allows to browse an XML or XHTML document
*/
//----------------------------------------------------------------------------

//error_reporting(E_ERROR | E_CORE_ERROR | E_USER_ERROR);

//----------------------------------------------------------------------------

namespace Phool\XML;

class XPage
{

/** @var string Buffer containing the document

public $page;

/** @var DOMDocument The document as a DOMDocument instance */

public $xdoc=null;

#--------
/** Creates the DOM instance and imports the data
*
* @param string $data The content of the page/document
* @param boolean $html Is the format html (or xml) ?
* @returns void
* @throws DOMException
*/

public function __construct($data,$html=true)
{
$this->page=$data;
$this->xdoc=new \DOMDocument;

$method=($html ? 'loadHTML' : 'loadXML');
if (!@$this->xdoc->$method($data))
	throw new \DOMException('Cannot load data');
}

#--------
/**
* Returns a list of nodes corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNodeList (can be empty)
*/

public function nodes($xpath,$base=null)
{
$xp=new \DOMXPath($this->xdoc);
if (is_null($base)) $base=$this->xdoc->documentElement;
$n=$xp->query($xpath,$base);
unset($xp);
return $n;
}

//------------
/**
* Returns the first node corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNode|null null if no match
*/

public function node($xpath,$base=null)
{
$node_list=$this->nodes($xpath,$base);
return ($node_list->length ? $node_list->item(0) : null);
}

//------------
/**
* Returns the last node corresponding to an XPath
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns DOMNode|null null if no match
*/

public function lastNode($xpath,$base=null)
{
$node_list=$this->nodes($xpath,$base);
return ($node_list->length ? $node_list->item($node_list->length-1) : null);
}

#--------
/**
* Returns the values of the nodes corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns array empty if no match
*/

public function values($xpath,$base=null)
{
$a=array();
$res=$this->nodes($xpath,$base);
if (!$res->length) return $a;
foreach($res as $node) $a[]=$node->nodeValue;
return $a;
}

#--------
/**
* Returns the value of the first node corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns string|null null if no match
*/

public function value($xpath,$base=null)
{
$node=$this->node($xpath,$base);

return (($node===null) ? null : $node->nodeValue);
}

#--------
/**
* Returns the number of nodes corresponding to an XPath (nodeValue)
*
* @param string $xpath The xpath string
* @param DOMElement|null The search base(if null, starts from the root node)
*
* @returns int
*/

public function nb($xpath,$base=null)
{
return $this->nodes($xpath,$base)->length;
}

#--------
/**
* Returns the text and target of an hyperlink node as an
* array('text' => <text>, 'url' => <target>)
*
* @param DOMNode $node Node of type 'a'
*
* @returns array(text,url)
*
* @throws Exception
*/

public static function aInfo($node)
{
if ((! $node instanceof DOMElement))
	throw new \Exception('Arg should be a DOMElement');

if ($node->tagName != 'a')
	throw new \Exception('Node should be an anchor ('.$node->tagName.')');

return array('text' => $node->textContent
	,'url' => $node->attributes->getNamedItem('href')->nodeValue);
}

#--------

public function recursiveBackNodes($start_node,$item)
{
$a=array();
$node=$start_node;

while (true)
	{
	$nodes=$this->nodes($item,$node);
	if ($nodes->length)
		{
		for ($i=0;$i<$nodes->length;$i++) $a[]=$nodes->item($i);
		}
	if ($node->isSameNode($this->xdoc)) break; // if root node
	$node=$node->parentNode;
	}
return $a;
}

#--------

public function recursiveBackNode($start_node,$item)
{
$nodes=$this->recursiveBackNodes($start_node,$item);
return ((count($nodes)==0) ? null : $nodes[0]);
}

#--------

public function recursiveBackValues($start_node,$item)
{
$a=array();
foreach ($this->recursiveBackNodes($start_node,$item) as $node)
	$a[]=$node->nodeValue;
return $a;
}

#--------

public function recursiveBackValue($start_node,$item)
{
$node=$this->recursiveBackNode($start_node,$item);
return (is_null($node) ? null : $node->nodeValue);
}

//----------
} // End of class XPage
//=============================================================================
?>
<p align="center">
Apache License<br />
Version 2.0, January 2004<br />
<a href="http://www.apache.org/licenses/">http://www.apache.org/licenses/</a>
</p>
<p>
TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
</p>
<p><b><a name="definitions">1. Definitions</a></b>.</p>
<p>
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
</p>
<p>
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
</p>
<p>
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
</p>
<p>
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
</p>
<p>
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
</p>
<p>
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
</p>
<p>
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
</p>
<p>
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
</p>
<p>
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
</p>
<p>
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
</p>
<p><b><a name="copyright">2. Grant of Copyright License</a></b>.
Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
</p>
<p><b><a name="patent">3. Grant of Patent License</a></b>.
Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
</p>
<p><b><a name="redistribution">4. Redistribution</a></b>.
You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
<ol type="a">
<li>You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
<br /> <br /></li>

<li>You must cause any modified files to carry prominent notices
          stating that You changed the files; and
<br /> <br /></li>

<li>You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
<br /> <br /></li>

<li>If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.</li>
</ol>
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
</p>
<p><b><a name="contributions">5. Submission of Contributions</a></b>.
Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
</p>
<p><b><a name="trademarks">6. Trademarks</a></b>.
This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
</p>
<p><b><a name="no-warranty">7. Disclaimer of Warranty</a></b>.
Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
</p>
<p><b><a name="no-liability">8. Limitation of Liability</a></b>.
In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
</p>
<p><b><a name="additional">9. Accepting Warranty or Additional Liability</a></b>.
While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.
</p>
<p>
END OF TERMS AND CONDITIONS
</p>
</div>

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
